#+SETUPFILE: ./_setup.org
#+TITLE: Vincent Demeester's .emacs.d

* Overview
:PROPERTIES:
:CUSTOM_ID: h:958fee2e-86db-4d34-bef6-d5b4f4f73000
:END:
** Canonical links to this document
:PROPERTIES:
:CUSTOM_ID: h:11f5b93f-6dd7-483c-aa44-e10471f17c22
:END:

+ HTML version :: [[https://sbr.pm/dotemacs][sbr.pm/dotemacs]]
+ Git repo :: [[https://github.com/vdemeester/emacs-config.git][github.com/vdemeester/emacs-config]]

** What is this
:PROPERTIES:
:CUSTOM_ID: h:e9d0ae1c-244c-4ad9-b0dc-c5e53b8d49ea
:END:

The present document, referred to in the source code version as =emacs.org=, contains the
bulk of my configurations for GNU Emacs. It is designed using principles of "literate
programming": a combination of ordinary language and inline code blocks. Emacs knows how
to parse this file properly so as to evaluate only the elisp ("Emacs Lisp") included
herein. The rest is for humans to make sense of my additions and their underlying
rationale.

#+BEGIN_QUOTE
Literate programming allows us to be more expressive and deliberate. Not only we can use
typography to its maximum potential, but can also employ techniques such as internal links
between sections. This makes the end product much better for end users, than a terse
script.
#+END_QUOTE

I switched back and forth on using =org-mode= and literate programming, so why re-using
it. First, I think I went for it the wrong way the first time. I copied part of the
configuration from elsewhere, sometimes without really needing what I was copying. for
some reason I think this is a common pattern when configuring Emacs. You start by using a
distribution (Doom Emacs, Spacemacs, …) or by copying configuration from all over the
place. Slowly but surely you realize this was a mistake as you didn't learn anything, so
you *reboot* your configuration.

I'm taking [[https://protesilaos.com/][Protesilaos Stavrou]] approach on writing and configuring this file (see [[https://protesilaos.com/dotemacs/][his
dotemacs]]), although I am not loading it directly. I prefer using the [[https://orgmode.org/manual/tangle.html][tangle]] feature of
=org-mode= instead of loading it using ~org-babel~ function. This allows me to document my
configuration and generating final(s) ~.el~ files. Those files can then load and/or
pre-compile, without the need to load =org= first. It also means that I can add code
pieces in there that won't be /tangle/, like usage example ; and I also can use this to
generate any additional file I need, whatever the programming language they are written
in.
** COPYING
:PROPERTIES:
:CUSTOM_ID: h:13ded0f2-230e-406f-85e1-979aca3b4cd6
:END:

Copyright (c) 2013-2020 Vincent Demeester <vincent@sbr.pm>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

* TODO Base settings
:PROPERTIES:
:CUSTOM_ID: h:b5ee7306-620f-4ab8-9da5-a6c8781a93b5
:END:

This section contains configurations that are needed prior to the setup of everything
else. Anything that needs to be configured first should be in there, this includes the
~init.el~ and ~early-init.el~ files content.

Starting with Emacs 27, an =early-init.el= file can be used to do early configuration
and optimization.

#+begin_quote
Emacs can now be configured using an early init file. The file is called ~early-init.el~,
in ~user-emacs-directory~. It is loaded very early in the startup process: before
graphical elements such as the tool bar are initialized, and before the package manager is
initialized. The primary purpose is to allow customizing how the package system is
initialized given that initialization now happens before loading the regular init file
(see below).

We recommend against putting any customizations in this file that don't need to be set up
before initializing installed add-on packages, because the early init file is read too
early into the startup process, and some important parts of the Emacs session, such as
'window-system' and other GUI features, are not yet set up, which could make some
customization fail to work.
#+end_quote

We can use this to our advantage and optimize the initial loading of emacs.

- Before Emacs 27, the init file was responsible for initializing the package manager by
  calling `package-initialize'.  Emacs 27 changed the default behavior: It now calls
  `package-initialize' before loading the init file.

  #+begin_src emacs-lisp :tangle early-init.el
    (setq package-enable-at-startup nil)
  #+end_src

- Let's inhibit resizing the frame at early stage.

  #+begin_src emacs-lisp :tangle early-init.el
    (setq frame-inhibit-implied-resize t)
  #+end_src

- I never use the /menu-bar/, or the /tool-bar/ or even the /scroll-bar/, so we can safely
  disable those very very early.

  #+begin_src emacs-lisp :tangle early-init.el
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (horizontal-scroll-bar-mode -1)
  #+end_src

- Finally we can try to avoid garbage collection at startup. The garbage collector can
  easily double startup time, so we suppress it at startup by turning up ~gc-cons-threshold~
  (and perhaps ~gc-cons-percentage~) temporarily.

  #+begin_src emacs-lisp :tangle early-init.el
    (setq gc-cons-threshold 402653184
          gc-cons-percentage 0.6)
  #+end_src

  However, it is important to reset it eventually. Not doing so will cause garbage
  collection freezes during long-term interactive use. Conversely, a ~gc-cons-threshold~
  that is too small will cause stuttering.

  #+begin_src emacs-lisp :tangle early-init.el
    (add-hook 'after-init-hook
              `(lambda ()
                 (setq gc-cons-threshold 16777216 ; 16mb
                       gc-cons-percentage 0.1)
                 (garbage-collect)) t)
  #+end_src

One thing though, I am currently not necessarily running Emacs 27, so I am going to need
to have the same configuration in ~init.el~ for a little bit of time.

#+begin_src emacs-lisp :tangle init.el
  ;;; -*- lexical-binding: t; -*-
  (defconst emacs-start-time (current-time))

  (when (< emacs-major-version 27)
    (setq package-enable-at-startup nil)

    (setq frame-inhibit-implied-resize)

    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (horizontal-scroll-bar-mode -1)

    (setq gc-cons-threshold 402653184
          gc-cons-percentage 0.6)

    (add-hook 'after-init-hook
              `(lambda ()
                 (setq gc-cons-threshold 16777216 ; 16mb
                       gc-cons-percentage 0.1)
                 (garbage-collect)) t))
#+end_src


* TODO Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: h:571cf8bc-a359-4d75-9d56-b35c22126cf2
:END:

* TODO Directory, buffer and window management
:PROPERTIES:
:CUSTOM_ID: h:d93bf4bc-62c9-4873-a80e-4ddd874d64c4
:END:

* TODO Applications and utilities
:PROPERTIES:
:CUSTOM_ID: h:9bb3e4bd-c13a-4311-8af7-588fb0386a03
:END:

* TODO Programming
:PROPERTIES:
:CUSTOM_ID: h:a6c9891a-6195-4987-b98f-fd06e1147b47
:END:
* Legacy
:PROPERTIES:
:CUSTOM_ID: h:66d47486-8c74-4028-a9c7-8cfe75c07e1a
:END:

This holds legacy code from the previous configuration (without org-mode). This will
slowly but surely move into an org-mode header and or disappear.

** Configurations
:PROPERTIES:
:CUSTOM_ID: h:2080e917-9414-4a08-8fb8-f3cdbedf8642
:END:

These are the initial configuration files to be imported in this file slowly but surely.

*** ~init.el~
:PROPERTIES:
:CUSTOM_ID: h:7a634a4a-7d15-4c66-b65d-8b5a682fe029
:END:

#+begin_src emacs-lisp :tangle init.el
  (defvar file-name-handler-alist-old file-name-handler-alist)

  (setq file-name-handler-alist nil
        message-log-max 16384
        auto-window-vscroll nil)

  (let ((minver 25))
    (unless (>= emacs-major-version minver)
      (error "Your Emacs is too old -- this configuration requrise v%s or higher" minver)))

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-language-environment 'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)

  ;;; package setup
  (require 'package)

  (setq package-archives
        '(("melpa" . "http://melpa.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("org" . "https://orgmode.org/elpa/")
          ("gnu" . "https://elpa.gnu.org/packages/")))

  (setq package-archive-priorities
        '(("melpa-stable" . 4)
          ("melpa" .  3)
          ("org" . 2)
          ("gnu" . 1)))

  (require 'tls)

  ;; From https://github.com/hlissner/doom-emacs/blob/5dacbb7cb1c6ac246a9ccd15e6c4290def67757c/core/core-packages.el#L102
  (setq gnutls-verify-error (not (getenv "INSECURE")) ; you shouldn't use this
        tls-checktrust gnutls-verify-error
        tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                          ;; compatibility fallbacks
                          "gnutls-cli -p %p %h"
                          "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof"))

  ;; Initialise the packages, avoiding a re-initialisation.
  (unless (bound-and-true-p package--initialized)
    (setq package-enable-at-startup nil)
    (package-initialize))

  (setq load-prefer-newer t)              ; Always load newer compiled files
  (setq ad-redefinition-action 'accept)   ; Silence advice redefinition warnings

  ;; Init `delight'
  (unless (package-installed-p 'delight)
    (package-refresh-contents)
    (package-install 'delight))

  ;; Configure `use-package' prior to loading it.
  (eval-and-compile
    (setq use-package-always-ensure nil)
    (setq use-package-always-defer nil)
    (setq use-package-always-demand nil)
    (setq use-package-expand-minimally nil)
    (setq use-package-enable-imenu-support t))

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))

  (use-package dash) ; A modern list library

  (use-package use-package-ensure-system-package :ensure t :pin melpa)

  (require 'subr-x)
  (require 'time-date)

  ;;; Initialization
  (setq inhibit-default-init t)           ; Disable the site default settings

  (use-package exec-path-from-shell       ; Set up environment variables
    :if (display-graphic-p)
    :unless (eq system-type 'windows-nt)
    :config
    (setq exec-path-from-shell-variables
          '("PATH"               ; Full path
            "INFOPATH"           ; Info directories
            "GOPATH"             ; Golang path
            ))

    (exec-path-from-shell-initialize))

  ;; Set separate custom file for the customize interface
  (defconst vde/custom-file (locate-user-emacs-file "custom.el")
    "File used to store settings from Customization UI.")

  (use-package cus-edit                   ; Set up custom.el
    :defer t
    :config
    (setq
     custom-file vde/custom-file
     custom-buffer-done-kill nil          ; Kill when existing
     custom-buffer-verbose-help nil       ; Remove redundant help text
     custom-unlispify-tag-names nil       ; Show me the real variable name
     custom-unlispify-menu-entries nil)
    :init (load vde/custom-file 'no-error 'no-message))

  (use-package no-littering               ; Keep .emacs.d clean
    :config
    (require 'recentf)
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory)

    (setq
     create-lockfiles nil
     delete-old-versions t
     kept-new-versions 6
     kept-old-versions 2
     version-control t)

    (setq
     backup-directory-alist
     `((".*" . ,(no-littering-expand-var-file-name "backup/")))
     auto-save-file-name-transforms
     `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))

  (setenv "PAGER" "cat")
  (setenv "TERM" "xterm-256color")
  (setenv "NOTMUCH_CONFIG" (expand-file-name ".config/notmuch/notmuchrc" (getenv "HOME")))

  (use-package server                     ; The server of `emacsclient'
    :config (or (server-running-p) (server-mode)))

  (use-package pinentry
    :config
    (setenv "INSIDE_EMACS" (format "%s,comint" emacs-version))
    (pinentry-start))

  ;; Confirm before quitting Emacs
  (setq confirm-kill-emacs #'y-or-n-p)

  ;;; Require files under ~/.emacs.d/lisp
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

  ;; Enable `vde-mode' unless `disable-pkg-vde-mode' is set to `t' in
  ;; `setup-var-overrides.el'.
  (when (not (bound-and-true-p disable-pkg-setup-mode))
    (use-package setup-vde-mode))

  (use-package setup-style)
  (use-package setup-keybindings)
  (use-package setup-completion)
  (use-package setup-vcs)
  (use-package setup-dired)
  (use-package setup-search)
  (use-package setup-files)
  (use-package setup-editing)
  (use-package setup-multiple-cursors)
  (use-package setup-navigating)
  (use-package setup-windows)
  (use-package setup-buffers)
  (use-package setup-projectile)
  (use-package setup-shells)
  (use-package setup-compile)
  (use-package setup-org)
  ;; Programming languages
  (use-package setup-nix)
  (use-package setup-go)
  (use-package setup-web)
  (use-package setup-docker)
  (use-package setup-hydras)
  (use-package setup-browser)
  (use-package setup-notmuch)

  ;; C-up/down onn console
  (when (not window-system)
    (define-key function-key-map "\eO1;5A"    [C-up])
    (define-key function-key-map "\eO1;5B"  [C-down])
    (define-key function-key-map "\eO1;5C" [C-right])
    (define-key function-key-map "\eO1;5D"  [C-left])
    )

  (let ((elapsed (float-time (time-subtract (current-time)
                                            emacs-start-time))))
    (message "Loading %s...done (%.3fs)" load-file-name elapsed))

  (add-hook 'after-init-hook
            `(lambda ()
               (let ((elapsed
                      (float-time
                       (time-subtract (current-time) emacs-start-time))))
                 (message "Loading %s...done (%.3fs) [after-init]"
                          ,load-file-name elapsed))) t)

  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)

  (put 'magit-diff-edit-hunk-commit 'disabled nil)
  ;; Local Variables:
  ;; coding: utf-8
  ;; indent-tabs-mode: nil
  ;; End:
  ;;; Finalization
  ;;; init.el ends here
#+end_src

*** ~setup-browser.el~
:PROPERTIES:
:CUSTOM_ID: h:79089a4f-0e9c-428c-9269-9819c139f988
:END:

#+begin_src emacs-lisp :tangle lisp/setup-browser.el
  ;;; -*- lexical-binding: t; -*-
  (use-package shr
    :commands (eww
               eww-browse-url)
    :custom
    (browse-url-browser-function 'eww-browse-url)
    (shr-use-fonts nil)
    (shr-use-colors nil)
    (shr-max-image-proportion 0.2)
    (shr-width (current-fill-column)))

  (use-package shr-tag-pre-highlight
    :after shr
    :config
    (add-to-list 'shr-external-rendering-functions
                 '(pre . shr-tag-pre-highlight))
    (when (version< emacs-version "26")
      (with-eval-after-load 'eww
        (advice-add 'eww-display-html :around
                    'eww-display-html--override-shr-external-rendering-functions))))

  (use-package eww
    :defer t
    :init
    (setq browse-url-browser-function
          '((".*google.*maps.*" . browse-url-generic)
            ;; Github goes to firefox, but not gist
            ("http.*\/\/github.com" . browse-url-generic)
            ("http.*\/\/github.io" . browse-url-generic)
            ("http.*\/\/gitlab.com" . browse-url-generic)
            ("http.*\/\/gitlab.io" . browse-url-generic)
            ("groups.google.com" . browse-url-generic)
            ("docs.google.com" . browse-url-generic)
            ("melpa.org" . browse-url-generic)
            ("build.*\.elastic.co" . browse-url-generic)
            (".*-ci\.elastic.co" . browse-url-generic)
            ("internal-ci\.elastic\.co" . browse-url-generic)
            ("zendesk\.com" . browse-url-generic)
            ("salesforce\.com" . browse-url-generic)
            ("stackoverflow\.com" . browse-url-generic)
            ("apache\.org\/jira" . browse-url-generic)
            ("thepoachedegg\.net" . browse-url-generic)
            ("zoom.us" . browse-url-generic)
            ("blujeans.com" . browse-url-generic)
            ("t.co" . browse-url-generic)
            ("twitter.com" . browse-url-generic)
            ("\/\/a.co" . browse-url-generic)
            ("youtube.com" . browse-url-generic)
            ("amazon.com" . browse-url-generic)
            ("slideshare.net" . browse-url-generic)
            ("." . eww-browse-url)))
    (setq shr-external-browser 'browse-url-generic)
    (setq browse-url-generic-program (executable-find "firefox"))
    (add-hook 'eww-mode-hook #'toggle-word-wrap)
    (add-hook 'eww-mode-hook #'visual-line-mode)
    :config
    (define-key eww-mode-map "o" 'eww)
    (define-key eww-mode-map "O" 'eww-browse-with-external-browser))

  (provide 'setup-browser)
#+end_src

*** ~setup-buffers.el~
:PROPERTIES:
:CUSTOM_ID: h:3acb943f-4a00-432a-8f94-7da51a5c757c
:END:

#+begin_src emacs-lisp :tangle lisp/setup-buffers.el
  ;;; -*- lexical-binding: t; -*-
  ;; Don't let the cursor go into minibuffer prompt
  (let ((default (eval (car (get 'minibuffer-prompt-properties 'standard-value))))
        (dont-touch-prompt-prop '(cursor-intangible t)))
    (setq minibuffer-prompt-properties
          (append default dont-touch-prompt-prop))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))

  ;; Allow to read from minibuffer while in minibuffer.
  (setq enable-recursive-minibuffers t)

  ;; Show the minibuffer depth (when larger than 1)
  (minibuffer-depth-indicate-mode 1)

  (use-package savehist                   ; Save minibuffer history
    :init (savehist-mode t)
    :custom
    (history-length 1000)
    (savehist-save-minibuffer-history t)
    (savehist-autosave-interval 180)
    :config
    (savehist-mode 1))

  (use-package emacs
    :init
    ;; Configure `display-buffer' behaviour for some special buffers
    (setq display-buffer-alist
          '(;; bottom side window
            ("\\*e?shell.*"
             (display-buffer-in-side-window)
             (window-height . 0.25)
             (side . bottom)
             (slot . -1))
            ("\\*v?term.*"
             (display-buffer-in-side-window)
             (window-height . 0.25)
             (side . bottom)
             (slot . -1))
            ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|[Hh]elp\\|Messages\\)\\*"
             (display-buffer-in-side-window)
             (window-height . 0.25)
             (side . bottom)
             (slot . 0))
            ("\\*\\(compilation\\|go test\\).*"
             (display-buffer-in-side-window)
             (window-height . 0.25)
             (side . bottom)
             (slot . 0))
            ("\\*\\(ielm\\).*"
             (display-buffer-in-side-window)
             (window-height . 0.25)
             (side . bottom)
             (slot . 1))
            ;; right side window
            ("\\*wclock*"
             (display-buffer-in-side-window)
             (window-width . 0.333)
             (side . right)
             (slot . -1))
            ("\\*undo-tree*"
             (display-buffer-in-side-window)
             (window-width . 0.333)
             (side . right)
             (slot . -1))
            ("\\*\\(Flycheck\\|Package-Lint\\).*"
             (display-buffer-in-side-window)
             (window-width . 0.333)
             (side . right)
             (slot . 0)
             (window-parameters . ((no-other-window . t)
                                   (mode-line-format . (" "
                                                        mode-line-buffer-identification)))))
            ("\\*Faces\\*"
             (display-buffer-in-side-window)
             (window-width . 0.333)
             (side . right)
             (slot . 1)
             (window-parameters . ((no-other-window . t)
                                   (mode-line-format . (" "
                                                        mode-line-buffer-identification)))))
            ("\\*Custom.*"
             (display-buffer-in-side-window)
             (window-width . 0.333)
             (side . right)
             (slot . 2))))
    :bind (("<f7>" . window-toggle-side-windows)))

  (use-package uniquify                   ; Unique buffer names
    :custom
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-separator ":")
    (uniquify-ignore-buffers-re "^\\*")
    (uniquify-after-kill-buffer-p t))

  (use-package ibuf-ext                   ; Extensions for Ibuffer
    :config
    ;; Do not show empty groups
    (setq ibuffer-show-empty-filter-groups nil))

  (use-package ibuffer                    ; Buffer management
    :custom
    (ibuffer-expert t)
    (ibuffer-filter-group-name-face 'font-lock-doc-face)
    (ibuffer-default-sorting-mode 'filename/process)
    (ibuffer-use-header-line t)
    :bind (("C-x C-b" . ibuffer)
           ([remap list-buffers] . ibuffer))
    :config
    ;; Use human readable Size column instead of original one
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))

    (setq ibuffer-formats
          '((mark modified read-only " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  filename-and-process)
            (mark modified read-only " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  filename-and-process))))

  (use-package ibuffer-vc                 ; Group buffers by VC project and status
    :defer 2
    :init (add-hook 'ibuffer-hook
                    (lambda ()
                      (ibuffer-vc-set-filter-groups-by-vc-root)
                      (unless (eq ibuffer-sorting-mode 'filename/process)
                        (ibuffer-do-sort-by-filename/process)))))

  (provide 'setup-buffers)
#+end_src

*** ~setup-compile.el~
:PROPERTIES:
:CUSTOM_ID: h:31c034c1-735e-4aae-affd-deb25a11a50e
:END:

#+begin_src emacs-lisp :tangle lisp/setup-compile.el
  ;;; -*- lexical-binding: t; -*-
  (use-package compile
    :defer 2
    :config
    (progn
      ;; http://stackoverflow.com/a/13408008/1219634
      (setq
       compilation-scroll-output t
       ;; I'm not scared of saving everything.
       compilation-ask-about-save nil
       ;; Automatically scroll and jump to the first error
       compilation-scroll-output 'next-error
       ;; compilation-scroll-output 'first-error
       ;; compilation-auto-jump-to-first-error t
       ;; Skip over warnings and info messages in compilation
       compilation-skip-threshold 2
       ;; Don't freeze when process reads from stdin
       compilation-disable-input t
       ;; Show three lines of context around the current message
       compilation-context-lines 3)
      (require 'ansi-color)
      (defun vde/colorize-compilation-buffer ()
        (unless (or (derived-mode-p 'grep-mode) ;Don't mess up colors in Grep/Ag results buffers
                    (derived-mode-p 'ag-mode))
          (ansi-color-apply-on-region compilation-filter-start (point))))
      (add-hook 'compilation-filter-hook #'vde/colorize-compilation-buffer)

      (defun vde/mark-compilation-window-as-dedicated ()
        "Setup the *compilation* window with custom settings."
        (when (string-prefix-p "*compilation: " (buffer-name))
          (save-selected-window
            (save-excursion
              (let* ((w (get-buffer-window (buffer-name))))
                (when w
                  (select-window w)
                  (switch-to-buffer (buffer-name))
                  (set-window-dedicated-p w t)))))))
      (add-hook 'compilation-mode-hook 'vde/mark-compilation-window-as-dedicated)))

  (use-package flycheck
    :if (not (eq system-type 'windows-nt))
    :defer 4
    :commands (flycheck-mode
               flycheck-next-error
               flycheck-previous-error)
    :init
    (dolist (where '((emacs-lisp-mode-hook . emacs-lisp-mode-map)
                     (haskell-mode-hook    . haskell-mode-map)
                     (js2-mode-hook        . js2-mode-map)
                     (go-mode-hook         . go-mode-map)
                     (c-mode-common-hook   . c-mode-base-map)))
      (add-hook (car where)
                `(lambda ()
                   (bind-key "M-n" #'flycheck-next-error ,(cdr where))
                   (bind-key "M-p" #'flycheck-previous-error ,(cdr where)))
                t))
    :config
    (add-hook 'prog-mode-hook 'flycheck-mode)
    (defalias 'show-error-at-point-soon
      'flycheck-show-error-at-point)
    (setq flycheck-idle-change-delay 1.2))

  (provide 'setup-compile)
#+end_src

*** ~setup-completion.el~
:PROPERTIES:
:CUSTOM_ID: h:5fda01e3-f756-47d0-8bce-c907619d3087
:END:

#+begin_src emacs-lisp :tangle lisp/setup-completion.el
  ;;; -*- lexical-binding: t; -*-
  (use-package ivy
    :delight
    :custom
    (ivy-count-format "%d/%d ")
    (ivy-height-alist '((t lambda (_caller) (/ (window-height) 4))))
    (ivy-use-virtual-buffers t)
    (ivy-virtual-abbreviate 'full) ;Show the full virtual file paths
    (ivy-wrap nil)
    (ivy-re-builders-alist
     '((counsel-M-x . ivy--regex-fuzzy)
       (t . ivy--regex-plus)))
    (ivy-display-style 'fancy)
    (ivy-use-selectable-prompt t)
    (ivy-fixed-height-minibuffer nil)
    (ivy-extra-directories nil) ; Default value: ("../" "./")
    :bind (:map vde-mode-map
                ("C-x b" . vde/switch-buffer)
                ("C-x B" . ivy-switch-buffer)
                ("M-u" . ivy-resume)    ;Override the default binding for `upcase-word'
                ("C-c C-w p" . ivy-push-view) ;Push window configuration to `ivy-views'
                ("C-c C-w P" . ivy-pop-view)  ;Remove window configuration from `ivy-views'
                ("C-c C-w s" . ivy-switch-view) ; Switch window configuration to `ivy-views'
                :map ivy-occur-mode-map
                ("f" . forward-char)
                ("b" . backward-char)
                ("n" . ivy-occur-next-line)
                ("p" . ivy-occur-previous-line)
                ("<C-return>" . ivy-occur-press))
    :init
    (progn
      (bind-to-vde-map "v" #'counsel-set-variable))
    :hook
    (ivy-occur-mode . hl-line-mode)
    :config
    (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur)
    (ivy-set-occur 'swiper 'swiper-occur)
    (ivy-set-occur 'swiper-isearch 'swiper-occur)
    (ivy-mode 1)
    (progn
      (defun vde/switch-buffer (arg)
        "Custom switch to buffer.
  With universal argument ARG or when not in project, rely on
  `ivy-switch-buffer'.
  Otherwise, use `counsel-projectile-switch-project'."
        (interactive "P")
        (if (or arg
                (not (projectile-project-p)))
            (ivy-switch-buffer)
          (counsel-projectile-switch-to-buffer)))
      ;; Disable ido
      (with-eval-after-load 'ido
        (ido-mode -1)
        ;; Enable ivy
        (ivy-mode 1))
      ))

  (use-package ivy-hydra                  ; Additional bindings for Ivy
    :after ivy)

  (use-package ivy-rich
    :after ivy
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev)
    :config (ivy-rich-mode 1))

  (use-package prescient
    :custom
    (prescient-history-length 50)
    ;; (prescient-save-file "~/.emacs.d/prescient-items")
    (prescient-filter-method '(fuzzy initialism regexp))
    :config
    (prescient-persist-mode 1))

  ;;; Default rg arguments
  ;; https://github.com/BurntSushi/ripgrep
  (defconst vde/rg-arguments
    `("--no-ignore-vcs"                   ;Ignore files/dirs ONLY from `.ignore'
      "--line-number"                     ;Line numbers
      "--smart-case"
      "--max-columns" "150"      ;Emacs doesn't handle long line lengths very well
      "--ignore-file" ,(expand-file-name ".ignore" (getenv "HOME")))
    "Default rg arguments used in the functions in `counsel' and `projectile' packages.")

  (use-package ivy-prescient
    :after (prescient ivy)
    :custom
    (ivy-prescient-sort-commands
     '(:not swiper ivy-switch-buffer counsel-switch-buffer))
    (ivy-prescient-retain-classic-highlighting t)
    (ivy-prescient-enable-filtering t)
    (ivy-prescient-enable-sorting t)
    :config
    (defun prot/ivy-prescient-filters (str)
      "Specify an exception for `prescient-filter-method'.

  This new rule can be used to tailor the results of individual
  Ivy-powered commands, using `ivy-prescient-re-builder'."
      (let ((prescient-filter-method '(literal regexp)))
        (ivy-prescient-re-builder str)))

    (setq ivy-re-builders-alist
          '((counsel-rg . prot/ivy-prescient-filters)
            (counsel-grep . prot/ivy-prescient-filters)
            (counsel-yank-pop . prot/ivy-prescient-filters)
            (swiper . prot/ivy-prescient-filters)
            (swiper-isearch . prot/ivy-prescient-filters)
            (swiper-all . prot/ivy-prescient-filters)
            (t . ivy-prescient-re-builder)))
    (ivy-prescient-mode 1))

  (use-package counsel
    :after ivy
    :custom
    (counsel-yank-pop-preselect-last t)
    (counsel-yank-pop-separator "\n—————————\n")
    (counsel-describe-function-function 'helpful-function)
    (counsel-describe-variable-function 'helpful-variable)
    (counsel-find-file-at-point t)
    (counsel-find-file-ignore-regexp
     ;; Note that `ivy-extra-directories' should also not contain the "../" and
     ;; "./" elements if you don't want to see those in the `counsel-find-file'
     ;; completion list.
     (concat
      ;; file names beginning with # or .
      "\\(?:\\`[#.]\\)"
      ;; file names ending with # or ~
      "\\|\\(?:[#~]\\'\\)"))
    :bind (:map vde-mode-map
                ("M-i" . counsel-semantic-or-imenu)
                ;;("M-i" . counsel-grep-or-swiper)
                ("C-x C-r" . counsel-recentf)
                ("C-M-y" . counsel-yank-pop)
                ("C-h F" . counsel-faces)       ;Overrides `Info-goto-emacs-command-node'
                ("C-h S" . counsel-info-lookup-symbol)
                ("C-c u" . counsel-unicode-char)
                ("C-c C" . counsel-colors-emacs) ;Alternative to `list-colors-display'
                ([remap execute-extended-command] . counsel-M-x)
                ([remap bookmark-jump] . counsel-bookmark) ;Jump to book or set it if it doesn't exist, C-x r b
                ([remap bookmark-set] . counsel-bookmark)  ;C-x r m
                ([remap find-file]  . counsel-find-file)
                ([remap describe-bindings] . counsel-descbinds)
                ([remap finder-by-keyword] . counsel-package) ;C-h p
                ([remap describe-variable] . counsel-describe-variable)
                ([remap describe-function] . counsel-describe-function)
                ("M-s r" . counsel-rg)
                ("M-s g" . counsel-git-grep)
                ("M-s z" . prot/counsel-fzf-rg-files)
                :map ivy-minibuffer-map
                ("C-r" . counsel-minibuffer-history)
                ("C-SPC" . ivy-restrict-to-matches))
    :init
    (progn
      (bind-to-vde-map "s" #'counsel-rg))
    :config
    (progn
      (defun prot/counsel-fzf-rg-files (&optional input dir)
        "Run `fzf' in tandem with `ripgrep' to find files in the
  present directory.  If invoked from inside a version-controlled
  repository, then the corresponding root is used instead."
        (interactive)
        (let* ((process-environment
                (cons (concat "FZF_DEFAULT_COMMAND=rg -Sn --color never --files --no-follow --hidden")
                      process-environment))
               (vc (vc-root-dir)))
          (if dir
              (counsel-fzf input dir)
            (if (eq vc nil)
                (counsel-fzf input default-directory)
              (counsel-fzf input vc)))))

      (defun prot/counsel-fzf-dir (arg)
        "Specify root directory for `counsel-fzf'."
        (prot/counsel-fzf-rg-files ivy-text
                                   (read-directory-name
                                    (concat (car (split-string counsel-fzf-cmd))
                                            " in directory: "))))

      (defun prot/counsel-rg-dir (arg)
        "Specify root directory for `counsel-rg'."
        (let ((current-prefix-arg '(4)))
          (counsel-rg ivy-text nil "")))

      ;; TODO generalise for all relevant file/buffer counsel-*?
      (defun prot/counsel-fzf-ace-window (arg)
        "Use `ace-window' on `prot/counsel-fzf-rg-files' candidate."
        (ace-window t)
        (let ((default-directory (if (eq (vc-root-dir) nil)
                                     counsel--fzf-dir
                                   (vc-root-dir))))
          (if (> (length (aw-window-list)) 1)
              (progn
                (find-file arg))
            (find-file-other-window arg))
          (balance-windows)))

      ;; Pass functions as appropriate Ivy actions (accessed via M-o)
      (ivy-add-actions
       'counsel-fzf
       '(("r" prot/counsel-fzf-dir "change root directory")
         ("g" prot/counsel-rg-dir "use ripgrep in root directory")
         ("a" prot/counsel-fzf-ace-window "ace-window switch")))

      (ivy-add-actions
       'counsel-rg
       '(("r" prot/counsel-rg-dir "change root directory")
         ("z" prot/counsel-fzf-dir "find file with fzf in root directory")))

      (ivy-add-actions
       'counsel-find-file
       '(("g" prot/counsel-rg-dir "use ripgrep in root directory")
         ("z" prot/counsel-fzf-dir "find file with fzf in root directory")))

      (ivy-set-actions
       'counsel-find-file
       `(("x"
          (lambda (x) (delete-file (expand-file-name x ivy--directory)))
          ,(propertize "delete" 'face 'font-lock-warning-face))))

      (push '(counsel-rg . "--glob '**' -- ") ivy-initial-inputs-alist)
      ;; counsel-rg
      ;; Redefine `counsel-rg-base-command' with my required options, especially
      ;; the `--follow' option to allow search through symbolic links (part of
      ;; `modi/rg-arguments').
      (setq counsel-rg-base-command
            (concat (mapconcat #'shell-quote-argument
                               (append '("rg")
                                       vde/rg-arguments
                                       '("--no-heading" ;No file names above matching content
                                         ))
                               " ")
                    " %s"            ;This MUST be %s, not %S
                                          ;https://github.com/abo-abo/swiper/issues/427
                    ))))

  (use-package ivy-posframe
    :delight
    :custom
    (ivy-posframe-height-alist
     '((swiper . 15)
       (swiper-isearch . 15)
       (t . 10)))
    (ivy-posframe-display-functions-alist
     '((complete-symbol . ivy-posframe-display-at-point)
       ;;(t . ivy-posframe-display-at-frame-center)
       (counsel-M-x . ivy-posframe-display-at-frame-bottom-left)))
    :config
    (ivy-posframe-mode 1))

  (use-package company
    :commands global-company-mode
    :init
    (add-hook 'after-init-hook #'global-company-mode)
    (setq
     company-idle-delay 0.2
     company-selection-wrap-around t
     company-minimum-prefix-length 2
     company-require-match nil
     company-dabbrev-ignore-case nil
     company-dabbrev-downcase nil
     company-show-numbers t
     company-tooltip-align-annotations t)
    :config
    (bind-keys :map company-active-map
               ("C-d" . company-show-doc-buffer)
               ("C-l" . company-show-location)
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)
               ("C-t" . company-select-next)
               ("C-s" . company-select-previous)
               ("TAB" . company-complete))
    (setq company-backends
          '(company-css
            company-clang
            company-capf
            company-semantic
            company-xcode
            company-cmake
            company-files
            company-gtags
            company-etags
            company-keywords)))

  (use-package company-prescient
    :ensure company
    :after (company prescient)
    :config
    (company-prescient-mode 1))

  (use-package company-emoji
    :ensure company
    :config
    (add-to-list 'company-backends 'company-emoji))

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :custom
    (lsp-gopls-staticcheck t)
    (lsp-gopls-complete-unimported t)
    (lsp-eldoc-render-all nil)
    (lsp-enable-snippet nil)
    (lsp-enable-links nil)
    (lsp-ui-sideline-enable nil)
    (lsp-ui-sideline-show-hover nil)
    (lsp-ui-sideline-delay 2.0)
    (lsp-ui-doc-enable t)
    (lsp-ui-doc-max-width 30)
    (lsp-ui-doc-max-height 15)
    (lsp-document-highlight-delay 2.0)
    (lsp-auto-guess-root t)
    (lsp-ui-flycheck-enable t)
    (lsp-prefer-flymake nil) ; Use flycheck instead of flymake
    :hook ((go-mode . lsp-deferred)
           (python-mode . lsp-deferred)))

  ;; lsp-ui: This contains all the higher level UI modules of lsp-mode, like flycheck support and code lenses.
  ;; https://github.com/emacs-lsp/lsp-ui
  (use-package lsp-ui
    :after lsp-mode
    :hook ((lsp-mode . lsp-ui-mode)
           (lsp-ui-mode . lsp-ui-peek-mode))
    :config
    (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
    (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references))

  ;;Set up before-save hooks to format buffer and add/delete imports.
  ;;Make sure you don't have other gofmt/goimports hooks enabled.
  (defun lsp-go-install-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))
  (add-hook 'go-mode-hook #'lsp-go-install-save-hooks)

  (with-eval-after-load "company"
    (use-package company-lsp
      :after lsp-mode
      :config
      (push 'company-lsp company-backends)))

  (with-eval-after-load "projectile"
    (defun my-set-projectile-root ()
      (when lsp--cur-workspace
        (setq projectile-project-root (lsp--workspace-root lsp--cur-workspace))))
    (add-hook 'lsp-before-open-hook #'my-set-projectile-root))

  (use-package dap-mode
    :after lsp-mode
    :bind (:map dap-mode-map
                ([f9] . dap-debug)
                ;; ([f9] . dap-continue)
                ;; ([S-f9] . dap-disconnect)
                ;; ([f10] . dap-next)
                ;; ([f11] . dap-step-in)
                ;; ([S-f11] . dap-step-out)
                ([C-f9] . dap-hide/show-ui))
    :hook (dap-stopped-hook . (lambda (arg) (call-interactively #'dap-hydra)))
    :config
    ;; FIXME: Create nice solution instead of a hack
    (defvar dap-hide/show-ui-hidden? t)
    (defun dap-hide/show-ui ()
      "Hide/show dap ui. FIXME"
      (interactive)
      (if dap-hide/show-ui-hidden?
          (progn
            (setq dap-hide/show-ui-hidden? nil)
            (dap-ui-locals)
            (dap-ui-repl))
        (dolist (buf '("*dap-ui-inspect*" "*dap-ui-locals*" "*dap-ui-repl*" "*dap-ui-sessions*"))
          (when (get-buffer buf)
            (kill-buffer buf)))
        (setq dap-hide/show-ui-hidden? t)))

    (dap-mode)
    (dap-ui-mode)
    (dap-tooltip-mode))

  (provide 'setup-completion)
#+end_src

*** ~setup-dired.el~
:PROPERTIES:
:CUSTOM_ID: h:66b435e6-b66c-4d39-9414-d13ce9ae5dd9
:END:

#+begin_src emacs-lisp :tangle lisp/setup-dired.el
  ;;; -*- lexical-binding: t; -*-
  (use-package dired
    :defer t
    :custom
    (dired-auto-revert-buffer t)
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    (dired-isearch-filenames 'dwim)
    (delete-by-moving-to-trash t)
    (dired-listing-switches "-lFaGh1v --group-directories-first")
    (dired-ls-F-marks-symlinks t)
    (dired-dwim-target t)
    :bind (("<C-return>" . vde/open-in-external-app)
           ("C-c f g"    . vde/dired-get-size)
           ("C-c f f"    . find-name-dired)
           (:map dired-mode-map
                 ("M-p"         . vde/dired-up)
                 ("^"           . vde/dired-up)
                 ("<backspace>" . vde/dired-up)
                 ("M-n"         . vde/dired-down)
                 ("RET"         . find-file-reuse-dir-buffer)
                 ("!"           . vde/sudired)
                 ("<prior>"     . beginend-dired-mode-goto-beginning)
                 ("<next>"      . beginend-dired-mode-goto-end)))
    :config
    (when (string= system-type "darwin")
      (setq dired-use-ls-dired t
            insert-directory-program "/usr/local/bin/gls"))

    ;; Enable dired-find-alternate-file
    (put 'dired-find-alternate-file 'disabled nil)

    ;; Handle long file names
    (add-hook 'dired-mode-hook #'toggle-truncate-lines)

    (defun vde/dired-up ()
      "Go to previous directory."
      (interactive)
      (find-alternate-file ".."))

    (defun vde/dired-down ()
      "Enter directory."
      (interactive)
      (dired-find-alternate-file))

    (defun vde/open-in-external-app ()
      "Open the file(s) at point with an external application."
      (interactive)
      (let* ((file-list
              (dired-get-marked-files)))
        (mapc
         (lambda (file-path)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" file-path))) file-list)))

    (defun find-file-reuse-dir-buffer ()
      "Like `dired-find-file', but reuse Dired buffers."
      (interactive)
      (set-buffer-modified-p nil)
      (let ((file (dired-get-file-for-visit)))
        (if (file-directory-p file)
            (find-alternate-file file)
          (find-file file))))

    (defun vde/sudired ()
      "Open directory with sudo in Dired."
      (interactive)
      (require 'tramp)
      (let ((dir (expand-file-name default-directory)))
        (if (string-match "^/sudo:" dir)
            (user-error "Already in sudo")
          (dired (concat "/sudo::" dir)))))

    (defun vde/dired-get-size ()
      "Quick and easy way to get file size in Dired."
      (interactive)
      (let ((files (dired-get-marked-files)))
        (with-temp-buffer
          (apply 'call-process "du" nil t nil "-sch" files)
          (message
           "Size of all marked files: %s"
           (progn
             (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
             (match-string 1)))))))

  (use-package find-dired
    :after dired
    :custom
    (find-ls-option ;; applies to `find-name-dired'
     '("-ls" . "-AFhlv --group-directories-first"))
    (find-name-arg "-iname"))

  (use-package dired-x                    ; Enable some nice Dired features
    :bind ("C-x C-j" . dired-jump)
    :custom
    (dired-omit-verbose nil)
    (dired-clean-confirm-killing-deleted-buffers nil)
    :hook
    (dired-mode . dired-omit-mode)
    :config
    (setq dired-omit-files (concat dired-omit-files "\\|^\\.+$\\|^\\..+$")))

  (use-package dired-aux                  ; Other Dired customizations
    :after dired
    :config
    (setq
     ;; Ask for creation of missing directories when copying/moving
     dired-create-destination-dirs 'ask
     ;; Search only file names when point is on a file name
     dired-isearch-filenames'dwim))

  (use-package dired-collapse
    :defer 1
    :commands (dired-collapse-mode)
    :init
    (add-hook 'dired-mode-hook #'dired-collapse-mode))

  (use-package dired-quick-sort
    :defer 1
    :after dired
    :config
    (dired-quick-sort-setup))

  (use-package async)

  (use-package dired-async
    :after (dired async)
    :config
    (dired-async-mode 1))

  (use-package dired-narrow
    :after dired
    :custom
    (dired-narrow-exit-when-one-left t)
    (dired-narrow-enable-blinking t)
    (dired-narrow-blink-time 0.3)
    :bind (:map dired-mode-map
                ("M-s n" . dired-narrow)))

  (use-package wdired
    :after dired
    :commands (wdired-mode
               wdired-change-to-wdired-mode)
    :custom
    (wdired-allow-to-change-permissions t)
    (wdired-create-parent-directories t))

  (use-package dired-rsync
    :ensure t
    :bind (:map dired-mode-map
                ("r" . dired-rsync)))

  (provide 'setup-dired)
#+end_src

*** ~setup-docker.el~
:PROPERTIES:
:CUSTOM_ID: h:1b476ae7-21a6-4dd3-b668-221fa2e38681
:END:

#+begin_src emacs-lisp :tangle lisp/setup-docker.el
  ;;; -*- lexical-binding: t; -*-
  (use-package dockerfile-mode            ; Edit docker's Dockerfiles
    :mode ("Dockerfile\\'" . dockerfile-mode))

  ;; I have a bunch of different 'profiles' for kubernetes by different cluster so
  ;; i don't mess between things
  ;; This allow me to set the KUBECONFIG variable between those easily
  ;; TODO: add the current profile in modeline
  (defun my-switch-kubeconfig-env (&optional kubeconfig)
    "Set KUBECONFIG environment variable for the current session"
    (interactive
     (list
      (completing-read
       "Kubeconfig: "
       (mapcar
        (lambda (x)
          (replace-regexp-in-string
           "^config\." ""
           (file-name-nondirectory(directory-file-name x))))
        (directory-files-recursively
         (expand-file-name "~/.kube") "^config\.")) nil t )))
    (setq kubeconfig (expand-file-name (format "~/.kube/config.%s" kubeconfig)))
    (if (file-exists-p kubeconfig)
        (setenv "KUBECONFIG" kubeconfig)
      (error "Cannot find kubeconfig: %s" kubeconfig)))

  (provide 'setup-docker)
#+end_src

*** ~setup-editing.el~
:PROPERTIES:
:CUSTOM_ID: h:0e7ab1fa-1d49-43ac-9bd7-f84e4d7057b5
:END:

#+begin_src emacs-lisp :tangle lisp/setup-editing.el
  ;;; -*- lexical-binding: t; -*-
  (setq enable-remote-dir-locals t)
  (use-package aggressive-indent          ; Automatically indent code
    :bind ("C-c e i" . aggressive-indent-mode)
    :hook ((lisp-mode       . aggressive-indent-mode)
           (emacs-lisp-mode . aggressive-indent-mode)
           (clojure-mode    . aggressive-indent-mode))
    :config
    ;; Free C-c C-q, used in Org and in CIDER
    (unbind-key "C-c C-q" aggressive-indent-mode-map))

  (use-package undo-tree                  ; Show buffer changes as a tree
    :defer 1
    :init (global-undo-tree-mode)
    :config (setq undo-tree-visualizer-timestamps t
                  undo-tree-enable-undo-in-region t))

  (use-package whitespace
    :defer 1
    :hook ((prog-mode . whitespace-mode))
    :config
    (setq whitespace-style '(face tabs spaces trailing space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))

  (use-package smartparens
    :defer 1
    :init
    (progn
      (use-package smartparens-config)
      (show-smartparens-global-mode 1))
    :config
    (progn
      (require 'smartparens-config)
      (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
      (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)

      (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
      (sp-local-pair 'web-mode "{%" "%}")
      (sp-with-modes 'emacs-lisp-mode
        ;; disable ', it's the quote character!
        (sp-local-pair "'" nil :actions nil)
        ;; also only use the pseudo-quote inside strings where it
        ;; serves as hyperlink.
        (sp-local-pair "`" "'" :when '(sp-in-string-p sp-in-comment-p)))))

  (use-package expand-region
    :bind (("C-=" . er/expand-region)
           ("C--". er/contract-region)))

  (use-package iedit
    :defines hydra-iedit/body
    :bind* (:map global-map
                 ("C-*" . iedit-mode)
                 :map iedit-mode-keymap
                 ("M-n" . iedit-next-occurence)
                 ("M-p" . iedit-prev-occurence))
    :config
    (defhydra hydra-iedit (:color pink :columns 1)
      "IEDIT"
      ("C-*" iedit-mode "toggle")
      ("C-p" iedit-prev-occurrence "prev")
      ("C-n" iedit-next-occurrence "next")
      ("C-g" iedit-quit "toggle" :color blue)))

  (use-package visual-regexp
    :bind (("C-c r"   . vr/replace)
           ("C-c %"   . vr/query-replace)
           ("C-c m" . vr/mc-mark)))

  (use-package yasnippet
    :after (company prog-mode)
    :defer 5
    :bind (("C-c y d" . yas-load-directory)
           ("C-c y i" . yas-insert-snippet)
           ("C-c y f" . yas-visit-snippet-file)
           ("C-c y n" . yas-new-snippet)
           ("C-c y t" . yas-tryout-snippet)
           ("C-c y l" . yas-describe-tables)
           ("C-c y g" . yas-global-mode)
           ("C-c y m" . yas-minor-mode)
           ("C-c y a" . yas-reload-all)
           ("C-c y x" . yas-expand))
    :bind (:map yas-keymap
                ("C-i" . yas-next-field-or-maybe-expand))
    :mode ("/\\.emacs\\.d/etc/yasnippet/snippets/" . snippet-mode)
    :hook (go-mode . yas-minor-mode)
    :config
    (yas-load-directory (concat user-emacs-directory "etc/yasnippet/snippets"))
    (yas-global-mode 1)
    :init
    (add-hook 'term-mode-hook (lambda () (yas-minor-mode -1))))

  (use-package hs-minor-mode
    :hook ((prog-mode . hs-minor-mode)))

  (use-package easy-kill
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill)
    (global-set-key [remap mark-sexp] 'easy-mark))

  (use-package define-word)

  (setq display-line-numbers-type 'relative)
  (add-hook 'prog-mode-hook
            'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'toggle-truncate-lines)

  (use-package newcomment
    :custom
    (comment-empty-lines t)
    (comment-fill-column nil)
    (comment-multi-line t)
    (comment-style 'multi-line)
    :config
    (defun prot/comment-dwim (&optional arg)
      "Alternative to `comment-dwim': offers a simple wrapper
  around `comment-line' and `comment-dwim'.

  If the region is active, then toggle the comment status of the
  region or, if the major mode defines as much, of all the lines
  implied by the region boundaries.

  Else toggle the comment status of the line at point."
      (interactive "*P")
      (if (use-region-p)
          (comment-dwim arg)
        (save-excursion
          (comment-line arg))))

    :bind (("C-;" . prot/comment-dwim)
           ("C-:" . comment-kill)
           ("M-;" . comment-indent)
           ("C-x C-;" . comment-box)))

  (use-package flyspell
    :init
    (setq flyspell-issue-message-flag nil)
    (setq flyspell-issue-welcome-flag nil)
    (setq ispell-program-name "hunspell")
    (setq ispell-local-dictionary "en_GB")
    (setq ispell-local-dictionary-alist
          '(("en_GB"
             "[[:alpha:]]"
             "[^[:alpha:]]"
             "[']"
             nil
             ("-d" "en_GB,fr_FR")
             nil
             utf-8)))
    :config
    (define-key flyspell-mode-map (kbd "C-;") nil)
    :hook
    (text-mode . turn-on-flyspell)
    (prog-mode . turn-off-flyspell))

  (use-package flyspell-correct-ivy
    :after flyspell
    :bind (:map flyspell-mode-map
                ([remap flyspell-correct-word-before-point] . flyspell-correct-previous-word-generic)))

  (use-package electric
    :custom
    (electric-pair-inhibit-predicate 'electric-pair-default-inhibit)
    (electric-pair-pairs '((8216 . 8217)
                           (8220 . 8221)
                           (171 . 187)))
    (electric-pair-skip-self 'electric-pair-default-skip-self)
    (electric-quote-context-sensitive t)
    (electric-quote-paragraph t)
    (electric-quote-string nil)
    :config
    (electric-indent-mode 1)
    (electric-pair-mode 1)
    (electric-quote-mode -1))

  (use-package emacs
    :init
    (setq-default tab-always-indent 'complete)
    (setq-default tab-width 4)
    (setq-default indent-tabs-mode nil))

  (use-package emacs
    :hook (before-save . delete-trailing-whitespace))

  (use-package delsel
    :config
    (delete-selection-mode 1))

  (use-package emacs
    :custom
    (repeat-on-final-keystroke t)
    (set-mark-command-repeat-pop t)
    :bind ("M-z" . zap-up-to-char))

  (use-package emacs
    :config
    (defun prot/new-line-below ()
      "Create a new line below the current one.  Move the point to
  the absolute beginning.  Also see `prot/new-line-above'."
      (interactive)
      (end-of-line)
      (newline))

    (defun prot/new-line-above ()
      "Create a new line above the current one.  Move the point to
  the absolute beginning.  Also see `prot/new-line-below'."
      (interactive)
      (beginning-of-line)
      (newline)
      (forward-line -1))

    (defun prot/yank-replace-line-or-region ()
      "Replace the line at point with the contents of the last
  stretch of killed text.  If the region is active, operate over it
  instead.  This command can then be followed by the standard
  `yank-pop' (default is bound to M-y)."
      (interactive)
      (if (use-region-p)
          (progn
            (delete-region (region-beginning) (region-end))
            (yank))
        (progn
          (delete-region (point-at-bol) (point-at-eol))
          (yank))))

    :bind (("C-S-SPC" . contrib/mark-whole-word)
           ("<C-return>" . prot/new-line-below)
           ("<C-S-return>" . prot/new-line-above)
           ("M-SPC" . cycle-spacing)
           ("M-o" . delete-blank-lines)
           ("<f6>" . tear-off-window)
           ("C-S-y" . prot/yank-replace-line-or-region)))

  (use-package crux
    :commands (crux-transpose-windows
               crux-duplicate-current-line-or-region
               crux-rename-file-and-buffer
               crux-open-with)
    :bind (("C-c w S" . crux-transpose-windows)
           ("C-c d" . crux-duplicate-current-line-or-region)
           ("<C-f2>" . crux-rename-file-and-buffer)
           :map dired-mode-map
           ("<M-return>" . crux-open-with)))

  (use-package goto-last-change
    :commands goto-last-change
    :bind ("C-z" . goto-last-change))

  (use-package pdf-tools
    :pin manual
    :mode  ("\\.pdf\\'" . pdf-view-mode)
    :config
    (setq-default pdf-view-display-size 'fit-page)
    (setq pdf-annot-activate-created-annotations t)
    (setq pdf-view-midnight-colors '("#ffffff" . "#000000"))
    (pdf-tools-install :no-query)
    (require 'pdf-occur))

  (provide 'setup-editing)
#+end_src

*** ~setup-files.el~
:PROPERTIES:
:CUSTOM_ID: h:f7b54e8c-f10e-4fd8-9c54-bc3c31b36915
:END:

#+begin_src emacs-lisp :tangle lisp/setup-files.el
  ;;; -*- lexical-binding: t; -*-
  (use-package files                      ; Core commands for files
    :bind (("<f5>" . revert-buffer)))

  (use-package ripgrep
    :defer 2)

  (use-package recentf
    :custom
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    (recentf-show-file-shortcuts-flag nil)
    :config
    (recentf-mode 1)
    (add-to-list 'recentf-exclude "^/\\(?:ssh\\|su\\|sudo\\)?:")
    ;; Magic advice to rename entries in recentf when moving files in
    ;; dired.
    (defun rjs/recentf-rename-notify (oldname newname &rest args)
      (if (file-directory-p newname)
          (rjs/recentf-rename-directory oldname newname)
        (rjs/recentf-rename-file oldname newname)))

    (defun rjs/recentf-rename-file (oldname newname)
      (setq recentf-list
            (mapcar (lambda (name)
                      (if (string-equal name oldname)
                          newname
                        oldname))
                    recentf-list))
      recentf-cleanup)

    (defun rjs/recentf-rename-directory (oldname newname)
      ;; oldname, newname and all entries of recentf-list should already
      ;; be absolute and normalised so I think this can just test whether
      ;; oldname is a prefix of the element.
      (setq recentf-list
            (mapcar (lambda (name)
                      (if (string-prefix-p oldname name)
                          (concat newname (substring name (length oldname)))
                        name))
                    recentf-list))
      recentf-cleanup)

    (advice-add 'dired-rename-file :after #'rjs/recentf-rename-notify)

    (defun contrib/recentf-add-dired-directory ()
      "Include Dired buffers in the list.  Particularly useful when
  combined with a completion framework's ability to display virtual
  buffers."
      (when (and (stringp dired-directory)
                 (equal "" (file-name-nondirectory dired-directory)))
        (recentf-add-file dired-directory))))

  (setq view-read-only t)                 ; View read-only

  (use-package direnv
    :custom
    (direnv-always-show-summary t)
    (direnv-show-paths-in-summary nil)
    :config
    (direnv-mode))

  (use-package hardhat                    ; Protect user-writable files
    :init (global-hardhat-mode))

  (use-package image-file                 ; Visit images as images
    :init (auto-image-file-mode))

  (use-package markdown-mode              ; Edit markdown files
    :mode ("\\.md\\'" . markdown-mode)
    :config
    (setq markdown-fontify-code-blocks-natively t)

    ;; Don't change font in code blocks
    (set-face-attribute 'markdown-code-face nil
                        :inherit nil)

    ;; Process Markdown with Pandoc, using a custom stylesheet for nice output
    (let ((stylesheet (expand-file-name
                       (locate-user-emacs-file "etc/pandoc.css"))))
      (setq markdown-command
            (mapconcat #'shell-quote-argument
                       `("pandoc" "--toc" "--section-divs"
                         "--css" ,(concat "file://" stylesheet)
                         "--standalone" "-f" "markdown" "-t" "html5")
                       " ")))
    (add-hook 'markdown-mode-hook #'auto-fill-mode))

  (use-package highlight-indentation
    :config
    (set-face-background 'highlight-indentation-face "#e3e3d3")
    (set-face-background 'highlight-indentation-current-column-face "#c3b3b3"))

  (use-package yaml-mode
    :mode "\\.ya?ml\\'"
    :hook ((yaml-mode . highlight-indentation-mode)
           (yaml-mode . highlight-indentation-current-column-mode)))

  (use-package toml-mode
    :mode "\\.to?ml\\'")

  ;;;###autoload
  (defun vde/delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
      (kill-this-buffer)))

  ;;;###autoload
  (defun vde/rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (when (file-exists-p filename)
            (rename-file filename new-name 1))
          (rename-buffer new-name)
          (set-visited-file-name new-name)))))

  (bind-key "C-c f D" #'vde/delete-this-file)
  (bind-key "C-c f R" #'vde/rename-this-file-and-buffer)

  ;; Additional bindings for built-ins
  (bind-key "C-c f v d" #'add-dir-local-variable)
  (bind-key "C-c f v l" #'add-file-local-variable)
  (bind-key "C-c f v p" #'add-file-local-variable-prop-line)

  (defun vde/reload-dir-locals-for-current-buffer ()
    "Reload dir locals for the current buffer."
    (interactive)
    (let ((enable-local-variables :all))
      (hack-dir-local-variables-non-file-buffer)))

  (defun vde/reload-dir-locals-for-all-buffers-in-this-directory ()
    "Reload dir-locals for all buffers in current buffer's `default-directory'."
    (interactive)
    (let ((dir default-directory))
      (dolist (buffer (buffer-list))
        (with-current-buffer buffer
          (when (equal default-directory dir))
          (vde/reload-dir-locals-for-current-buffer)))))

  (bind-key "C-c f v r" #'vde/reload-dir-locals-for-current-buffer)
  (bind-key "C-c f v r" #'vde/reload-dir-locals-for-all-buffers-in-this-directory)

  (provide 'setup-files)
#+end_src

*** ~setup-gnus.el~
:PROPERTIES:
:CUSTOM_ID: h:6325713e-e541-43a7-adb7-e98b5478593c
:END:

#+begin_src emacs-lisp :tangle lisp/setup-gnus.el
  ;;; -*- lexical-binding: t; -*-
  (setq user-mail-address "vincent@demeester.fr"
        user-full-name "Vincent Demeester")

  (setq gnus-select-method
        '(nnimap "vincent@demeester.fr"
                 (nnimap-address "mail.gandi.net")  ; it could also be imap.googlemail.com if that's your server.
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))

  (setq smtpmail-smtp-server "mail.gandi.net"
        smtpmail-smtp-service 587
        gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

  ;; (require 'nnrss)
  ;; (nnrss-opml-import "~/desktop/downloads/feedly.opml")

  (provide setup-gnus)
#+end_src

*** ~setup-go.el~
:PROPERTIES:
:CUSTOM_ID: h:64e5b918-3d56-40ba-a07f-e56294f1575a
:END:

#+begin_src emacs-lisp :tangle lisp/setup-go.el
  ;;; -*- lexical-binding: t; -*-
  (use-package go-mode
    :mode "\\.go$"
    :interpreter "go"
    :config
    (use-package company-go
      :config
      (setq company-go-show-annotation t)
      (push 'company-go company-backends))
    (setq gofmt-command "goimports")
    (if (not (executable-find "goimports"))
        (warn "go-mode: couldn't find goimports; no code formatting/fixed imports on save")
      (add-hook 'before-save-hook 'gofmt-before-save))
    (if (not (string-match "go" compile-command))   ; set compile command default
        (set (make-local-variable 'compile-command)
             "go build -v && go test -v && go vet")))

  (use-package flycheck-golangci-lint
    :hook (go-mode . flycheck-golangci-lint-setup)
    :config (setq flycheck-golangci-lint-tests t))

  (use-package dap-go
    :after dap-mode)

  (use-package gotest-ui
    :after go-mode
    :bind (:map go-mode-map
                ("C-c t t" . gotest-ui-current-test)
                ("C-c t f" . gotest-ui-current-file)
                ("C-c t p" . gotest-ui-current-project)))

  (provide 'setup-go)
#+end_src

*** ~setup-hydras.el~
:PROPERTIES:
:CUSTOM_ID: h:81612e01-a0c8-42c2-a1fe-34bd1b9d8002
:END:

#+begin_src emacs-lisp :tangle lisp/setup-hydras.el
  ;;; -*- lexical-binding: t; -*-
  (defhydra hydra-goto-line (goto-map "")
    "goto-line"
    ("g" goto-line "go")
    ("m" set-mark-command "mark" :bind nil)
    ("q" nil "quit"))

  (defhydra hydra-yank-pop ()
    "yank"
    ("C-y" yank nil)
    ("M-y" yank-pop nil)
    ("y" (yank-pop 1) "next")
    ("Y" (yank-pop -1) "prev"))   ; or browse-kill-ring

  (defhydra hydra-zoom (global-map "<f2>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")
    ("r" (text-scale-set 0) "reset")
    ("0" (text-scale-set 0) :bind nil :exit t)
    ("1" (text-scale-set 0) nil :bind nil :exit t))

  ;; Better shrink/enlarge windows
  (defhydra hydra-resize (global-map "<f2>")
    "resize windows"
    ("<up>" enlarge-window "enlarge")
    ("<down>" shrink-window "shrink")
    ("<left>" shrink-window-horizontally "shrink horizontaly")
    ("<right>" enlarge-window-horizontally "enlarge horizontaly"))

  (defvar hide-mode-line-mode nil)
  (defvar whitespace-mode nil)
  (defvar subword-mode nil)
  (defhydra hydra-toggle (:color pink :hint nil)
    "
  _a_ abbrev-mode:          %`abbrev-mode
  _b_ subword-mode:         %`subword-mode
  _d_ debug-on-error:       %`debug-on-error
  _h_ hide-mode-line-mode   %`hide-mode-line-mode
  _f_ auto-fill-mode:       %`auto-fill-function
  _r_ readonly-mode:        %`buffer-read-only
  _t_ truncate-lines        %`truncate-lines
  _v_ visual-line-mode:     %`visual-line-mode
  _w_ whitespace-mode:      %`whitespace-mode
  _s_ smartparens-strict:   %`smartparens-strict-mode
  _V_ visible-mode:         %`visible-mode
  "
    ("a" abbrev-mode             nil)
    ("b" subword-mode            nil)
    ("d" toggle-debug-on-error   nil)
    ("f" auto-fill-mode          nil)
    ("h" hide-mode-line-mode     nil)
    ("r" dired-toggle-read-only  nil)
    ("t" toggle-truncate-lines   nil)
    ("v" visual-line-mode        nil)
    ("V" visible-mode            nil)
    ("w" whitespace-mode         nil)
    ("s" smartparens-strict-mode nil)
    ("q" nil "quit"))

  (global-set-key (kbd "C-c C-v") 'hydra-toggle/body)

  (defhydra hydra-marked-items (dired-mode-map "")
    "
  Number of marked items: %(length (dired-get-marked-files))
  "
    ("m" dired-mark "mark"))

  (bind-key "M-y" #'hydra-yank-pop/yank-pop)
  (bind-key "C-y" #'hydra-yank-pop/yank)

  (provide 'setup-hydras)
#+end_src

*** ~setup-keybindings.el~
:PROPERTIES:
:CUSTOM_ID: h:9b69d5a9-f589-4348-9798-7a03c850fcbc
:END:

#+begin_src emacs-lisp :tangle lisp/setup-keybindings.el
  (use-package which-key
    :init (which-key-mode)
    :custom
    (which-key-idle-delay 2)
    (which-key-idle-secondary-delay 0.05)
    (which-key-show-early-on-C-h t)
    (which-key-sort-order 'which-key-prefix-then-key-order)
    (which-key-popup-type 'side-window)
    (which-key-show-prefix 'echo)
    (which-key-max-display-columns 6)
    (which-key-separator " → ")
    :config
    (add-to-list 'which-key-replacement-alist '(("TAB" . nil) . ("↹" . nil)))
    (add-to-list 'which-key-replacement-alist '(("RET" . nil) . ("⏎" . nil)))
    (add-to-list 'which-key-replacement-alist '(("DEL" . nil) . ("⇤" . nil)))
    (add-to-list 'which-key-replacement-alist '(("SPC" . nil) . ("␣" . nil))))

  (use-package region-bindings-mode
    :config
    ;; Do not activate `region-bindings-mode' in Special modes like `dired' and
    ;; `ibuffer'. Single-key bindings like 'm' are useful in those modes even
    ;; when a region is selected.
    (setq region-bindings-mode-disabled-modes '(dired-mode ibuffer-mode))

    (region-bindings-mode-enable)

    (defun vde/disable-rbm-deactivate-mark ()
      "Disable `region-bindings-mode' and deactivate mark."
      (interactive)
      (region-bindings-mode -1)
      (deactivate-mark)
      (message "Mark deactivated"))

    (bind-keys
     :map region-bindings-mode-map
     ("<C-SPC>" . vde/disable-rbm-deactivate-mark)))

  ;; Disable C-x C-n to avoid the disabled command buffer
  (unbind-key "C-x C-n" global-map)

  (provide 'setup-keybindings)
#+end_src

*** ~setup-multiple-cursor.el~
:PROPERTIES:
:CUSTOM_ID: h:462c3e34-87b1-4c1a-b388-e698c057f15e
:END:

#+begin_src emacs-lisp :tangle lisp/setup-multiple-cursors.el
  (use-package multiple-cursor
    :bind (:map vde-mode-map
                ("C-S-c C-S-c" . mc/edit-lines))
    :bind (:map region-bindings-mode-map
                ("a" . mc/mark-all-like-this)
                ("p" . mc/mark-previous-like-this)
                ("n" . mc/mark-next-like-this)
                ("P" . mc/unmark-previous-like-this)
                ("N" . mc/unmark-next-like-this)
                ("[" . mc/cycle-backward)
                ("]" . mc/cycle-forward)
                ("m" . mc/mark-more-like-this-extended)
                ("h" . mc-hide-unmatched-lines-mode)
                ("\\" . mc/vertical-align-with-space)
                ("#" . mc/insert-numbers) ; use num prefix to set the starting number
                ("^" . mc/edit-beginnings-of-lines)
                ("$" . mc/edit-ends-of-lines)))

  (provide 'setup-multiple-cursors)
#+end_src

*** ~setup-navigating.el~
:PROPERTIES:
:CUSTOM_ID: h:c5ec18c7-1153-451c-b472-33b55f1bba77
:END:

#+begin_src emacs-lisp :tangle lisp/setup-navigating.el
  (use-package avy                   ; Jump to characters in buffers
    :bind (("C-c j"   . avy-goto-word-1)
           ("C-c n b" . avy-pop-mark)
           ("C-c n j" . avy-goto-char-2)
           ("C-c n t" . avy-goto-char-timer)
           ("C-c n w" . avy-goto-word-1)))

  (use-package helpful
    :bind (("C-c h F" . helpful-function)
           ("C-c h C" . helpful-command)
           ("C-c h M" . helpful-macro)
           ("C-c h L" . helpful-callable)
           ("C-c h S" . helpful-at-point)
           ("C-c h V" . helpful-variable)))
  (use-package winner
    :unless noninteractive
    :defer 5
    :config
    (winner-mode 1))

  (use-package hideshow
    :defer 5
    :bind (("C-c @ a" . hs-show-all)
           ("C-c @ c" . hs-toggle-hiding)
           ("C-c @ t" . hs-hide-all)
           ("C-c @ d" . hs-hide-block)
           ("C-c @ l" . hs-hide-level)))

  (use-package mwim
    :bind (:map prog-mode-map
                ("C-a" . mwim-beginning-of-code-or-line)
                ("C-e" . mwim-end-of-code-or-line)))

  (provide 'setup-navigating)
#+end_src

*** ~setup-nix.el~
:PROPERTIES:
:CUSTOM_ID: h:f82d7d6f-55bf-495d-b71f-dd4719ece06e
:END:

#+begin_src emacs-lisp :tangle lisp/setup-nix.el
  ;;; -*- lexical-binding: t; -*-
  (use-package nix-mode
    :mode ("\\.nix\\'" "\\.nix.in\\'"))

  (use-package nix-drv-mode
    :ensure nix-mode
    :mode "\\.drv\\'")

  (use-package nix-shell
    :ensure nix-mode
    :commands (nix-shell-unpack nix-shell-configure nix-shell-build))

  (provide 'setup-nix)
#+end_src

*** ~setup-notmuch.el~
:PROPERTIES:
:CUSTOM_ID: h:3505ad73-785d-4849-98a6-9081c6d8e93d
:END:

#+begin_src emacs-lisp :tangle lisp/setup-notmuch.el
  (use-package notmuch
    :defer t
    :bind ("<f6>" . notmuch)
    :config
    (setq notmuch-search-oldest-first nil
          mail-user-agent 'message-user-agent
          notmuch-tree-show-out t)
    (setq notmuch-saved-searches
          '((:key "i" :name "inbox" :query "tag:Inbox")
            (:key "r" :name "redhat inbox folder" :query "folder:redhat/Inbox")
            (:key "p" :name "perso inbox folder" :query "folder:perso/Inbox")
            (:key "u" :name "unread" :query "tag:unread")
            (:key "F" :name "flagged" :query "tag:flagged")
            (:key "S" :name "sent" :query "tag:Sent Mail"))))

  (use-package sendmail
    :defer t
    :commands (mail-mode mail-text)
    :defines (send-mail-function)
    :config
    (setq send-mail-function 'sendmail-send-it
          sendmail-program "/home/vincent/bin/msmtp"))

  (use-package message
    :commands (message-mode message-cite-original-without-signature)
    :config
    (add-hook 'message-mode-hook 'turn-on-auto-fill)
    (setq  message-default-mail-headers "Cc: \nBcc: \n"
           message-kill-buffer-on-exit t
           message-generate-headers-first t))

  (provide 'setup-notmuch)
#+end_src

*** ~setup-org.el~
:PROPERTIES:
:CUSTOM_ID: h:b004ecf8-04cf-4671-bd41-6ecdff14887f
:END:

#+begin_src emacs-lisp :tangle lisp/setup-org.el
  ;;; -*- lexical-binding: t; -*-
  (defvar org-directory "~/desktop/org/")
  (defvar site-directory "~/desktop/sites/")

  (defvar org-default-projects-dir (concat org-directory "projects") "Primary tasks directory.")
  (defvar org-default-technical-dir (concat org-directory "technical") "Directory of shareable, technical notes.")
  (defvar org-default-personal-dir (concat org-directory "personal") "Directory of un-shareable, personal notes.")
  (defvar org-default-completed-dir (concat org-directory "projects/completed") "Directory of completed project files.")
  (defvar org-default-inbox-file (concat org-directory "projects/inbox.org") "New stuff collected in this file.")
  (defvar org-default-incubate-file (concat org-directory "projects/incubate.org") "Ideas simmering on back burner.")
  (defvar org-default-notes-file (concat org-directory "personal/notes.org") "Non-actionable, personal notes.")
  (defvar org-default-media-file (concat org-directory "projects/media.org") "Links to other things to check out.")
  (defvar org-default-journal-file (concat org-directory "personal/journal.org") "Journaling stuff.")

  (set-register ?i `(file . ,org-default-inbox-file))
  (set-register ?I `(file . ,org-default-incubate-file))
  (set-register ?j `(file . ,org-default-journal-file))
  (set-register ?m `(file . ,org-default-media-file))

  (defvar org-default-publish-technical (concat site-directory "sbr.pm/technical"))

  ;; Use `org-mode' instead of `lisp-interaction-mode' for scratch buffer
  (setq
   inhibit-startup-message t            ; don't show the startup message
   inhibit-startup-screen t             ; … or screen
   initial-scratch-message nil          ; empty scratch buffer
   initial-major-mode 'org-mode  ; org-mode by default
   )

  (use-package s)

  (use-package org
    :defer t
    :mode (("\\.org$" . org-mode))
    :commands (org-capture org-agenda)
    :ensure org-plus-contrib
    :hook (org-mode . vde/org-mode-hook)
    :bind (("C-c o c" . org-capture)
           ("C-c o l" . org-store-link)
           ("C-c o r r" . org-refile)
           ("C-c o r a" . org-agenda-refile)
           ("C-c o a" . org-agenda)
           ("<f12>" . org-agenda)
           ("<f11>" . org-clock-goto))
    :config
    (use-package find-lisp)
    (setq org-modules '(org-crypt
                        org-docview
                        org-habit
                        org-id
                        org-info
                        org-irc
                        org-protocol
                        org-man
                        org-git-link
                        org-notmuch))
    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "STARTED(s)" "|" "DONE(d!)" "CANCELED(c@/!)")
            (sequence "WAITING(w@/!)" "SOMEDAY(s)" "|" "CANCELED(c@/!)")
            (sequence "IDEA(i)" "|" "CANCELED(c@/!)")))
    (setq org-todo-state-tags-triggers '(
                                         ("CANCELLED" ("CANCELLED" . t))
                                         ("WAITING" ("WAITING" . t))
                                         (done ("WAITING"))
                                         ("TODO" ("WAITING") ("CANCELLED"))
                                         ("NEXT" ("WAITING") ("CANCELLED"))
                                         ("DONE" ("WAITING") ("CANCELLED"))))
    (setq org-blank-before-new-entry '((heading . t)
                                       (plain-list-item . nil)))

    (setq org-habit-show-habits-only-for-today nil)
    (setq org-habit-graph-column 80)
    (setq org-agenda-files (list org-default-projects-dir))
    (setq org-agenda-file-regexp "^[a-z0-9-_]+.org")

    (setq org-agenda-include-diary t)
    (setq org-use-property-inheritance t)

    (setq org-enforce-todo-dependencies t)

    (setq org-refile-use-outline-path 'file
          org-outline-path-complete-in-steps nil
          org-refile-allow-creating-parent-nodes 'confirm)

    (setq org-refile-targets (append '((org-default-media-file :level . 1)
                                       (org-default-inbox-file :level . 0))
                                     (->>
                                      (directory-files org-default-projects-dir nil ".org")
                                      (-remove-item (file-name-base org-default-media-file))
                                      (--remove (s-starts-with? "." it))
                                      (--map (format "%s/%s" org-default-projects-dir it))
                                      (--map `(,it :level . 1)))))

    (setq org-indirect-buffer-display 'dedicated-frame)
    (setq org-use-speed-commands t)

    (setq org-log-done (quote time))
    (setq org-log-redeadline (quote time))
    (setq org-log-reschedule (quote time))
    (setq org-log-into-drawer t)

    (setq org-fontify-whole-heading-line t)
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)

    (setq org-pretty-entities t)
    (setq org-insert-heading-respect-content t)
    (setq org-ellipsis " …")

    (setq org-agenda-window-setup (quote current-window))
    (setq org-special-ctrl-a/e t)
    (setq org-special-ctrl-k t)
    (setq org-yank-adjusted-subtrees t)

    (setcar (nthcdr 4 org-emphasis-regexp-components) 10)

    (setq org-tag-alist (quote (("linux") ("nixos") ("emacs") ("org")
                                ("openshift") ("redhat") ("tektoncd") ("kubernetes") ("knative" ) ("docker")
                                ("docs") ("code") ("review")
                                (:startgroup . nil)
                                ("@home" . ?h) ("@work" . ?w) ("@errand" . ?e) ("@health" . ?l)
                                (:endgroup . nil)
                                (:startgroup . nil)
                                ("@link" . ?i) ("@read" . ?r) ("@project" . ?p)
                                (:endgroup . nil)
                                )))
    (setq org-agenda-skip-scheduled-if-done nil)

    (use-package org-super-agenda
      :config (org-super-agenda-mode))

    (setq org-agenda-span 'day
          org-agenda-compact-blocks t
          org-super-agenda-header-separator "")
    (setq org-agenda-sticky t)
    (setq org-agenda-custom-commands
          `(("n" "Personal agenda"
             ((agenda "")
              (tags-todo "+TODO=\"NEXT\""
                         ((org-agenda-overriding-header "Next items")))
              (tags-todo "@work-goals"
                         ((org-agenda-skip-function '(org-agenda-skip-if nil '(scheduled deadline)))
                          (org-agenda-overriding-header "Work")))
              (tags-todo "@home-goals"
                         ((org-agenda-skip-function '(org-agenda-skip-if nil '(scheduled deadline)))
                          (org-agenda-overriding-header "Home"))))
             ((org-super-agenda-groups
               '((:name "Important" :priority "A")
                 (:name "Done" :log closed)
                 (:name "Scheduled" :time-grid t)
                 (:name "Work" :tag "@work")
                 (:name "Perso" :tag "@home")
                 (:habit t))))
             (org-agenda-list))))

    (defun vde/is-project-p ()
      "Any task with a todo keyword subtask"
      (save-restriction
        (widen)
        (let ((has-subtask)
              (subtree-end (save-excursion (org-end-of-subtree t)))
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (forward-line 1)
            (while (and (not has-subtask)
                        (< (point) subtree-end)
                        (re-search-forward "^\*+ " subtree-end t))
              (when (member (org-get-todo-state) org-todo-keywords-1)
                (setq has-subtask t))))
          (and is-a-task has-subtask))))

    (defun vde/is-project-subtree-p ()
      "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
      (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                  (point))))
        (save-excursion
          (vde/find-project-task)
          (if (equal (point) task)
              nil
            t))))

    (defun vde/find-project-task ()
      "Move point to the parent (project) task if any"
      (save-restriction
        (widen)
        (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
          (while (org-up-heading-safe)
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (goto-char parent-task)
          parent-task)))

    (defun vde/is-task-p ()
      "Any task with a todo keyword and no subtask"
      (save-restriction
        (widen)
        (let ((has-subtask)
              (subtree-end (save-excursion (org-end-of-subtree t)))
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (forward-line 1)
            (while (and (not has-subtask)
                        (< (point) subtree-end)
                        (re-search-forward "^\*+ " subtree-end t))
              (when (member (org-get-todo-state) org-todo-keywords-1)
                (setq has-subtask t))))
          (and is-a-task (not has-subtask)))))

    (defun vde/is-subproject-p ()
      "Any task which is a subtask of another project"
      (let ((is-subproject)
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (while (and (not is-subproject) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq is-subproject t))))
        (and is-a-task is-subproject)))

    ;; Set default column view headings: Task Effort Clock_Summary
    (setq org-columns-default-format "%80ITEM(Task) %TODO %3PRIORITY %10Effort(Effort){:} %10CLOCKSUM")

    (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                        ("STYLE_ALL" . "habit"))))

    (org-clock-persistence-insinuate)
    ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
    (setq org-clock-history-length 23)
    ;; Change tasks to STARTED when clocking in
    (setq org-clock-in-switch-to-state 'vde/clock-in-to-started)
    ;; Clock out when moving task to a done state
    (setq org-clock-out-when-done t)
    ;; Save the running clock and all clock history when exiting Emacs, load it on startup
    (setq org-clock-persist t)

    (defun vde/clock-in-to-started (kw)
      "Switch a task from TODO to STARTED when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from STARTED back to TODO"
      (when (not (and (boundp 'org-capture-mode) org-capture-mode))
        (cond
         ((and (member (org-get-todo-state) (list "TODO"))
               (vde/is-task-p))
          "STARTED")
         ((and (member (org-get-todo-state) (list "STARTED"))
               (vde/is-project-p))
          "TODO"))))

    (defvar org-capture-templates (list))
    (setq org-protocol-default-template-key "l")

    ;; images
    (setq org-image-actual-width nil
          org-startup-with-inline-images t)

    ;; Tasks (-> inbox)
    (add-to-list 'org-capture-templates
                 `("t" "Task Entry" entry
                   (file ,org-default-inbox-file)
                   "* %?\n:PROPERTIES:\n:CREATED:%U\n:END:\n\n%i\n\nFrom: %a"
                   :empty-lines 1))
    (add-to-list 'org-capture-templates
                 `("r" "PR Review" entry
                   (file ,org-default-inbox-file)
                   "* TODO review gh:%^{issue} :review:\n:PROPERTIES:\n:CREATED:%U\n:END:\n\n%i\n%?\nFrom: %a"
                   :empty-lines 1))
    (add-to-list 'org-capture-templates
                 `("l" "Link" entry
                   (file ,org-default-inbox-file)
                   "* %a\n%U\n%?\n%i"
                   :empty-lines 1))
    (add-to-list 'org-capture-templates
                 '("n" "Thought or Note"  entry
                   (file org-default-notes-file)
                   "* %?\n\n  %i\n\n  See: %a" :empty-lines 1))

    ;; Journal
    (add-to-list 'org-capture-templates
                 `("j" "Journal entry" entry
                   (file+datetree ,org-default-journal-file)
                   "* %^{title}\n%U\n%?\n%i\nFrom: %a"
                   :empty-lines 1 :clock-in t :clock-resume t))
    (add-to-list 'org-capture-templates
                 `("w" "Worklog (journal) entry" entry
                   (file+datetree ,org-default-journal-file)
                   "* worklog :@work:log:\n%U\n** Today\n%?\n** Next (later today, tomorrow)\n"))
    (add-to-list 'org-capture-templates
                 `("e" "Weekly review" entry
                   (file+datetree,org-default-journal-file)
                   "* weekly review :weekly:review:\n%U

  - [ ] review [[file:../projects/inbox.org][~inbox.org~]]
    Clean the file by either
    - refiling it to ~incubate.org~
    - removing it / archiving it
  - [ ] review [[file:../projects/incubate.org][~incubate.org~]]
    - Is something worth becoming a project
    - Is something not worth thinking about anymore ?
  - [ ] empty mail inbox (and create task if needed)
    - [ ] work
    - [ ] perso
  - [ ] Review next week ~F12 n w f~
  - [ ] review ~org-mode~ workflow
    - *what works, what doesn't ?*
    - *is there task / stuck projects ?*
    - *enhancement possible ?*
  - [ ] export previous agenda (somewhere)"
                   :clock-in t :clock-resume t))

    ;; Olds, most likely to remove
    (add-to-list 'org-capture-templates
                 `("b" "Blog post" entry
                   (file+headline "~/src/github.com/vdemeester/blog/content-org/posts.org" "Blog Ideas")
                   "* %?\n:PROPERTIES:\n:END:\n"))
    (add-to-list 'org-capture-templates
                 `("bl" "Blog link post" entry
                   (file+olp "~/src/github.com/vdemeester/blog/content-org/links.org" "Link")
                   "* %a\n%?\n%i"))

    (setq org-ditaa-jar-path "/home/vincent/.nix-profile/lib/ditaa.jar") ;; FIXME(vdemeester) remove /home/vincent
    ;; org-babel
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((css . t)
       (dot . t)
       (ditaa . t)
       (emacs-lisp . t)
       (go . t)
       (gnuplot . t)
       (http . t)
       (js . t)
       ;;(ledger . t)
       (latex . t)
       (python . t)
       ;;(rust . t)
       (shell . t)
       ;;(typescript . t)
       ))

    (setq org-latex-listings t)

    (setq org-list-demote-modify-bullet
          '(("+" . "-") ("-" . "+")))

    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" ":END:"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" "#\\+END_SRC"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" "#\\+END_EXAMPLE"))

    ;; org-links
    ;; from http://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html
    (org-link-set-parameters "tag"
                             :follow #'endless/follow-tag-link)
    (defun endless/follow-tag-link (tag)
      "Display a list of TODO headlines with tag TAG.
  With prefix argument, also display headlines without a TODO keyword."
      (org-tags-view (null current-prefix-arg) tag))

    (org-link-set-parameters "grep"
                             :follow #'vde/follow-grep-link
                             :face '(:foreground "DarkRed" :underline t))
    (defun vde/follow-grep-link (regexp)
      "Run `rgrep' with REGEXP and FOLDER as argument,
  like this : [[grep:REGEXP:FOLDER]]."
      (setq expressions (split-string regexp ":"))
      (setq exp (nth 0 expressions))
      (grep-compute-defaults)
      (if (= (length expressions) 1)
          (progn
            (rgrep exp "*" (expand-file-name "./")))
        (progn
          (setq folder (nth 1 expressions))
          (rgrep exp "*" (expand-file-name folder))))
      )

    (org-link-set-parameters "rg"
                             :follow #'vde/follow-rg-link
                             :face '(:foreground "DarkGreen" :underline t))
    (defun vde/follow-rg-link (regexp)
      "Run `ripgrep-regexp` with REXEP and FOLDER as argument,
  like this : [[pt:REGEXP:FOLDER]]"
      (setq expressions (split-string regexp ":"))
      (setq exp (nth 0 expressions))
      (if (= (length expressions) 1)
          (progn
            (ripgrep-regexp exp (expand-file-name "./")))
        (progn
          (setq folder (nth 1 expressions))
          (ripgrep-regexp exp (file-name-as-directory (expand-file-name folder)))))
      )

    (org-link-set-parameters "gh"
                             :follow #'vde/follow-gh-link
                             :export #'vde/org-gh-export
                             :face '(:foreground "DimGrey" :underline t))
    (defun vde/org-gh-export (link description format)
      "Export a github page link from Org files."
      (let ((path (vde/gh-get-url link))
            (desc (or description link)))
        (cond
         ((eq format 'html) (format "<a hrefl=\"_blank\" href=\"%s\">%s</a>" path desc))
         ((eq format 'latex) (format "\\href{%s}{%s}" path desc))
         ((eq format 'texinfo) (format "@uref{%s,%s}" path desc))
         ((eq format 'ascii) (format "%s (%s)" desc path))
         (t path))))
    (defun vde/follow-gh-link (issue)
      "Browse github issue/pr specified"
      (browse-url (vde/gh-get-url issue)))

    (defun vde/gh-get-url (path)
      "Translate org-mode link `gh:foo/bar#1' to github url."
      (setq expressions (split-string path "#"))
      (setq project (nth 0 expressions))
      (setq issue (nth 1 expressions))
      (format "https://github.com/%s/issues/%s" project issue))

    (org-link-set-parameters
     "org"
     :complete (lambda () (+org-link-read-file "org" org-directory))
     :follow   (lambda (link) (find-file (expand-file-name link org-directory)))
     :face     (lambda (link)
                 (if (file-exists-p (expand-file-name link org-directory))
                     'org-link
                   'error)))
    (defun +org-link-read-file (key dir)
      (let ((file (read-file-name (format "%s: " (capitalize key)) dir)))
        (format "%s:%s"
                key
                (file-relative-name file dir))))
    )

  (defun vde/org-mode-hook ()
    "Org-mode hook"
    (setq show-trailing-whitespace t)
    (when (not (eq major-mode 'org-agenda-mode))
      (setq fill-column 90)
      (auto-revert-mode)
      (auto-fill-mode)
      (flyspell-mode)
      (org-indent-mode)
      (smartparens-mode)))

  (use-package org-id
    :after org
    :custom
    (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
    :config
    (defun eos/org-custom-id-get (&optional pom create prefix)
      "Get the CUSTOM_ID property of the entry at point-or-marker POM.
     If POM is nil, refer to the entry at point. If the entry does
     not have an CUSTOM_ID, the function returns nil. However, when
     CREATE is non nil, create a CUSTOM_ID if none is present
     already. PREFIX will be passed through to `org-id-new'. In any
     case, the CUSTOM_ID of the entry is returned."
      (interactive)
      (org-with-point-at pom
        (let ((id (org-entry-get nil "CUSTOM_ID")))
          (cond
           ((and id (stringp id) (string-match "\\S-" id))
            id)
           (create
            (setq id (org-id-new (concat prefix "h")))
            (org-entry-put pom "CUSTOM_ID" id)
            (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
            id)))))

    (defun eos/org-add-ids-to-headlines-in-file ()
      "Add CUSTOM_ID properties to all headlines in the
     current file which do not already have one."
      (interactive)
      (org-map-entries (lambda ()
                         (eos/org-custom-id-get (point) 'create)))))

  (use-package ob-go
    :after (org))
  (use-package ob-async
    :after (org))
  (use-package ob-http
    :after (org))

  (use-package org-crypt
    :after (org)
    :config
    (org-crypt-use-before-save-magic)
    (setq org-tags-exclude-from-inheritance (quote ("crypt"))))

  (use-package smartparens-org
    :after org-mode)

  (use-package ox-publish
    :config
    (setq org-html-coding-system 'utf-8-unix))
  (use-package ox-slack
    :after ox)
  (use-package ox-hugo
    :after ox
    :commands (org-hugo-slug)
    :bind (:map vde-mode-map
                ("C-c G" . org-hugo-export-wim-to-md))
    :config
    (use-package ox-hugo-auto-export))

  (use-package org-notify
    :after org
    :config
    (org-notify-start))

  (use-package org-capture-pop-frame)

  (use-package darkroom
    :custom
    (darkroom-text-scale-increase 2))
  (use-package org-tree-slide
    :after (org darkroom)
    :custom
    (org-tree-slide-breadcrumbs nil)
    (org-tree-slide-header nil)
    (org-tree-slide-slide-in-effect nil)
    (org-tree-slide-heading-emphasis nil)
    (org-tree-slide-cursor-init t)
    (org-tree-slide-modeline-display nil)
    (org-tree-slide-skip-done nil)
    (org-tree-slide-skip-comments t)
    (org-tree-slide-fold-subtrees-skipped t)
    (org-tree-slide-skip-outline-level 8)
    (org-tree-slide-never-touch-face t)
    :config
    (defun prot/org-presentation ()
      "Specifies conditions that should apply locally upon
  activation of `org-tree-slide-mode'."
      (if (eq darkroom-tentative-mode nil)
          (progn
            (darkroom-tentative-mode 1)
            (org-indent-mode 1)
            (set-frame-font "Hack-14" t t)
            (setq cursor-type '(bar . 1)))
        (darkroom-tentative-mode -1)
        (org-indent-mode -1)
        (prot/fonts-per-monitor)
        (setq cursor-type 'box)))
    :bind (("<f8>" . org-tree-slide-mode)
           :map org-tree-slide-mode-map
           ("<C-right>" . org-tree-slide-move-next-tree)
           ("<C-left>" . org-tree-slide-move-previous-tree))
    :hook (org-tree-slide-mode . prot/org-presentation))

  (use-package orgit
    :after magit)

  (provide 'setup-org)
#+end_src

*** ~setup-projectile.el~
:PROPERTIES:
:CUSTOM_ID: h:8b4f0172-d070-4563-808f-064d4c1fd61d
:END:

#+begin_src emacs-lisp :tangle lisp/setup-projectile.el
  ;;; -*- lexical-binding: t; -*-
  (use-package projectile                 ; Project management
    :init (projectile-mode)
    :bind-keymap ("C-c p" . projectile-command-map)
    :config
    ;; Remove dead projects when Emacs is idle
    (run-with-idle-timer 10 nil #'projectile-cleanup-known-projects)
    (setq
     ;; Custom compilation buffer name function
     compilation-buffer-name-function (lambda (mode) (concat "*" (downcase mode) ": " (projectile-project-name) "*"))
     projectile-completion-system 'ivy
     projectile-find-dir-includes-top-level t
     projectile-switch-project-action #'projectile-commander
     projectile-create-missing-test-files t
     projectile-mode-line '(:eval (format " Proj[%s]" (projectile-project-name))))
    (def-projectile-commander-method ?s
      "Open a *shell* buffer for the project"
      (projectile-run-eshell))
    (def-projectile-commander-method ?c
      "Run `compile' in the project"
      (projectile-compile-project nil)))

  (use-package counsel-projectile         ; Ivy integration for Projectile
    :bind (:map projectile-command-map
                ("p" . counsel-projectile-switch-project)
                ("r" . counsel-projectile-rg))
    :init (counsel-projectile-mode))

  (provide 'setup-projectile)
#+end_src

*** ~setup-search.el~
:PROPERTIES:
:CUSTOM_ID: h:190839ba-ced5-4b72-b2cd-1d65603d2082
:END:

#+begin_src emacs-lisp :tangle lisp/setup-search.el
  ;;; -*- lexical-binding: t; -*-
  ;; Ignore directories during grep
  (with-eval-after-load 'grep
    '(progn
       (add-to-list 'grep-find-ignored-directories "auto")
       (add-to-list 'grep-find-ignored-directories "elpa")))

  ;; Truncate lines during grep
  (add-hook 'grep-mode-hook #'toggle-truncate-lines)
  (use-package isearch
    :custom
    (search-whitespace-regexp ".*?")
    (isearch-lax-whitespace t)
    (isearch-regexp-lax-whitespace nil)
    :config
    (defun prot/isearch-mark-and-exit ()
      "Marks the current search string.  Can be used as a building
  block for a more complex chain, such as to kill a region, or
  place multiple cursors."
      (interactive)
      (push-mark isearch-other-end t 'activate)
      (setq deactivate-mark nil)
      (isearch-done))

    (defun stribb/isearch-region (&optional not-regexp no-recursive-edit)
      "If a region is active, make this the isearch default search
  pattern."
      (interactive "P\np")
      (when (use-region-p)
        (let ((search (buffer-substring-no-properties
                       (region-beginning)
                       (region-end))))
          (message "stribb/ir: %s %d %d" search (region-beginning) (region-end))
          (setq deactivate-mark t)
          (isearch-yank-string search))))
    (advice-add 'isearch-forward-regexp :after 'stribb/isearch-region)
    (advice-add 'isearch-forward :after 'stribb/isearch-region)
    (advice-add 'isearch-backward-regexp :after 'stribb/isearch-region)
    (advice-add 'isearch-backward :after 'stribb/isearch-region)

    (defun contrib/isearchp-remove-failed-part-or-last-char ()
      "Remove failed part of search string, or last char if successful.
  Do nothing if search string is empty to start with."
      (interactive)
      (if (equal isearch-string "")
          (isearch-update)
        (if isearch-success
            (isearch-delete-char)
          (while (isearch-fail-pos) (isearch-pop-state)))
        (isearch-update)))

    (defun contrib/isearch-done-opposite-end (&optional nopush edit)
      "End current search in the opposite side of the match.
  Particularly useful when the match does not fall within the
  confines of word boundaries (e.g. multiple words)."
      (interactive)
      (funcall #'isearch-done nopush edit)
      (when isearch-other-end (goto-char isearch-other-end)))
    :bind (("M-s M-o" . multi-occur)
           :map isearch-mode-map
           ("C-SPC" . prot/isearch-mark-and-exit)
           ("DEL" . contrib/isearchp-remove-failed-part-or-last-char)
           ("<C-return>" . contrib/isearch-done-opposite-end)))

  (use-package anzu
    :ensure t
    :delight
    :custom
    (anzu-search-threshold 100)
    (anzu-replace-threshold nil)
    (anzu-deactivate-region nil)
    (anzu-replace-to-string-separator "")
    :config
    (global-anzu-mode 1)
    :bind (([remap isearch-query-replace] . anzu-isearch-query-replace)
           ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))
    ([remap query-replace] . anzu-query-replace)
    ([remap query-replace-regexp] . anzu-query-replace-regexp)
    ("M-s %" . anzu-query-replace-at-cursor))

  (use-package swiper
    :after ivy
    :custom
    (swiper-action-recenter t)
    (swiper-goto-start-of-match t)
    (swiper-include-line-number-in-search t)
    :bind (("C-S-s" . swiper)
           ("M-s s" . swiper-multi)
           ("M-s w" . swiper-thing-at-point)
           :map swiper-map
           ("M-y" . yank)
           ("C-." . swiper-avy)))

  (use-package wgrep                      ; Editable grep buffer
    :defer 2
    :custom
    (wgrep-auto-save-buffer t)
    (wgrep-change-readonly-file t))

  (use-package visual-regexp              ; Regexp replace with in-buffer display
    :bind (("C-c s r" . vr/query-replace)
           ("C-c s R" . vr/replace)))

  (provide 'setup-search)
#+end_src

*** ~setup-shells.el~
:PROPERTIES:
:CUSTOM_ID: h:7b4b9a30-5e03-42f4-b5d1-c0ca1236ac3f
:END:

#+begin_src emacs-lisp :tangle lisp/setup-shells.el
  ;;; -*- lexical-binding: t; -*-
  (use-package shell                 ; Specialized comint.el for running the shell
    :custom
                                          ;(ansi-color-for-comint-mode 'filter)
    (explicit-shell-file-name "zsh")
    (shell-file-name "zsh")
    :bind (("<f1>"      . shell)
           (:map shell-mode-map
                 ("<tab>" . completion-at-point)))
    :config
    (unbind-key "C-c C-l" shell-mode-map)
    (bind-key "C-c C-l" #'counsel-shell-history shell-mode-map)

    (defun vde/comint-delchar-or-eof-or-kill-buffer (arg)
      "Restore window configuration if process is dead, otherwise delete ARG."
      (interactive "p")
      (if (null (get-buffer-process (current-buffer)))
          (vde/pop-window-configuration)
        (comint-delchar-or-maybe-eof arg)))

    (add-hook 'shell-mode-hook
              (lambda ()
                (bind-key "C-d" #'vde/comint-delchar-or-eof-or-kill-buffer
                          shell-mode-map)))
    )

  (use-package eshell                     ; Emacs command shell
    :bind* ("C-x m t" . eshell-here)
    :config
    (defun eshell-here ()
      "Open EShell in the directory associated with the current buffer's file.
  The EShell is renamed to match that directory to make multiple windows easier."
      (interactive)
      (let* ((parent (if (buffer-file-name)
                         (file-name-directory (buffer-file-name))
                       default-directory))
             (name   (car (last (split-string parent "/" t)))))
        (eshell "new")
        (rename-buffer (concat "*eshell: " name "*"))))

    ;; Handy aliases
    (defalias 'ff 'find-file)

    (defun eshell/d ()
      "Open a dired instance of the current working directory."
      (dired "."))

    (defun eshell/gs (&rest args)
      (magit-status (pop args) nil)
      (eshell/echo))                      ; The echo command suppresses output

    (defun eshell/extract (file)
      "One universal command to extract FILE (for bz2, gz, rar, etc.)"
      (eshell-command-result (format "%s %s" (cond ((string-match-p ".*\.tar.bz2" file)
                                                    "tar xzf")
                                                   ((string-match-p ".*\.tar.gz" file)
                                                    "tar xzf")
                                                   ((string-match-p ".*\.bz2" file)
                                                    "bunzip2")
                                                   ((string-match-p ".*\.rar" file)
                                                    "unrar x")
                                                   ((string-match-p ".*\.gz" file)
                                                    "gunzip")
                                                   ((string-match-p ".*\.tar" file)
                                                    "tar xf")
                                                   ((string-match-p ".*\.tbz2" file)
                                                    "tar xjf")
                                                   ((string-match-p ".*\.tgz" file)
                                                    "tar xzf")
                                                   ((string-match-p ".*\.zip" file)
                                                    "unzip")
                                                   ((string-match-p ".*\.jar" file)
                                                    "unzip")
                                                   ((string-match-p ".*\.Z" file)
                                                    "uncompress")
                                                   (t
                                                    (error "Don't know how to extract %s" file)))
                                     file)))

    (add-hook
     'eshell-mode-hook
     (lambda ()
       (let ((ls (if (executable-find "exa") "exa" "ls")))
         (eshell/alias "ls" (concat ls " --color=always $*"))
         (eshell/alias "ll" (concat ls " --color=always -l $*"))
         (eshell/alias "l" (concat ls " --color=always -lah $*")))
       (eshell-smart-initialize)
       (eshell-dirs-initialize)
       (bind-keys :map eshell-mode-map
                  ("C-c C-l"                . counsel-esh-history)
                  ([remap eshell-pcomplete] . completion-at-point))))

    ;; Use system su/sudo
    (with-eval-after-load "em-unix"
      '(progn
         (unintern 'eshell/su nil)
         (unintern 'eshell/sudo nil)))

    (add-hook 'eshell-mode-hook #'with-editor-export-editor))

  (use-package em-prompt                  ; EShell command prompts
    :defer 2
    :config
    (defun vde/eshell-quit-or-delete-char (arg)
      "Use C-d to either delete forward char or exit EShell."
      (interactive "p")
      (if (and (eolp) (looking-back eshell-prompt-regexp nil nil))
          (progn
            (eshell-life-is-too-much))
        (delete-char arg)))

    (add-hook 'eshell-mode-hook
              (lambda ()
                (bind-key "C-d"
                          #'vde/eshell-quit-or-delete-char eshell-mode-map))))

  (use-package esh-mode                   ; EShell UI customizations
    :ensure eshell
    :config (setq eshell-scroll-to-bottom-on-input 'all))

  (use-package em-smart
    :ensure eshell)
  (use-package em-dirs
    :ensure eshell)

  (use-package em-cmpl                    ; EShell TAB completion
    :ensure eshell
    :config
    (add-hook 'eshell-mode-hook #'eshell-cmpl-initialize)

    (add-to-list 'eshell-command-completions-alist
                 '("gunzip" "gz\\'"))
    (add-to-list 'eshell-command-completions-alist
                 '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'")))

  (use-package em-hist                    ; EShell History management
    :ensure eshell
    :config (setq eshell-hist-ignoredups t))

  (use-package em-term                    ; Handle visual commands in EShell
    :ensure eshell
    :config
    (add-to-list 'eshell-visual-commands "ssh")
    (add-to-list 'eshell-visual-commands "htop")
    (add-to-list 'eshell-visual-commands "top")
    (add-to-list 'eshell-visual-commands "tail")
    (add-to-list 'eshell-visual-commands "npm")
    (add-to-list 'eshell-visual-commands "ncdu"))

  (use-package em-banner
    :ensure eshell
    :config
    (setq eshell-banner-message "
    Welcome to the Emacs

                           _/                  _/  _/
        _/_/      _/_/_/  _/_/_/      _/_/    _/  _/
     _/_/_/_/  _/_/      _/    _/  _/_/_/_/  _/  _/
    _/            _/_/  _/    _/  _/        _/  _/
     _/_/_/  _/_/_/    _/    _/    _/_/_/  _/  _/

  "))

  (use-package fish-completion            ; Add Fish completion to EShell
    :defer 2
    :when (executable-find "fish")
    :config (add-hook 'eshell-mode-hook #'fish-completion-mode))

  (use-package eshell-prompt-extras
    :defer 1
    :custom
    (eshell-highlight-prompt nil)
    (eshell-prompt-function 'vde-theme-lambda)
    :config
    (defun vde-kubernetes-current-context ()
      "Return the current context"
      (if (not (string-empty-p (getenv "KUBECONFIG")))
          (epe-trim-newline (shell-command-to-string (concat
                                                      "env KUBECONFIG="
                                                      (getenv "KUBECONFIG")
                                                      " kubectl config current-context")))
        (epe-trim-newline (shell-command-to-string "kubectl config current-context"))))
    (defun vde-kubernetes-p ()
      "If you have kubectl install and a config set,
  using either KUBECONFIG or ~/.kube/config"
      (and (eshell-search-path "kubectl")
           (not (string-empty-p (vde-kubernetes-current-context)))
           (not (string-match-p "error: current-context is not set" (vde-kubernetes-current-context)))))
    ;; From epe-theme-lambda
    (defun vde-theme-lambda ()
      "A eshell-prompt lambda theme."
      (setq eshell-prompt-regexp "^[^#\nλ]*[#λ] ")
      (concat
       (when (epe-remote-p)
         (epe-colorize-with-face
          (concat (epe-remote-user) "@" (epe-remote-host) " ")
          'epe-remote-face))
       (when (and epe-show-python-info (bound-and-true-p venv-current-name))
         (epe-colorize-with-face (concat "(" venv-current-name ") ") 'epe-venv-face))
       (let ((f (cond ((eq epe-path-style 'fish) 'epe-fish-path)
                      ((eq epe-path-style 'single) 'epe-abbrev-dir-name)
                      ((eq epe-path-style 'full) 'abbreviate-file-name))))
         (epe-colorize-with-face (funcall f (eshell/pwd)) 'epe-dir-face))
       (when (epe-git-p)
         (concat
          (epe-colorize-with-face ":" 'epe-dir-face)
          (epe-colorize-with-face
           (concat (epe-git-branch)
                   (epe-git-dirty)
                   (epe-git-untracked)
                   (let ((unpushed (epe-git-unpushed-number)))
                     (unless (= unpushed 0)
                       (concat ":" (number-to-string unpushed)))))
           'epe-git-face)))
       (when (vde-kubernetes-p)
         (concat (epe-colorize-with-face " (" 'epe-dir-face)
                 (epe-colorize-with-face (vde-kubernetes-current-context) 'epe-dir-face)
                 (epe-colorize-with-face ")" 'epe-dir-face)))
       (epe-colorize-with-face " λ" 'epe-symbol-face)
       (epe-colorize-with-face (if (= (user-uid) 0) "#" "") 'epe-sudo-symbol-face)
       " ")))

  (use-package esh-autosuggest
    :defer 1
    :hook (eshell-mode . esh-autosuggest-mode))

  (use-package xterm-color
    :init
    (setq comint-output-filter-functions
          (remove 'ansi-color-process-output comint-output-filter-functions))
    (add-hook 'shell-mode-hook
              (lambda ()
                ;; Disable font-locking in this buffer to improve performance
                (font-lock-mode -1)
                ;; Prevent font-locking from being re-enabled in this buffer
                (make-local-variable 'font-lock-function)
                (setq font-lock-function (lambda (_) nil))
                (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
    (add-hook 'eshell-before-prompt-hook
              (lambda ()
                (setenv "TERM" "xterm-256color")
                (setq xterm-color-preserve-properties t)))
    (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
    (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
    (setq compilation-environment '("TERM=xterm-256color"))
    (add-hook 'compilation-start-hook
              (lambda (proc)
                ;; We need to differentiate between compilation-mode buffers
                ;; and running as part of comint (which at this point we assume
                ;; has been configured separately for xterm-color)
                (when (eq (process-filter proc) 'compilation-filter)
                  ;; This is a process associated with a compilation-mode buffer.
                  ;; We may call `xterm-color-filter' before its own filter function.
                  (set-process-filter
                   proc
                   (lambda (proc string)
                     (funcall 'compilation-filter proc
                              (xterm-color-filter string))))))))

  ;; for fish in ansi-term
  (add-hook 'term-mode-hook 'toggle-truncate-lines)

  (provide 'setup-shells)
#+end_src

*** ~setup-style.el~
:PROPERTIES:
:CUSTOM_ID: h:3261211e-0ffb-44de-8a35-f3612d333c68
:END:

#+begin_src emacs-lisp :tangle lisp/setup-style.el
  ;;; -*- lexical-binding: t; -*-
  ;;; ¯\_(ツ)_/¯
  ;;; - Iosevka (https://github.com/be5invis/Iosevka)
  ;;; - Fira Sans (https://github.com/mozilla/Fira/)
  (setq font-height 110)
  (cond
   ((string= (system-name) "hokkaido")
    (setq font-height 100)))
  ;; Middle/Near East: שלום, السّلام عليكم
  (when (member "Noto Sans Arabic" (font-family-list))
    (set-fontset-font t 'arabic "Noto Sans Arabic"))
  (when (member "Noto Sans Hebrew" (font-family-list))
    (set-fontset-font t 'arabic "Noto Sans Hebrew"))

  ;; Africa: ሠላም
  (when (member "Noto Sans Ethiopic" (font-family-list))
    (set-fontset-font t 'ethiopic "Noto Sans Ethiopic"))

  (set-face-attribute 'default nil
                      :family "Fira Code" ; "Overpass Mono" to try someday
                      :height font-height)
  (set-face-attribute 'variable-pitch nil
                      :family "Fira Sans"
                      :height font-height
                      :weight 'regular)

  ;;; Utilities and key bindings
  (defun mu-reset-fonts ()
    "Reset fonts to my preferences."
    (interactive)
    (set-face-attribute 'default nil
                        :family "Fira Code"
                        :height font-height)
    (set-face-attribute 'variable-pitch nil
                        :family "Fira Sans"
                        :height font-height
                        :weight 'regular))

  (bind-key "C-c t f" #'mu-reset-fonts)

  ;;; Interface
  (use-package frame                      ; Frames
    :bind ("C-c w f" . toggle-frame-fullscreen)
    :init
    ;; Kill `suspend-frame'
    (unbind-key "C-x C-z")
    :config (add-to-list 'initial-frame-alist '(fullscreen . maximized)))

  (use-package emacs
    :custom
    (use-file-dialog nil)
    (use-dialog-box nil)
    (inhibit-splash-screen t)
    (echo-keystrokes 0.1) ; Faster echo keystrokes
    (line-number-display-limit-width 10000) ;; Avoid showing ?? in the mode line when we have long lines.
    (display-time-world-list '(("Europe/London" "London")
                               ("Europe/Paris" "Paris")
                               ("America/New_York" "Boston")
                               ("America/Los_Angeles" "San-Francisco")
                               ("Asia/Calcutta" "Bangalore")
                               ("Australia/Brisbane" "Brisbane")))
    :config
    (line-number-mode 1)
    (column-number-mode 1)
    (global-hl-line-mode 1)
    (global-unset-key (kbd "C-z"))
    (global-unset-key (kbd "C-x C-z"))
    (global-unset-key (kbd "C-h h")))

  ;;; Theme
  (setq custom-safe-themes t)    ; Treat themes as safe

  (use-package doom-themes
    :config
    (load-theme 'doom-one t)
    (doom-themes-visual-bell-config)
    (doom-themes-org-config))

  (use-package solaire-mode
    :config
    (setq solaire-mode-remap-modeline nil)
    (add-hook 'after-change-major-mode-hook #'turn-on-solaire-mode)
    (add-hook 'after-revert-hook #'turn-on-solaire-mode)
    (add-hook 'minibuffer-setup-hook #'solaire-mode-in-minibuffer)
    (add-hook 'ediff-prepare-buffer-hook #'solaire-mode)
    (advice-add #'persp-load-state-from-file :after #'solaire-mode-restore-persp-mode-buffers))

  ;; Show buffer position percentage starting from top
  (setq mode-line-percent-position '(-3 "%o"))
  (defvar mu-eyebrowse-mode-line
    '(:propertize
      (:eval
       (when (bound-and-true-p eyebrowse-mode)
         (let* ((num (eyebrowse--get 'current-slot))
                (tag (when num
                       (nth 2 (assoc num (eyebrowse--get 'window-configs)))))
                (str (concat
                      " "
                      (if (and tag (< 0 (length tag)))
                          tag
                        (when num (int-to-string num)))
                      " ")))
           str)))
      face (:background "#81a2be" :foreground "#373b41"))
    "Mode line format for Eyebrowse.")

  (put 'mu-eyebrowse-mode-line 'risky-local-variable t)

  (setq-default mode-line-format
                '("%e"
                  mu-eyebrowse-mode-line
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification " " mode-line-position
                  (vc-mode vc-mode)
                  (multiple-cursors-mode mc/mode-line)
                  " " mode-line-modes
                  mode-line-end-spaces))

  (defmacro rename-modeline (package-name mode new-name)
    "Rename PACKAGE-NAME with MODE into NEW-NAME in the mode line."
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))

  (defun generic-term-init ()
    (visual-line-mode -1)
    (setq-local global-hl-line-mode nil)
    (setq-local scroll-margin 0))

  (add-hook 'term-mode-hook #'generic-term-init)
  (add-hook 'shell-mode-hook #'generic-term-init)
  (add-hook 'eshell-mode-hook #'generic-term-init)

  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))

  (use-package minions                    ; A minor-mode menu for the mode line
    :init (minions-mode)
    :config
    (setq
     minions-mode-line-lighter "λ="
     minions-direct '(flycheck-mode)))

  (setq-default indicate-buffer-boundaries 'left)
  (setq-default indicate-empty-lines +1)

  (use-package highlight
    :ensure t
    :pin melpa)

  (use-package highlight-numbers
    :hook (prog-mode . highlight-numbers-mode))

  (use-package symbol-overlay
    :defer 4
    :bind
    ("M-s h ." . symbol-overlay-put)
    ("M-s h n" . symbol-overlay-jump-next)
    ("M-s h p" . symbol-overlay-jump-prev)
    :hook (prog-mode . symbol-overlay-mode)
    :config
    (setq symbol-overlay-idle-time 0.2))

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  (use-package rainbow-mode
    :commands rainbow-mode
    :hook (prog-mode . rainbow-mode))

  (use-package visual-fill-column
    :commands visual-fill-column-mode)

  (use-package hide-mode-line-mode
    :commands hide-mode-line-mode)

  (defun set-light-theme ()
    "Set the light theme with some customization if needed."
    (interactive)
    (load-theme 'doom-one-light t))

  (defun set-dark-theme ()
    "Set the dark theme with some customization if needed."
    (interactive)
    (load-theme 'doom-one t))

  (defun theme-switcher ()
    (interactive)
    (let ((current-hour (string-to-number (format-time-string "%H"))))
      (if (and (> current-hour 6) (< current-hour 20))
          (set-light-theme)
        (set-dark-theme))))

  ;; Run at every 3600 seconds, after 0s delay
  (run-with-timer 0 3600 'theme-switcher)

  (provide 'setup-style)
#+end_src

*** ~setup-vcs.el~
:PROPERTIES:
:CUSTOM_ID: h:90edb897-d72a-4433-86c7-f6f446e9ed97
:END:

#+begin_src emacs-lisp :tangle lisp/setup-vcs.el
  ;;; -*- lexical-binding: t; -*-
  (use-package vc-hooks                   ; Simple version control
    :bind (("S-<f5>" . vc-revert)
           ("C-c v r" . vc-refresh-state))
    :config
    ;; Always follow symlinks to files in VCS repos
    (setq vc-follow-symlinks t))

  (use-package magit                      ; The best Git client out there
    :bind (("C-c v c" . magit-clone)
           ("C-c v C" . magit-checkout)
           ("C-c v d" . magit-dispatch-popup)
           ("C-c v g" . magit-blame)
           ("C-c v l" . magit-log-buffer-file)
           ("C-c v p" . magit-pull)
           ("C-c v v" . magit-status))
    :config
    (setq
     magit-save-repository-buffers 'dontask
     magit-refs-show-commit-count 'all
     magit-branch-prefer-remote-upstream '("master")
     magit-display-buffer-function #'magit-display-buffer-traditional
     magit-completing-read-function 'ivy-completing-read
     )

    (magit-define-popup-option 'magit-rebase-popup
      ?S "Sign using gpg" "--gpg-sign=" #'magit-read-gpg-secret-key)
    (magit-define-popup-switch 'magit-log-popup
      ?m "Omit merge commits" "--no-merges")

    ;; Hide "Recent Commits"
    (magit-add-section-hook 'magit-status-sections-hook
                            'magit-insert-unpushed-to-upstream
                            'magit-insert-unpushed-to-upstream-or-recent
                            'replace)

    (use-package magit-files
      :config
      (global-magit-file-mode))

    ;; Show refined hunks during diffs
    (set-default 'magit-diff-refine-hunk t)

    (add-hook 'projectile-switch-project-hook
              #'mu-magit-set-repo-dirs-from-projectile)

    ;; Refresh `magit-status' after saving a buffer
    (add-hook 'after-save-hook #'magit-after-save-refresh-status)

    ;; Free C-c C-w for Eyebrowse
    (unbind-key "C-c C-w" git-commit-mode-map)  )

  (use-package forge
    :after magit)

  (use-package magit-repos
    :after magit
    :commands magit-list-repositories
    :config
    (setq magit-repository-directories
          '(("~/src" . 3))))

  (use-package git-commit                 ; Git commit message mode
    :defer 2
    :init (global-git-commit-mode)
    :config
    (setq git-commit-summary-max-length 50)
    (setq git-commit-known-pseudo-headers
          '("Signed-off-by"
            "Acked-by"
            "Modified-by"
            "Cc"
            "Suggested-by"
            "Reported-by"
            "Tested-by"
            "Reviewed-by"))
    (setq git-commit-style-convention-checks
          '(non-empty-second-line
            overlong-summary-line))
    (remove-hook 'git-commit-finish-query-functions
                 #'git-commit-check-style-conventions))

  (use-package gitconfig-mode             ; Git configuration mode
    :defer 2)

  (use-package gitignore-mode             ; .gitignore mode
    :defer 2)

  (use-package gitattributes-mode         ; Git attributes mode
    :defer 2)

  (use-package dired-git-info
    :bind (:map dired-mode-map
                (")" . dired-git-info-mode))
    :defer 2)

  (defun git-blame-line ()
    "Runs `git blame` on the current line and
     adds the commit id to the kill ring"
    (interactive)
    (let* ((line-number (save-excursion
                          (goto-char (point-at-bol))
                          (+ 1 (count-lines 1 (point)))))
           (line-arg (format "%d,%d" line-number line-number))
           (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
      (call-process "git" nil commit-buf nil
                    "blame" (buffer-file-name) "-L" line-arg)
      (let* ((commit-id (with-current-buffer commit-buf
                          (buffer-substring 1 9)))
             (log-buf (generate-new-buffer "*git-blame-line-log*")))
        (kill-new commit-id)
        (call-process "git" nil log-buf nil
                      "log" "-1" "--pretty=%h   %an   %s" commit-id)
        (with-current-buffer log-buf
          (message "Line %d: %s" line-number (buffer-string)))
        (kill-buffer log-buf))
      (kill-buffer commit-buf)))

  (provide 'setup-vcs)
#+end_src

*** ~setup-vde-mode.el~
:PROPERTIES:
:CUSTOM_ID: h:d61614e2-7b13-43f3-aec8-a854bcaaeb0c
:END:

#+begin_src emacs-lisp :tangle lisp/setup-vde-mode.el
  ;;; -*- lexical-binding: t; -*-
  (defvar vde-special-keymap-prefix (kbd "C-x m")
    "`vde-mode' keymap prefix.
  Overrides the default binding for `compose-mail'.")

  (defvar vde-mode-special-map (make-sparse-keymap)
    "Special keymap for `vde-mode' whose bindings begin with
  `vde-special-keymap-prefix'.")
  (fset 'vde-mode-special-map vde-mode-special-map)

  (defvar vde-mode-map (let ((map (make-sparse-keymap)))
                         (define-key map vde-special-keymap-prefix 'vde-mode-special-map)
                         map)
    "Keymap for `vde-mode'.")

  ;;;###autoload
  (define-minor-mode vde-mode
    "A minor mode so that my key settings override annoying major modes."
    ;; If init-value is not set to t, this mode does not get enabled in
    ;; `fundamental-mode' buffers even after doing \"(global-vde-mode 1)\".
    ;; More info: http://emacs.stackexchange.com/q/16693/115
    :init-value t
    :lighter    " μ"
    :keymap     vde-mode-map)

  ;;;###autoload
  (define-globalized-minor-mode global-vde-mode vde-mode vde-mode)

  ;; https://github.com/jwiegley/use-package/blob/master/bind-key.el
  ;; The keymaps in `emulation-mode-map-alists' take precedence over
  ;; `minor-mode-map-alist'
  (add-to-list 'emulation-mode-map-alists `((vde-mode . ,vde-mode-map)))

  ;; Turn off the minor mode in the minibuffer
  (defun turn-off-vde-mode ()
    "Turn off vde-mode."
    (vde-mode -1))
  (add-hook 'minibuffer-setup-hook #'turn-off-vde-mode)

  (defmacro bind-to-vde-map (key fn)
    "Bind a function to the `vde-mode-special-map'.
  USAGE: (bind-to-vde-map \"f\" #'full-screen-center)."
    `(define-key vde-mode-special-map (kbd ,key) ,fn))

  ;; http://emacs.stackexchange.com/a/12906/115
  (defun unbind-from-vde-map (key)
    "Unbind a function from the `vde-mode-map'
  USAGE: (unbind-from-vde-map \"C-x m f\")
  "
    (interactive "Unset key from vde-mode-map: ")
    (define-key vde-mode-map (kbd (key-description key)) nil)
    (message "%s" (format "Unbound %s key from the %s."
                          (propertize (key-description key)
                                      'face 'font-lock-function-name-face)
                          (propertize "vde-mode-map"
                                      'face 'font-lock-function-name-face))))

  (provide 'setup-vde-mode)
  ;; Minor mode tutorial: http://nullprogram.com/blog/2013/02/06/
#+end_src

*** ~setup-web.el~
:PROPERTIES:
:CUSTOM_ID: h:7b53ca52-4212-4b40-bb15-d320ecfcf2d5
:END:

#+begin_src emacs-lisp :tangle lisp/setup-web.el
  ;;; -*- lexical-binding: t; -*-
  (use-package web-mode
    :mode
    ("\\.html\\'" . web-mode)
    ("\\.phtml\\'" . web-mode)
    ("\\.[agj]sp\\'" . web-mode)
    ("\\.as[cp]x\\'" . web-mode)
    ("\\.erb\\'" . web-mode)
    ("\\.mustache\\'" . web-mode)
    ("\\.djhtml\\'" . web-mode)
    ("\\.jsp\\'" . web-mode)
    ("\\.eex\\'" . web-mode)
    ("\\.tsx\\'" . web-mode)
    :config
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-sql-indent-offset 2)
    (eval-after-load 'smartparens
      (lambda ()
        (setq web-mode-enable-auto-pairing nil)
        (sp-with-modes '(web-mode)
          (sp-local-pair "%" "%"
                         :unless '(sp-in-string-p)
                         :post-handlers '(((lambda (&rest _ignored)
                                             (just-one-space)
                                             (save-excursion (insert " ")))
                                           "SPC" "=" "#")))
          (sp-local-tag "%" "<% "  " %>")
          (sp-local-tag "=" "<%= " " %>")
          (sp-local-tag "#" "<%# " " %>")))))

  (provide 'setup-web)
#+end_src

*** ~setup-windows.el~
:PROPERTIES:
:CUSTOM_ID: h:f00c62a0-5aed-4192-bfe8-c04f5e7e9cbe
:END:

#+begin_src emacs-lisp :tangle lisp/setup-windows.el
  ;;; -*- lexical-binding: t; -*-
  (setq window-combination-resize t) ; Size new windows proportionally

  ;;;###autoload
  (defun vde/window-split-toggle ()
    "Toggle between horizontal and vertical split with two windows."
    (interactive)
    (if (> (length (window-list)) 2)
        (error "Can't toggle with more than 2 windows!")
      (let ((func (if (window-full-height-p)
                      #'split-window-vertically
                    #'split-window-horizontally)))
        (delete-other-windows)
        (funcall func)
        (save-selected-window
          (other-window 1)
          (switch-to-buffer (other-buffer))))))

  (bind-key "C-c w t" #'vde/window-split-toggle)

  (defvar vde/saved-window-configuration nil)

  (defun vde/save-wins-then-call (func &optional args)
    "Save current window configuration, then call FUNC optionally with ARGS."
    (interactive)
    (push (current-window-configuration) vde/saved-window-configuration)
    (cond
     ;; We have arguments for the function
     ((bound-and-true-p args) (funcall func args))
     ;; The function expects exactly one argument, and we want it to be nil
     ((equal args "nil") (funcall func nil))
     ;; The function does not expect arguments
     (t (funcall func))))

  (defun vde/restore-window-configuration (config)
    "Kill current buffer and restore the window configuration in CONFIG."
    (interactive)
    (kill-this-buffer)
    (set-window-configuration config))

  (defun vde/pop-window-configuration ()
    "Restore the previous window configuration and clear current window."
    (interactive)
    (let ((config (pop vde/saved-window-configuration)))
      (if config
          (vde/restore-window-configuration config)
        (if (> (length (window-list)) 1)
            (delete-window)
          (bury-buffer)))))

  (use-package eyebrowse                  ; Easy workspaces creation and switching
    :init (eyebrowse-mode t)
    :config
    (setq
     eyebrowse-mode-line-separator " "
     eyebrowse-mode-line-style 'always
     eyebrowse-new-workspace t
     eyebrowse-wrap-around t))

  (use-package ace-window                 ; Better movements between windows
    :custom
    (aw-keys '(?a ?u ?i ?e ?, ?c ?t ?r ?m))
    (aw-scope 'frame)
    (aw-dispatch-always t)
    (aw-dispatch-alist
     '((?s aw-swap-window "Swap Windows")
       (?2 aw-split-window-vert "Split Window Vertically")
       (?3 aw-split-window-horz "Split Window Horizontally")
       (?? aw-show-dispatch-help)))
    (aw-minibuffer-flag t)
    (aw-ignore-current nil)
    (aw-display-mode-overlay t)
    (aw-background t)
    :bind (("C-x o"   . ace-window)
           ("C-c w w" . ace-window)
           ("C-c w s" . ace-swap-window)))

  (use-package windmove
    :bind (("M-<left>" . windmove-left)
           ("M-<down>" . windmove-down)
           ("M-<up>" . windmove-up)
           ("M-<right>" . windmove-right)))

  (provide 'setup-windows)
#+end_src

** External libraries
:PROPERTIES:
:CUSTOM_ID: h:ce167134-1188-4ffb-9d94-61ea13440551
:END:

*** ~gotest-ui.el~
:PROPERTIES:
:CUSTOM_ID: h:0166b379-751d-4d9d-8f7e-ac33fde2b80b
:END:

From [[https://github.com/antifuchs/gotest-ui-mode/][antifuchs/gotest-ui-mode]].

#+begin_src emacs-lisp :tangle lisp/gotest-ui.el
  ;;; gotest-ui.el --- Major mode for running go test -json

  ;; Copyright 2018 Andreas Fuchs
  ;; Authors: Andreas Fuchs <asf@boinkor.net>

  ;; URL: https://github.com/antifuchs/gotest-ui-mode
  ;; Created: Feb 18, 2018
  ;; Keywords: languages go
  ;; Version: 0.1.0
  ;; Package-Requires: ((emacs "25") (s "1.12.0") (gotest "0.14.0"))

  ;; This file is not a part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or
  ;; modify it under the terms of the GNU General Public License as
  ;; published by the Free Software Foundation; either version 3.0, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; if not, write to the Free Software
  ;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  ;;; Commentary:

  ;;  Provides support for running go tests with a nice user interface
  ;;  that allows folding away output, highlighting failing tests.

  ;;; Code:

  (eval-when-compile
    (require 'cl))

  (require 'subr-x)
  (require 'ewoc)
  (require 'json)
  (require 'compile)

  (defgroup gotest-ui nil
    "The go test runner."
    :group 'tools)

  (defface gotest-ui-pass-face '((t :foreground "green"))
    "Face for displaying the status of a passing test."
    :group 'gotest-ui)

  (defface gotest-ui-skip-face '((t :foreground "grey"))
    "Face for displaying the status of a skipped test."
    :group 'gotest-ui)

  (defface gotest-ui-fail-face '((t :foreground "pink" :weight bold))
    "Face for displaying the status of a failed test."
    :group 'gotest-ui)

  (defface gotest-ui-link-face '((t :foreground "white" :weight bold))
    "Face for displaying links to go source files."
    :group 'gotest-ui)

  (defcustom gotest-ui-expand-test-statuses '(fail)
    "Statuses to expand test cases for.
  Whenever a test enters this state, it is automatically expanded."
    :group 'gotest-ui)

  (defcustom gotest-ui-test-binary '("go")
    "Command list used to invoke the `go' binary."
    :group 'gotest-ui)

  (defcustom gotest-ui-test-args '("test" "-json")
    "Argument list used to run tests with JSON output."
    :group 'gotest-ui)

  (defcustom gotest-ui-additional-test-args '()
    "Additional args to pass to `go test'."
    :group 'gotest-ui)

  ;;;; Data model:

  (defstruct (gotest-ui-section :named
                                (:constructor gotest-ui-section-create)
                                (:type vector)
                                (:predicate gotest-ui-section-p))
    title tests node)

  ;;; `gotest-ui-thing' is a thing that can be under test: a
  ;;; package, or a single test.

  (defstruct gotest-ui-thing
    (name)
    (node)
    (expanded-p)
    (status)
    (buffer)    ; the buffer containing this test's output
    (elapsed)   ; a floating-point amount of seconds
    )

  ;;; `gotest-ui-test' is a single test. It contains a status and
  ;;; output.
  (defstruct (gotest-ui-test (:include gotest-ui-thing)
                             (:constructor gotest-ui--make-test-1))
    (package)
    (reason))

  (defun gotest-ui-test->= (test1 test2)
    "Returns true if TEST1's name sorts greater than TEST2's."
    (let ((pkg1 (gotest-ui-test-package test1))
          (pkg2 (gotest-ui-test-package test2))
          (name1 (or (gotest-ui-thing-name test1) ""))
          (name2 (or (gotest-ui-thing-name test2) "")))
      (if (string= pkg1 pkg2)
          (string> name1 name2)
        (string> pkg1 pkg2))))

  (defstruct (gotest-ui-status (:constructor gotest-ui--make-status-1))
    (state)
    (cmdline)
    (dir)
    (output)
    (node))

  (cl-defun gotest-ui--make-status (ewoc cmdline dir)
    (let ((status (gotest-ui--make-status-1 :state 'run :cmdline (s-join " " cmdline) :dir dir)))
      (let ((node (ewoc-enter-first ewoc status)))
        (setf (gotest-ui-status-node status) node))
      status))

  (cl-defun gotest-ui--make-test (ewoc &rest args &key status package name &allow-other-keys)
    (apply #'gotest-ui--make-test-1 :status (or status "run") args))

  ;;; Data manipulation routines:

  (cl-defun gotest-ui-ensure-test (ewoc package-name base-name &key (status 'run))
    (let* ((test-name (format "%s.%s" package-name base-name))
           (test (gethash test-name gotest-ui--tests)))
      (if test
          test
        (setf (gethash test-name gotest-ui--tests)
              (gotest-ui--make-test ewoc :name base-name :package package-name :status status)))))

  (defun gotest-ui-update-status (new-state)
    (setf (gotest-ui-status-state gotest-ui--status) new-state)
    (ewoc-invalidate gotest-ui--ewoc (gotest-ui-status-node gotest-ui--status)))

  (defun gotest-ui-update-status-output (new-output)
    (setf (gotest-ui-status-output gotest-ui--status) new-output)
    (ewoc-invalidate gotest-ui--ewoc (gotest-ui-status-node gotest-ui--status)))

  (defun gotest-ui-ensure-output-buffer (thing)
    (unless (gotest-ui-thing-buffer thing)
      (with-current-buffer
          (setf (gotest-ui-thing-buffer thing)
                (generate-new-buffer (format " *%s" (gotest-ui-thing-name thing))))
        (setq-local gotest-ui-parse-marker (point-min-marker))
        (setq-local gotest-ui-insertion-marker (point-min-marker))
        (set-marker-insertion-type gotest-ui-insertion-marker t)))
    (gotest-ui-thing-buffer thing))

  (defun gotest-ui-mouse-open-file (event)
    "In gotest-ui mode, open the file/line reference in another window."
    (interactive "e")
    (let ((window (posn-window (event-end event)))
          (pos (posn-point (event-end event)))
          file line)
      (if (not (windowp window))
          (error "No file chosen"))
      (with-current-buffer (window-buffer window)
        (goto-char pos)
        (setq file (gotest-ui-get-file-for-visit))
        (setq line (gotest-ui-get-line-for-visit)))
      (unless (file-exists-p file)
        (error "Could not open %s:%d" file line))
      (with-current-buffer (find-file-other-window file)
        (goto-char (point-min))
        (forward-line (1- line)))))

  (defun gotest-ui-get-file-for-visit ()
    (get-text-property (point) 'gotest-ui-file))

  (defun gotest-ui-get-line-for-visit ()
    (string-to-number (get-text-property (point) 'gotest-ui-line)))

  (defun gotest-ui-file-from-gopath (package file-basename)
    (if (or (file-name-absolute-p file-basename)
            (string-match-p "/" file-basename))
        file-basename
      (let ((gopath (or (getenv "GOPATH")
                        (expand-file-name "~/go"))))
        (expand-file-name (concat gopath "/src/" package "/" file-basename)))))

  (defvar gotest-ui-click-map
    (let ((map (make-sparse-keymap)))
      (define-key map [mouse-2] 'gotest-ui-mouse-open-file)
      map))

  (defun gotest-ui-ensure-parsed (thing)
    (save-excursion
      (goto-char gotest-ui-parse-marker)
      (while (re-search-forward "\\([^ \t]+\\.go\\):\\([0-9]+\\)" gotest-ui-insertion-marker t)
        (let* ((file-basename (match-string 1))
               (file (gotest-ui-file-from-gopath (gotest-ui-test-package thing) file-basename)))
          (set-text-properties (match-beginning 0) (match-end 0)
                               `(face gotest-ui-link-face
                                      gotest-ui-file ,file
                                      gotest-ui-line ,(match-string 2)
                                      keymap ,gotest-ui-click-map
                                      follow-link t
                                      ))))
      (set-marker gotest-ui-parse-marker gotest-ui-insertion-marker)))

  (defun gotest-ui-update-thing-output (thing output)
    (with-current-buffer (gotest-ui-ensure-output-buffer thing)
      (goto-char gotest-ui-insertion-marker)
      (let ((overwrites (split-string output "\r")))
        (insert (car overwrites))
        (dolist (segment (cdr overwrites))
          (let ((delete-to (point)))
            (forward-line 0)
            (delete-region (point) delete-to))
          (insert segment)))
      (set-marker gotest-ui-insertion-marker (point))
      (gotest-ui-ensure-parsed thing)))

  ;; TODO: clean up buffers on kill

  ;;;; Mode definition

  (defvar gotest-ui-mode-map
    (let ((m (make-sparse-keymap)))
      (suppress-keymap m)
      ;; key bindings go here
      (define-key m (kbd "TAB") 'gotest-ui-toggle-expanded)
      (define-key m (kbd "g") 'gotest-ui-rerun)
      m))

  (define-derived-mode gotest-ui-mode special-mode "go test UI"
    "Major mode for running go test with JSON output."
    (setq truncate-lines t)
    (setq buffer-read-only t)
    (setq-local line-move-visual t)
    (setq show-trailing-whitespace nil)
    (setq list-buffers-directory default-directory)
    (make-local-variable 'text-property-default-nonsticky)
    (push (cons 'keymap t) text-property-default-nonsticky))


  (defun gotest-ui--clear-buffer (buffer)
    (let ((dir default-directory))
      (with-current-buffer buffer
        (when (buffer-live-p gotest-ui--process-buffer)
          (kill-buffer gotest-ui--process-buffer))
        (kill-all-local-variables)
        (let  ((buffer-read-only nil))
          (erase-buffer))
        (buffer-disable-undo)
        (setq-local default-directory dir))))

  (defun gotest-ui--setup-buffer (buffer name cmdline dir)
    (setq-local default-directory dir)
    (setq gotest-ui--cmdline cmdline
          gotest-ui--dir dir)
    (let ((ewoc (ewoc-create 'gotest-ui--pp-test nil nil t))
          (tests (make-hash-table :test #'equal)))
      (setq gotest-ui--tests tests)
      (setq gotest-ui--ewoc ewoc)
      ;; Drop in the first few ewoc nodes:
      (setq gotest-ui--status (gotest-ui--make-status ewoc cmdline dir))
      (gotest-ui-add-section gotest-ui--ewoc 'fail "Failed Tests:")
      (gotest-ui-add-section gotest-ui--ewoc 'run "Currently Running:")
      (gotest-ui-add-section gotest-ui--ewoc 'skip "Skipped:")
      (gotest-ui-add-section gotest-ui--ewoc 'pass "Passed Tests:"))
    ;; Set up the other buffers:
    (setq gotest-ui--stderr-process-buffer (generate-new-buffer (format " *%s (stderr)" name)))
    (with-current-buffer gotest-ui--stderr-process-buffer
      (setq gotest-ui--ui-buffer buffer))
    (setq gotest-ui--process-buffer (generate-new-buffer (format " *%s" name)))
    (with-current-buffer gotest-ui--process-buffer
      (setq gotest-ui--ui-buffer buffer)))

  (defun gotest-ui-add-section (ewoc state name)
    (let ((section (gotest-ui-section-create :title name :tests (list nil))))
      (setf (gotest-ui-section-node section)
            (ewoc-enter-last ewoc section))
      (push (cons state section) gotest-ui--section-alist)))

  (defun gotest-ui-sort-test-into-section (test previous-state)
    (let (invalidate-nodes)
      (when-let ((previous-section* (and previous-state
                                         (assoc previous-state gotest-ui--section-alist))))
        (let ((previous-section (cdr previous-section*)))
          (setf (gotest-ui-section-tests previous-section)
                (delete test (gotest-ui-section-tests previous-section)))
          (when (null (cdr (gotest-ui-section-tests previous-section)))
            (push (gotest-ui-section-node previous-section) invalidate-nodes))))
      ;; Drop the node from the buffer:
      (when-let (node (gotest-ui-thing-node test))
        (let ((buffer-read-only nil))
          (ewoc-delete gotest-ui--ewoc node))
        (setf (gotest-ui-thing-node test) nil))

      ;; Put it in the next secion:
      (when-let ((section* (assoc (gotest-ui-thing-status test)
                                  gotest-ui--section-alist)))
        (let* ((section (cdr section*))
               (insertion-cons (gotest-ui-section-tests section)))
          (while (and (cdr insertion-cons)
                      (gotest-ui-test->= test (cadr insertion-cons)))
            (setq insertion-cons (cdr insertion-cons)))
          (rplacd insertion-cons (cons test (cdr insertion-cons)))
          (let ((insertion-node (if (car insertion-cons)
                                    (gotest-ui-thing-node (car insertion-cons))
                                  (gotest-ui-section-node section))))
            (setf (gotest-ui-thing-node test)
                  (ewoc-enter-after gotest-ui--ewoc insertion-node test)))
          (when (null (cddr (gotest-ui-section-tests section)))
            (push (gotest-ui-section-node section) invalidate-nodes))))
      (unless (null invalidate-nodes)
        (apply 'ewoc-invalidate gotest-ui--ewoc invalidate-nodes))
      (gotest-ui-thing-node test)))

  ;;;; Commands:

  (defun gotest-ui-toggle-expanded ()
    "Toggle expandedness of a test/package node"
    (interactive)
    (let* ((node (ewoc-locate gotest-ui--ewoc (point)))
           (data (ewoc-data node)))
      (when (and data (gotest-ui-thing-p data))
        (setf (gotest-ui-thing-expanded-p data)
              (not (gotest-ui-thing-expanded-p data)))
        (ewoc-invalidate gotest-ui--ewoc node))))

  (defun gotest-ui-rerun ()
    (interactive)
    (gotest-ui gotest-ui--cmdline :dir gotest-ui--dir))

  ;;;; Displaying the data:

  (defvar-local gotest-ui--tests nil)
  (defvar-local gotest-ui--section-alist nil)
  (defvar-local gotest-ui--ewoc nil)
  (defvar-local gotest-ui--status nil)
  (defvar-local gotest-ui--process-buffer nil)
  (defvar-local gotest-ui--stderr-process-buffer nil)
  (defvar-local gotest-ui--ui-buffer nil)
  (defvar-local gotest-ui--process nil)
  (defvar-local gotest-ui--stderr-process nil)
  (defvar-local gotest-ui--cmdline nil)
  (defvar-local gotest-ui--dir nil)

  (cl-defun gotest-ui (cmdline &key dir)
    (let* ((dir (or dir default-directory))
           (name (format "*go test: %s in %s" (s-join " " cmdline) dir))
           (buffer (get-buffer-create name)))
      (unless (eql buffer (current-buffer))
        (display-buffer buffer))
      (with-current-buffer buffer
        (let ((default-directory dir))
          (gotest-ui--clear-buffer buffer)
          (gotest-ui-mode)
          (gotest-ui--setup-buffer buffer name cmdline dir))
        (setq gotest-ui--stderr-process
              (make-pipe-process :name (s-concat name "(stderr)")
                                 :buffer gotest-ui--stderr-process-buffer
                                 :sentinel #'gotest-ui--stderr-process-sentinel
                                 :filter #'gotest-ui-read-stderr))
        (setq gotest-ui--process
              (make-process :name name
                            :buffer gotest-ui--process-buffer
                            :sentinel #'gotest-ui--process-sentinel
                            :filter #'gotest-ui-read-stdout
                            :stderr gotest-ui--stderr-process
                            :command cmdline)))))

  (defun gotest-ui-pp-status (status)
    (propertize (format "%s" status)
                'face
                (case status
                  (fail 'gotest-ui-fail-face)
                  (skip 'gotest-ui-skip-face)
                  (pass 'gotest-ui-pass-face)
                  (otherwise 'default))))

  (defun gotest-ui--pp-test-output (test)
    (with-current-buffer (gotest-ui-ensure-output-buffer test)
      (propertize (buffer-substring (point-min) (point-max))
                  'line-prefix "\t")))

  (defun gotest-ui--pp-test (test)
    (cond
     ((gotest-ui-section-p test)
      (unless (null (cdr (gotest-ui-section-tests test)))
        (insert "\n" (gotest-ui-section-title test) "\n")))
     ((gotest-ui-status-p test)
      (insert (gotest-ui-pp-status (gotest-ui-status-state test)))
      (insert (format " %s in %s\n\n"
                      (gotest-ui-status-cmdline test)
                      (gotest-ui-status-dir test)))
      (unless (zerop (length (gotest-ui-status-output test)))
        (insert (format "\n\n%s" (gotest-ui-status-output test)))))
     ((gotest-ui-test-p test)
      (let ((status (gotest-ui-thing-status test))
            (package (gotest-ui-test-package test))
            (name (gotest-ui-thing-name test)))
        (insert (gotest-ui-pp-status status))
        (insert " ")
        (insert (if name
                    (format "%s.%s" package name)
                  package))
        (when-let ((elapsed (gotest-ui-thing-elapsed test)))
          (insert (format " (%.3fs)" elapsed)))
        (when-let ((reason (gotest-ui-test-reason test)))
          (insert (format " [%s]" reason))))
      (when (and (gotest-ui-thing-expanded-p test)
                 (> (length (gotest-ui--pp-test-output test)) 0))
        (insert "\n")
        (insert (gotest-ui--pp-test-output test)))
      (insert "\n"))))

  ;;;; Handling input:

  (defun gotest-ui--process-sentinel (proc event)
    (let* ((process-buffer (process-buffer proc))
           (ui-buffer (with-current-buffer process-buffer gotest-ui--ui-buffer))
           (inhibit-quit t))
      (with-local-quit
        (with-current-buffer ui-buffer
          (cond
           ((string= event "finished\n")
            (gotest-ui-update-status 'pass))
           ((s-prefix-p "exited abnormally" event)
            (gotest-ui-update-status 'fail))
           (t
            (gotest-ui-update-status event)))))))

  (defun gotest-ui--stderr-process-sentinel (proc event)
    ;; ignore all events
    nil)

  (defun gotest-ui-read-stderr (proc input)
    (let* ((process-buffer (process-buffer proc))
           (ui-buffer (with-current-buffer process-buffer gotest-ui--ui-buffer))
           (inhibit-quit t))
      (with-local-quit
        (when (buffer-live-p process-buffer)
          (with-current-buffer process-buffer
            (gotest-ui-read-compiler-spew proc process-buffer ui-buffer input))))))

  (defun gotest-ui-read-stdout (proc input)
    (let* ((process-buffer (process-buffer proc))
           (ui-buffer (with-current-buffer process-buffer gotest-ui--ui-buffer))
           (inhibit-quit t))
      (with-local-quit
        (when (buffer-live-p process-buffer)
          (gotest-ui-read-json process-buffer (process-mark proc) input)))))

  (defun gotest-ui-read-json (process-buffer marker input)
    (with-current-buffer process-buffer
      (gotest-ui-read-json-1 process-buffer marker gotest-ui--ui-buffer input)))

  (defvar-local gotest-ui--current-failing-test nil)

  (defun gotest-ui-read-failing-package (ui-buffer)
    (when (looking-at "^# \\(.*\\)$")
      (let* ((package (match-string 1))
             test)
        (with-current-buffer ui-buffer
          (setq test (gotest-ui-ensure-test gotest-ui--ewoc package nil :status 'fail))
          (gotest-ui-maybe-expand test)
          (gotest-ui-sort-test-into-section test nil))
        (forward-line 1)
        test)))

  (defun gotest-ui-read-compiler-spew (proc process-buffer ui-buffer input)
    (with-current-buffer process-buffer
      (save-excursion
        (goto-char (point-max))
        (insert input)
        (goto-char (process-mark proc))
        (while (and (/= (point-max) (line-end-position)) ; incomplete line
                    (/= (point-max) (point)))
          (cond
           (gotest-ui--current-failing-test
            (cond
             ((looking-at "^# \\(.*\\)$")
              (gotest-ui-read-failing-package ui-buffer))
             (t
              (let* ((line (buffer-substring (point) (line-end-position)))
                     (test gotest-ui--current-failing-test))
                (forward-line 1)
                (set-marker (process-mark proc) (point))
                (with-current-buffer ui-buffer
                  (gotest-ui-update-thing-output test (concat line "\n"))
                  (ewoc-invalidate gotest-ui--ewoc (gotest-ui-thing-node test)))))))
           (t
            (let ((test (gotest-ui-read-failing-package ui-buffer)))
              (setq gotest-ui--current-failing-test test)
              (set-marker (process-mark proc) (point))
              (with-current-buffer ui-buffer
                (ewoc-invalidate gotest-ui--ewoc (gotest-ui-thing-node test))))))))))

  (defun gotest-ui-read-json-1 (process-buffer marker ui-buffer input)
    (with-current-buffer process-buffer
      (save-excursion
        ;; insert the chunk of output at the end
        (goto-char (point-max))
        (insert input)

        ;; try to read the next object (which is hopefully complete now):
        (let ((nodes
               (cl-loop
                for (node . continue) = (gotest-ui-read-test-event process-buffer marker ui-buffer)
                when node collect node into nodes
                while continue
                finally (return nodes))))
          (when nodes
            (with-current-buffer ui-buffer
              (apply #'ewoc-invalidate gotest-ui--ewoc
                     (cl-remove-if-not (lambda (node) (marker-buffer (ewoc-location node))) (cl-remove-duplicates nodes)))))))))

  (defun gotest-ui-read-test-event (process-buffer marker ui-buffer)
    (goto-char marker)
    (when (= (point) (line-end-position))
      (forward-line 1))
    (case (char-after (point))
      (?\{
       ;; It's JSON:
       (condition-case err
           (let ((obj (json-read)))
             (set-marker marker (point))
             (with-current-buffer ui-buffer
               (cons (gotest-ui-update-test-status obj) t)))
         (json-error (cons nil nil))
         (wrong-type-argument
          (if (and (eql (cadr err) 'characterp)
                   (eql (caddr err) :json-eof))
              ;; This is peaceful & we can ignore it:
              (cons nil nil)
            (signal 'wrong-type-argument err)))))
      (?\F
       ;; It's a compiler error:
       (when (looking-at "^FAIL\t\\(.*\\)\s+\\[\\([^]]+\\)\\]\n")
         (let* ((package-name (match-string 1))
                (reason (match-string 2))
                test node)
           (with-current-buffer ui-buffer
             (setq test (gotest-ui-ensure-test gotest-ui--ewoc package-name nil :status 'fail)
                   node (gotest-ui-thing-node test))
             (setf (gotest-ui-test-reason test) reason)
             (gotest-ui-sort-test-into-section test nil)
             (gotest-ui-maybe-expand test))
           (forward-line 1)
           (set-marker marker (point))
           (cons node t))))
      (otherwise
       ;; We're done:
       (cons nil nil))))

  (defun gotest-ui-maybe-expand (test)
    (when (memq (gotest-ui-test-status test) gotest-ui-expand-test-statuses)
      (setf (gotest-ui-test-expanded-p test) t)))

  (defun gotest-ui-update-test-status (json)
    (let-alist json
      (let* ((action (intern .Action))
             (test (gotest-ui-ensure-test gotest-ui--ewoc .Package .Test))
             (previous-status (gotest-ui-thing-status test)))
        (case action
          (run
           (gotest-ui-sort-test-into-section test nil))
          (output (gotest-ui-update-thing-output test .Output))
          (pass
           (setf (gotest-ui-thing-status test) 'pass
                 (gotest-ui-thing-elapsed test) .Elapsed)
           (gotest-ui-sort-test-into-section test previous-status)
           (gotest-ui-maybe-expand test))
          (fail
           (setf (gotest-ui-thing-status test) 'fail
                 (gotest-ui-thing-elapsed test) .Elapsed)
           (gotest-ui-sort-test-into-section test previous-status)
           (gotest-ui-maybe-expand test))
          (skip
           (setf (gotest-ui-thing-status test) 'skip
                 (gotest-ui-thing-elapsed test) .Elapsed)
           (gotest-ui-sort-test-into-section test previous-status)
           (gotest-ui-maybe-expand test))
          (otherwise
           (setq test nil)))
        (when test (gotest-ui-thing-node test)))))

  ;;;; Commands for go-mode:

  (defun gotest-ui--command-line (&rest cmdline)
    (append gotest-ui-test-binary gotest-ui-test-args gotest-ui-additional-test-args
            cmdline))

  ;;;###autoload
  (defun gotest-ui-current-test ()
    "Launch go test with the test that (point) is in."
    (interactive)
    (cl-destructuring-bind (test-suite test-name) (go-test--get-current-test-info)
      (let ((test-flag (if (> (length test-suite) 0) "-m" "-run")))
        (when test-name
          (gotest-ui (gotest-ui--command-line test-flag (s-concat test-name "$") "."))))))

  ;;;###autoload
  (defun gotest-ui-current-file ()
    "Launch go test on the current buffer file."
    (interactive)
    (let* ((data (go-test--get-current-file-testing-data))
           (run-flag (s-concat "-run=" data "$")))
      (gotest-ui (gotest-ui--command-line run-flag "."))))

  ;;;###autoload
  (defun gotest-ui-current-project ()
    "Launch go test on the current buffer's project."
    (interactive)
    (let ((default-directory (projectile-project-root)))
      (gotest-ui (gotest-ui--command-line "./..."))))

  (provide 'gotest-ui)

  ;;; gotest-ui.el ends here
#+end_src
