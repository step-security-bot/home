#+SETUPFILE: ./_setup.org
#+TITLE: Vincent Demeester's .emacs.d

#+TOC: headlines 3


* Overview
:PROPERTIES:
:CUSTOM_ID: h:64b142be-1326-479b-ab6e-e88ca298f56d
:END:
** Canonical links to this document
:PROPERTIES:
:CUSTOM_ID: h:9e025e71-b8c5-4cd3-88cc-c81f1e026d13
:END:

+ HTML version :: [[https://sbr.pm/dotemacs][sbr.pm/dotemacs]]
+ Git repo :: [[https://github.com/vdemeester/emacs-config.git][github.com/vdemeester/emacs-config]]

** What is this
:PROPERTIES:
:CUSTOM_ID: h:6cf02bfd-0266-456f-be5f-728c75e3013e
:END:

The present document, referred to in the source code version as =emacs.org=, contains the
bulk of my configurations for GNU Emacs. It is designed using principles of "literate
programming": a combination of ordinary language and inline code blocks. Emacs knows how
to parse this file properly so as to evaluate only the elisp ("Emacs Lisp") included
herein. The rest is for humans to make sense of my additions and their underlying
rationale.

#+BEGIN_QUOTE
Literate programming allows us to be more expressive and deliberate. Not only we can use
typography to its maximum potential, but can also employ techniques such as internal links
between sections. This makes the end product much better for end users, than a terse
script.
#+END_QUOTE

I switched back and forth on using =org-mode= and literate programming, so why re-using
it. First, I think I went for it the wrong way the first time. I copied part of the
configuration from elsewhere, sometimes without really needing what I was copying. for
some reason I think this is a common pattern when configuring Emacs. You start by using a
distribution (Doom Emacs, Spacemacs, …) or by copying configuration from all over the
place. Slowly but surely you realize this was a mistake as you didn't learn anything, so
you *reboot* your configuration.

I'm taking [[https://protesilaos.com/][Protesilaos Stavrou]] approach on writing and configuring this file (see [[https://protesilaos.com/dotemacs/][his
dotemacs]]), although I am not loading it directly. I prefer using the [[https://orgmode.org/manual/tangle.html][tangle]] feature of
=org-mode= instead of loading it using ~org-babel~ function. This allows me to document my
configuration and generating final(s) ~.el~ files. Those files can then load and/or
pre-compile, without the need to load =org= first. It also means that I can add code
pieces in there that won't be /tangle/, like usage example ; and I also can use this to
generate any additional file I need, whatever the programming language they are written
in.

** Why using GNU/Emacs ?
:PROPERTIES:
:CUSTOM_ID: h:165fca5a-b87d-4140-963b-658a2438e769
:END:

This is a question I thought I needed to answer, or at least, document why I am choosing
GNU/Emacs as my primary editor. [[https://protesilaos.com/][Protesilaos Stavrou]] has a [[https://protesilaos.com/codelog/2019-12-20-vlog-switch-emacs/][video]] about it, really
interesting.

There is a lot of reasons but for me, the following are the main ones:
- *Open Source*: this is a "of course", but my editor _has to be_ open-sourced. This seems
  to be the norm these days anyway (and for a long time, with =vim=).
- *Lightweight*: the editor should be relatively lightweight. I don't want a full browser
  loaded to edit files, and I want to be able to run it in a terminal, on a server. =vim=
  can do that (and sometimes, =vim= or =vi= is enough 👼).
- *Extensible*: to be honest, this is the most important reason. I want to be able to
  extend my editor as much as possible.

GNU/Emacs checks all the boxes for me. Even though GNU/Emacs is probably not as
lightweight as =vim=, it is definitely lightweight compared to all the Electron-based
editors (vscode, …). It is of course open-source, and since ages (almost as old as I am
😅). And best of all, GNU/Emacs is extensible as you couldn't dream of. Emacs is a lisp
interpreter, and it is designed to be extended in order to meet the user's
needs. /Extensibility/ is the quintessential Emacs quality. You can modify any piece of
elisp /in real time/.

I'm also a huge fan of /text-based/ software, a.k.a. do whatever you can using text :
reading mails, news, organizing notes and todos, all can be done in text. And GNU/Emacs
shines at this. For emails and news, you've got Gnus built-in, for notes and todos, the
wonderful =org-mode= is the best thing on earth (seriously, this is the *one* mode that
made me switch from =vim=).

** Assumptions
:PROPERTIES:
:CUSTOM_ID: h:657c38cd-d910-42c2-bd8c-8c20171a8bd5
:END:

I'll make a few assumption in the following document (that may or may not be true):

- [[https://nixos.org/nix/][~nix~]] is available, either from [[https://nixos.org][NixOS]] or via an install of nix. I'll try my best to
  support non-nix environment, but it's definitely not my current focus.
  + As I am making the assumption that ~nix~ is available, I am also making the assumption
    that all the library required are already present (in my [[https://github.com/vdemeester/home][~home~]], there is a file
    called [[https://github.com/vdemeester/home/blob/master/modules/profiles/emacs.nix][~emacs.nix~]] that encapsulate those dependencies). This is why, by default
    *use-package* doesn't use the =ensure= option in 99% of the configuration.
- Any function I wrote is going to be prefixed by ~vde/~ so that it doesn't conflicts with
  function that would have been defined elsewhere.

As it is detailed in each part of this configuration, I am trying to setup keybinding in a
/mnemonics/ way so it's easy to remember (and use). This is what [[https://www.spacemacs.org/][spacemacs]] does with evil
keybindings (aka vim-like keybindings). I am staying with the /standard/ emacs keybinding
as much as possible (as there is already some mnemonics in there).

There are countless jokes and comics on Emacs’s seemingly ridiculous keybindings. Good
laughs indeed, but at the end of day, it’s not incomprehensible. It has well-defined
conventions listed at [[https://www.gnu.org/software/emacs/manual/html%5Fnode/elisp/Key-Binding-Conventions.html][Emacs Key Bindings Convention]]. In summary, the general rules are:

+ =C-x= reserved for Emacs native essential keybindings: buffer, window, frame, file, directory, etc…
+ =C-c= reserved for user and major mode:
  - =C-c letter= reserved for user. =<F5>=-=<F9>= reserved for user.
  - =C-c C-letter= reserved for major mode.
+ Don’t rebind =C-g=, =C-h= and =ESC=.

To give a small example, most of my personal =org-mode= keybinding will start with =C-c
o=, as it is reserved for user, and =o= is for =org-mode=. For version control, it's gonna
be =C-c v=, for projects it's gonna be =C-c p=, etc…

** COPYING
:PROPERTIES:
:CUSTOM_ID: h:d4cfb344-dcff-4144-951a-8197c5ae2c84
:END:

Copyright (c) 2013-2020 Vincent Demeester <vincent@sbr.pm>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

* TODO Base settings
:PROPERTIES:
:CUSTOM_ID: h:e483cc48-eb2d-42a7-93ca-3e1a37fa6a7c
:END:

This section contains configurations that are needed prior to the setup of everything
else. Anything that needs to be configured first should be in there, this includes the
~init.el~ and ~early-init.el~ files content.

** Initiazing emacs
:PROPERTIES:
:CUSTOM_ID: h:4886d661-e2e0-4a75-bf3f-e85aef27b50c
:END:

Starting with Emacs 27, an =early-init.el= file can be used to do early configuration
and optimization.

#+begin_quote
Emacs can now be configured using an early init file. The file is called ~early-init.el~,
in ~user-emacs-directory~. It is loaded very early in the startup process: before
graphical elements such as the tool bar are initialized, and before the package manager is
initialized. The primary purpose is to allow customizing how the package system is
initialized given that initialization now happens before loading the regular init file
(see below).

We recommend against putting any customizations in this file that don't need to be set up
before initializing installed add-on packages, because the early init file is read too
early into the startup process, and some important parts of the Emacs session, such as
'window-system' and other GUI features, are not yet set up, which could make some
customization fail to work.
#+end_quote

We can use this to our advantage and optimize the initial loading of emacs.

- Before Emacs 27, the init file was responsible for initializing the package manager by
  calling `package-initialize'.  Emacs 27 changed the default behavior: It now calls
  `package-initialize' before loading the init file.

  #+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
  #+end_src

- Let's inhibit resizing the frame at early stage.

  #+begin_src emacs-lisp :tangle early-init.el
  (setq frame-inhibit-implied-resize t)
  #+end_src

- I never use the /menu-bar/, or the /tool-bar/ or even the /scroll-bar/, so we can safely
  disable those very very early.

  #+begin_src emacs-lisp :tangle early-init.el
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  #+end_src

- Finally we can try to avoid garbage collection at startup. The garbage collector can
  easily double startup time, so we suppress it at startup by turning up ~gc-cons-threshold~
  (and perhaps ~gc-cons-percentage~) temporarily.

  #+begin_src emacs-lisp :tangle early-init.el
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)
  #+end_src

- Another small optimization concerns on =file-name-handler-alist= : on every .el and .elc
  file loaded during start up, it has to runs those regexps against the filename ; setting
  it to ~nil~ and after initialization finished put the value back make the initialization
  process quicker.

  #+begin_src emacs-lisp :tangle early-init.el
  (defvar file-name-handler-alist-original file-name-handler-alist)
  (setq file-name-handler-alist nil)
  #+end_src

  However, it is important to reset it eventually. Not doing so will cause garbage
  collection freezes during long-term interactive use. Conversely, a ~gc-cons-threshold~
  that is too small will cause stuttering.

  #+begin_src emacs-lisp :tangle early-init.el
  (add-hook 'after-init-hook
            `(lambda ()
               (setq gc-cons-threshold 16777216 ; 16mb
                     gc-cons-percentage 0.1
                     file-name-handler-alist file-name-handler-alist-original)
               (garbage-collect)) t)
  #+end_src

One thing though, I am currently not necessarily running Emacs 27, so I am going to need
to have the same configuration in ~init.el~ for a little bit of time.

/Note: the lowest emacs version I wanna support is 26 (as of today, might evolve)/

#+begin_src emacs-lisp :tangle init.el
;;; -*- lexical-binding: t; -*-
(let ((minver 26))
  (unless (>= emacs-major-version minver)
    (error "Your Emacs is too old -- this configuration requires v%s or higher" minver)))

(defconst emacs-start-time (current-time))

;; load early-init.el before Emacs 27.0
(unless (featurep 'early-init)
  (message "Early init: Emacs Version < 27.0")
  (load (expand-file-name "early-init.el" user-emacs-directory)))
#+end_src

We also want our configuration to be working the same on any computer, this means we want
to define every option by ourselves, not relying on default files (~default.el~) that
would be set by our distribution. This is where =inhibit-default-init= comes into play,
setting it to non-nil inhibit loading the ~default~ library.

#+begin_src emacs-lisp :tangle init.el
(setq inhibit-default-init t)           ; Disable the site default settings
#+end_src

We also want to inhibit some initial default start messages and screen. The default screen
will be as bare as possible.

#+begin_src emacs-lisp :tangle init.el
(setq inhibit-startup-message t
      inhibit-startup-screen t)
#+end_src

One last piece to the puzzle is the default mode. Setting it to fundamental-mode means we
won't load any /heavy/ mode at startup (like =org-mode=). We also want this scratch buffer
to be empty, so let's set it as well

#+begin_src emacs-lisp :tangle init.el
(setq initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
#+end_src

*** Unicode all the way
:PROPERTIES:
:CUSTOM_ID: h:df45a01a-177d-4909-9ce7-a5423e0ea20f
:END:

By default, all my systems are configured and support =utf-8=, so let's just make it a
default in Emacs ; and handle special case on demand.

#+begin_src emacs-lisp :tangle init.el
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-language-environment 'utf-8)
(set-selection-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
#+end_src

*** Package management with =use-package=
:PROPERTIES:
:CUSTOM_ID: h:112262a1-dd4d-4a50-a9e2-85b36bbbd95b
:END:

=use-package= is a tool that streamlines the configuration of packages. It handles
everything from assigning key bindings, setting the value of customisation options,
writing hooks, declaring a package as a dependency for another, and so on.

#+begin_quote
The =use-package= macro allows you to isolate package configuration in your =.emacs= file
in a way that is both performance-oriented and, well, tidy.  I created it because I have
over 80 packages that I use in Emacs, and things were getting difficult to manage.  Yet
with this utility my total load time is around 2 seconds, with no loss of functionality!
#+end_quote

With =use-package= we can improve the start-up performance of Emacs in a few fairly simple
ways. Whenever a command is bound to a key it is configured to be loaded only once
invoked. Otherwise we can specify which functions should be autoloaded by means of the
=:commands= keyword.

We need to setup the emacs package system and install =use-package= if not present
already.

#+begin_src emacs-lisp :tangle init.el
;;; package setup
(require 'package)

(setq package-archives
      '(("melpa" . "http://melpa.org/packages/")
        ("org" . "https://orgmode.org/elpa/")
        ("gnu" . "https://elpa.gnu.org/packages/")))

(setq package-archive-priorities
      '(("melpa" .  3)
        ("org" . 2)
        ("gnu" . 1)))

(require 'tls)

;; From https://github.com/hlissner/doom-emacs/blob/5dacbb7cb1c6ac246a9ccd15e6c4290def67757c/core/core-packages.el#L102
(setq gnutls-verify-error (not (getenv "INSECURE")) ; you shouldn't use this
      tls-checktrust gnutls-verify-error
      tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"
                        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof"))

;; Initialise the packages, avoiding a re-initialisation.
(unless (bound-and-true-p package--initialized)
  (setq package-enable-at-startup nil)
  (package-initialize))

(setq load-prefer-newer t)              ; Always load newer compiled files
(setq ad-redefinition-action 'accept)   ; Silence advice redefinition warnings

;; Init `delight'
(unless (package-installed-p 'delight)
  (package-refresh-contents)
  (package-install 'delight))

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t))

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+end_src

*** =custom.el=
:PROPERTIES:
:CUSTOM_ID: h:1ddaf27e-ff7c-424e-8615-dd0bd22b685f
:END:

When you install a package or use the various customisation interfaces to tweak things to
your liking, Emacs will append a piece of elisp to your init file. I prefer to have that
stored in a separate file.

#+begin_src emacs-lisp :tangle init.el
(defconst vde/custom-file (locate-user-emacs-file "custom.el")
  "File used to store settings from Customization UI.")

(use-package cus-edit
  :config
  (setq
   custom-file vde/custom-file
   custom-buffer-done-kill nil          ; Kill when existing
   custom-buffer-verbose-help nil       ; Remove redundant help text
   custom-unlispify-tag-names nil       ; Show me the real variable name
   custom-unlispify-menu-entries nil)
  (unless (file-exists-p custom-file)
    (write-region "" nil custom-file))

  (load vde/custom-file 'no-error 'no-message))
#+end_src

*** Loading configuration files
:PROPERTIES:
:CUSTOM_ID: h:d6aebc56-aadb-4b01-8404-bb922d12f8a8
:END:

This =org-mode= document /tangles/ into several files in different folders :
- ~config~ for my configuration
- ~lisp~ for imported code or library I've written and not yet published

I used to load them by hand in the ~init.el~ file, which is very cumbersome, so let's try
to automatically load them. I want to first load the file in the ~lisp~ folder as they are
potentially used by my configuration (in ~config~).

Let's define some functions that would do the job.

#+begin_src emacs-lisp :tangle init.el
(defun vde/el-load-dir (dir)
    "Load el files from the given folder"
    (let ((files (directory-files dir nil "\.el$")))
      (while files
        (load-file (concat dir (pop files))))))
#+end_src

Now, in order to load ~lisp~ and ~config~ files, it's just a matter of calling this
function with the right argument.

#+begin_src emacs-lisp :tangle init.el
(vde/el-load-dir (concat user-emacs-directory "/lisp/"))
(vde/el-load-dir (concat user-emacs-directory "/config/"))
#+end_src

Finally, I want to be able to load files for a specific machine, in case I need it (not
entirely sure why yet but…)

#+begin_src emacs-lisp :tangle init.el
(defun vde/short-hostname ()
  "Return hostname in short (aka wakasu.local -> wakasu)"
  (string-match "[0-9A-Za-z-]+" system-name)
  (substring system-name (match-beginning 0) (match-end 0)))

(if (file-exists-p (downcase (concat user-emacs-directory "/hosts/" (vde/short-hostname) ".el")))
    (load-file (downcase (concat user-emacs-directory "/hosts/" (vde/short-hostname) ".el"))))
#+end_src

** ~PATH~'s customization
:PROPERTIES:
:header-args: :tangle config/00-paths.el
:CUSTOM_ID: h:2a72b00e-ea97-4a3b-a70c-cbbe648df428
:END:

To make sure my emacs instance and my user environment setup is always /similar/, I use
=exec-path-from-shell=.

#+begin_quote
Ever find that a command works in your shell, but not in Emacs?

This happens a lot on OS X, where an Emacs instance started from the GUI inherits a
default set of environment variables.

This library solves this problem by copying important environment variables from the
user's shell: it works by asking your shell to print out the variables of interest, then
copying them into the Emacs environment.
#+end_quote

#+begin_src emacs-lisp
(use-package exec-path-from-shell       ; Set up environment variables
  :if (display-graphic-p)
  :unless (eq system-type 'windows-nt)
  :config
  (setq exec-path-from-shell-variables
        '("PATH"               ; Full path
          "INFOPATH"           ; Info directories
          "GOPATH"             ; Golang path
          ))
  (exec-path-from-shell-initialize))
#+end_src

** Keep emacs clean
:PROPERTIES:
:header-args: :tangle config/00-clean.el
:CUSTOM_ID: h:8a9d7d0d-0900-4261-a9e3-923a0afc1324
:END:

I want to keep the =~/.emacs.d= folder as clean as possible. The [[https://github.com/emacscollective/no-littering][no-littering]] project
helps wit that.

#+begin_quote
The default paths used to store configuration files and persistent data are not consistent
across Emacs packages. This isn't just a problem with third-party packages but even with
built-in packages.

Some packages put these files directly in user-emacs-directory or $HOME or in a
subdirectory of either of the two or elsewhere. Furthermore sometimes file names are used
that don't provide any insight into what package might have created them.

This package sets out to fix this by changing the values of path variables to put
configuration files in no-littering-etc-directory (defaulting to ~/.emacs.d/etc/) and
persistent data files in no-littering-var-directory (defaulting to ~/.emacs.d/var/), and
by using descriptive file names and subdirectories when appropriate. This is similar to a
color-theme; a "path-theme" if you will.
#+end_quote

Let's configure it *and* make sure we load it as soon as possible (hence the
=config/00-clean.el=).

As I am loading =recentf= during this cleanup part, I need to setup recentf before 😅. In
a gist:

- I keep about 200 items.
- I don't want the /auto-cleanup/ of recentf items to happen when the mode is loaded (a.k.a.
  at startup). It is configured to run after 360s of idle time.
- I don't really want to show the Nth number of the items.
- I don't want recentf to save remote, =su= and =sudo= items (=ssh:=, =sudo:=, …)

#+begin_src emacs-lisp
(use-package recentf
  :config
  (setq recentf-max-saved-items 200
        recentf-auto-cleanup 360
        recentf-show-file-shortcuts-flag nil)
  (recentf-mode 1)
  (add-to-list 'recentf-exclude "^/\\(?:ssh\\|su\\|sudo\\)?:")
  ;; Magic advice to rename entries in recentf when moving files in
  ;; dired.
  (defun rjs/recentf-rename-notify (oldname newname &rest args)
    (if (file-directory-p newname)
        (rjs/recentf-rename-directory oldname newname)
      (rjs/recentf-rename-file oldname newname)))

  (defun rjs/recentf-rename-file (oldname newname)
    (setq recentf-list
          (mapcar (lambda (name)
                    (if (string-equal name oldname)
                        newname
                      oldname))
                  recentf-list))
    recentf-cleanup)

  (defun rjs/recentf-rename-directory (oldname newname)
    ;; oldname, newname and all entries of recentf-list should already
    ;; be absolute and normalised so I think this can just test whether
    ;; oldname is a prefix of the element.
    (setq recentf-list
          (mapcar (lambda (name)
                    (if (string-prefix-p oldname name)
                        (concat newname (substring name (length oldname)))
                      name))
                  recentf-list))
    recentf-cleanup)

  (advice-add 'dired-rename-file :after #'rjs/recentf-rename-notify))

(use-package no-littering               ; Keep .emacs.d clean
  :config
  (require 'recentf)
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude no-littering-etc-directory)

  ;; Move this in its own thing
  (setq
   create-lockfiles nil
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)

  (setq
   backup-directory-alist
   `((".*" . ,(no-littering-expand-var-file-name "backup/")))
   auto-save-file-name-transforms
   `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src


** Server mode
:PROPERTIES:
:header-args: :tangle config/01-server.el
:CUSTOM_ID: h:51ffd089-63c6-4ba6-8cc5-4c888521ef3a
:END:

My current setup involves a =emacs --daemon= systemd service. We want to start the server
if it's not already running, so that =emacsclient= can connect to it.

#+begin_src emacs-lisp
(use-package server
  :config (or (server-running-p) (server-mode)))
#+end_src

* TODO Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: h:4323a022-5419-48f7-acf9-7af94e43eddf
:END:

* TODO Directory, buffer and window management
:PROPERTIES:
:CUSTOM_ID: h:88c7f450-bb9d-41f6-a8f9-3082a32d3179
:END:

* Applications and utilities
:PROPERTIES:
:CUSTOM_ID: h:8219f8ae-d4a8-4b9d-9a4a-3e457d69751e
:END:

This section includes configurations for programs like email clients, messages, knowledge
database and other /applications/ that runs in Emacs. Most of those should be the "killer
apps" of the Emacs ecosystem.

** TODO Org-mode (personal information manager)
:PROPERTIES:
:header-args: :tangle config/setup-org.el
:CUSTOM_ID: h:c8fd2624-6c91-4b89-9645-4261ca85d584
:END:

I am an heavy user of [[https://orgmode.org/][=org-mode=]]. This is most likely *the one* mode that made me switch
back to GNU/Emacs years back.

#+begin_quote
Org mode is for keeping notes, maintaining TODO lists, planning projects, and authoring
documents with a fast and effective plain-text system.
#+end_quote

I'm going to quote [[https://protesilaos.com/dotemacs/#h:4e8347de-415e-4804-b383-d61499e05ca1][Protesilaos Stavrou]] too as he describe it way better than I would do.

#+begin_quote
 Org offers you the basic tools to organise your life in super-efficient ways using
 nothing but plain text.

In its purest form, Org is a markup language that is similar to Markdown: symbols are used
to denote the meaning of a construct in its context, such as what may represent a headline
element or a phrase that calls for emphasis.

What lends Org its super powers though is everything else built around it: a rich corpus
of elisp functions that automate, link, combine, enhance, structure, or otherwise enrich
the process of using this otherwise simple markup language. This very document is written
in org-mode while its website version is produced by a function that exports Org notation
into its HTML equivalent.
#+end_quote

I am using =org-mode= for managing my tasks and partly my daily agenda, for /journaling/,
knowledge database (taking notes on stuff) and publishing documents (right now mainly on
[[https://sbr.pm][sbr.pm]]). I have been using =org-mode= for a while now, I feel some of my configuration may
be heavily /tailored/ to my needs.

The /base/ user keybinding for =org-mode= (and related modes) is =C-c o= (e.g. showing
agenda is =C-c o a=, capture is =C-c o c=, …).

*** Base settings                                                  :ATTACH:
:PROPERTIES:
:CUSTOM_ID: h:9287c076-1944-4c13-b4e4-c7cbc6587358
:ID:       1f74bbae-c4a1-4723-977e-e48900fcd1c7
:Attachments: 2020-02-29-13-46-08.png
:END:

First, let's define some basic constants, mainly on how my main =org= folder is organized.

#+begin_src emacs-lisp
(defconst org-directory "~/desktop/org/" "org-mode directory, where most of the org-mode file lives")
(defconst org-default-projects-dir (concat org-directory "projects") "Primary tasks directory.")
(defconst org-default-technical-dir (concat org-directory "technical") "Directory of shareable, technical notes.")
(defconst org-default-personal-dir (concat org-directory "personal") "Directory of un-shareable, personal notes.")
(defconst org-default-completed-dir (concat org-directory "archive/projects") "Directory of completed project files.")
(defconst org-default-inbox-file (concat org-directory "projects/inbox.org") "New stuff collected in this file.")
(defconst org-default-next-file (concat org-directory "projects/next.org") "Todo *next* collected in this file.")
(defconst org-default-incubate-file (concat org-directory "projects/incubate.org") "Ideas simmering on back burner.")
(defconst org-default-notes-file (concat org-directory "personal/notes.org") "Non-actionable, personal notes.")
(defconst org-default-journal-file (concat org-directory "personal/journal.org") "Journaling stuff.")
#+end_src

In a nutshell, I am currently trying the following organization, with =~/desktop/org/= as
the base of almost all =org-mode= things:

+ =projects= is the main /TODO/ folder. It holds todos and current projects along with ideas.
  - =inbox.org= is my inbox, where most of my captured todo, ideas and link will be store,
    waiting for reviews.
  - =incubate.org= is where I store my ideas that could become projects at some point. It
    is also waiting for reviews (once a week more or less).
  - =next.org= is where simple todos are stored, quick one shot /things/ that do not need
    a project to be created.
  - ={project}.org= are files that holds a project information and todos. It can be
    /long-lived/ projects (like =redhat.org= or =tekton.org=) or, prefered, /short-lived/
    projects, like =rework-infra.org= or =tekton-beta.org=. Once a project is marked as
    done or completed, it either goes into the =archive=, or into =technical= ; if it can
    be published.
+ =technical= is the public / to-be-published documents and /public/ knowledge base. It can holds todos, but its main
  purpose is to be publish, at [[https://sbr.pm][sbr.pm]]. Thus, it's organization is the same as the
  website.
+ =personal= is my private knowledge base. Those are private information or notes that I
  don't want to publish *and* might be encrypted (using =gnupg=).
+ =archive= holds all archived files (projects, todos from =projects= files, …)

Additionnaly, I may have =org-mode= files and /todos/ in other files, like in my
=~/.emacs.d= folder or my [[https://github.com/vdemeester/home][=home=]] configuration.

I want a way to quickly jump to certain =org-mode= files, like =next.org= or the
=inbox.org=. For this, we can use the emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Registers.html][registers]] and more accurately the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/File-Registers.html#File-Registers][file
registers]].

#+begin_src emacs-lisp
(set-register ?i `(file . ,org-default-inbox-file))
(set-register ?I `(file . ,org-default-incubate-file))
(set-register ?N `(file . ,org-default-next-file))
(set-register ?n `(file . ,org-default-notes-file))
(set-register ?j `(file . ,org-default-journal-file))
#+end_src

With this, I can jump to the inbox with ~C-x r j i~, to the journal using ~C-x r j j~, …

Let's setup the base of =org-mode=, with the following things in mind:

- Agenda :: =org-agenda-files= contains =~/desktop/org/=, =~/.emacs.d/= and
  =~/.config/nixpkgs/=. The rest of the configuration will happen when configuring
  =org-agenda=.
- Navigation and key bindings ::
  + As said before, =C-c o= is the prefix of my user specific keybindings
    - =C-c o l= is to store the link (default keybinding is =C-c C-l=)
    - =C-c o r r= is to refile a task from an org-mode buffer (default keybinding is =C-c
      C-w=, and there is a different keybinding when in an org-mode agenda buffer)
  + Activating [[https://orgmode.org/manual/Speed-Keys.html][/speed commands/]], aka being able to use one keystroke to do some action (like
    changing the TODO state, …)
  + =C-a=, =C-e= and =C-k= should be =org-mode= aware. This is achieved by setting
    =org-special-ctrl-a/e= and =org-special-ctrl-k= to =t=.
- To-do settings :: My current setup of /todo-keywords/ (a.k.a. =org-todo-keywords=) might
  be more complicated that it should be but I've been using it a while
  now. =org-todo-keywords= is a list of sequences, I have three:
  + =TODO= → =NEXT= → =STARTED= → =DONE= /or/ =CANCELED=
  + =WAITING= → =SOMEDAY= → move to a =TODO= or =CANCELED=
  + =IDEA= → move to a =TODO= or =CANCELED=

  I am leaning towards simplifying this, especially as =NEXT= is not really useful (I have
  =next.org= for this), and =IDEA= or =WAITING= are not really used either (=IDEA= goes
  into =incubate.org= and I don't seem to use =WAITING=).

  /I need to update and document =org-todo-state-tags-triggers= too/
- Tags :: I am using generic tags and some groups. Groups allow to define mutually
  exclusive tags, like =@home= and =@work= (can't be both). This is achieve by using
  =:startgroup= and =:endgroup= in the =org-tag-alist= variable. It is also possible to
  define [[https://orgmode.org/manual/Tag-Hierarchy.html#Tag-Hierarchy][tag hierarchies]] but I didn't look into it yet.

  I also want to have tag inheritance, aka children entry inherits their parent's tag —
  even though it may have a cost (search, …), it allows to reduce lots of /duplications/.
- Refile :: In the =org-mode= jargon, this means moving an entry from one heading (parent
  entry) to another. This move can be done across files. =org-mode= displays a list of
  choice, this list is controlled by the =org-refile-targets= variable.

  The =org-refile-targets= is pretty powerful if you read the doc. You specify a list of
  file and some /search/ options for org to build its list from. Those options can be the
  level of the entry, some tag, regular expression, … In my case, I want this list to be
  all the =org= file in the =project= folder and also the =inbox.org= file. For the inbox,
  I want to look only at level 0 (aka root), for the other, I want to look at level 1 (aka
  root and sub entries).

  I also changed the default way to show the refile targets (=level1/level2/level3=) to
  include the file name. When refiling, you can either do the completion hierarchically
  (select the file, then the first level, …) or you can display all the choice at once. I
  tend to prefer having all the choice at once and let my completion framework (=ivy= as
  of now) to do the /fuzzy/ selection.

  Finally, I want to be able to create new node if I want, while refiling, so I'm setting
  =org-refile-allow-creating-parent-nodes= to =confirm=, to ask me if I am sure 👼.
- User Interface ::
  + I want, by default, to display the effort and clock summary on org columns, so I am
    setting the =org-columns-default-format= to do that.

    [[att:2020-02-29-13-46-08.png]]

  + I want to /fontify/ the whole header line (it tends to look better for some theme)
  + I want things /pretty/, hence the =org-pretty-entities= 😹
  + When a entry (or a drawer) is closed, I like having a visual cue that it is. I chose
    the =…= character to show that. It can be set with =org-ellipsis=.
- Logging :: =org-mode= allows to write the time (or a note) on a entry state change, this
  is achieved by the =org-log-*= variables. On marking entries as =DONE= or when
  rescheduling them (or changing the deadline), I want to mark the time.

  Additionally, when I log those state changes, I don't want them to pollute the content
  of the to-do (aka description, …). Setting =org-log-int-drawer= will insert those logs
  in a =LOGBOOK= drawer (same as the property drawer).
- Archiving :: I don't want to pollute my current folder with =_archive= files, so I am
  redefining =org-archive-location= to archive to my =org-default-completed-dir=, also
  using =datetree= to put archived items in a datetree.
- Miscellaneous ::
  + I am setting up =org-use-property-inheritance= to make children node inherit their
    parent property. It has a cost on search but I feel, as for tag inheritance, it is
    worth the cost.
  + Still on properties, =org-global-properties= allows you to add values to properties
    that will show in the completion when setting those. For example, setting =EFFORT_ALL=
    to a list, will give you those options when you are trying to set the effort property.
  + I am setting =org-enforce-todo-dependencies= to make sure a parent entry cannot be
    mark as done if children are not in complete state (=DONE=, =CANCELLED=, …).
  + I want to add a new blank line whenever I create a new entry *but* I don't want that
    extra new blank line when adding a new list item. =org-blank-before-new-entry= allow
    to customize that behavior.

/The =ensure org-plus-contrib= is there to make sure I am loading the =org= module from my
nix configuration and not the built-in =org= module (that might lag in terms of version)/

#+begin_src emacs-lisp
(use-package s)
(use-package org
  :ensure org-plus-contrib ;; load from the package instead of internal
  :mode (("\\.org$" . org-mode))
  :config
  (setq org-agenda-files `(,org-default-projects-dir
                           ,user-emacs-directory
                           "~/.config/nixpkgs")
        org-agenda-file-regexp "^[a-zA-Z0-9-_]+.org$"
        org-use-speed-commands t
        org-special-ctrl-a/e t
        org-special-ctrl-k t
        org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "STARTED(s)" "|" "DONE(d!)" "CANCELED(c@/!)")
                            (sequence "WAITING(w@/!)" "SOMEDAY(s)" "|" "CANCELED(c@/!)")
                            (sequence "IDEA(i)" "|" "CANCELED(c@/!)"))
        org-todo-state-tags-triggers '(("CANCELLED" ("CANCELLED" . t))
                                       ("WAITING" ("WAITING" . t))
                                       (done ("WAITING"))
                                       ("TODO" ("WAITING") ("CANCELLED"))
                                       ("NEXT" ("WAITING") ("CANCELLED"))
                                       ("DONE" ("WAITING") ("CANCELLED")))
        org-use-tag-inheritance t
        org-tag-alist '(("linux") ("nixos") ("emacs") ("org")
                        ("openshift") ("redhat") ("tektoncd") ("kubernetes") ("knative" ) ("docker")
                        ("docs") ("code") ("review")
                        (:startgroup . nil)
                        ("@home" . ?h) ("@work" . ?w) ("@errand" . ?e) ("@health" . ?l)
                        (:endgroup . nil)
                        (:startgroup . nil)
                        ("@link" . ?i) ("@read" . ?r) ("@project" . ?p)
                        (:endgroup . nil))
        org-log-done 'time
        org-log-redeadline 'time
        org-log-reschedule 'time
        org-log-into-drawer t
        org-enforce-todo-dependencies t
        org-refile-targets (append '((org-default-inbox-file :level . 0))
                                   (->>
                                    (directory-files org-default-projects-dir nil ".org")
                                    (--remove (s-starts-with? "." it))
                                    (--map (format "%s/%s" org-default-projects-dir it))
                                    (--map `(,it :level . 1))))
        org-refile-use-outline-path 'file
        org-refile-allow-creating-parent-nodes 'confirm
        org-outline-path-complete-in-steps nil
        org-columns-default-format "%80ITEM(Task) %TODO %3PRIORITY %10Effort(Effort){:} %10CLOCKSUM"
        org-fontify-whole-heading-line t
        org-pretty-entities t
        org-ellipsis " …"
        org-archive-location (concat org-default-completed-dir "/%s::datetree/")
        org-use-property-inheritance t
        org-global-properties (quote (("EFFORT_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                      ("STYLE_ALL" . "habit")))
        org-blank-before-new-entry '((heading . t)
                                     (plain-list-item . nil))
        org-insert-heading-respect-content t
        org-yank-adjusted-subtrees t)
  (setcar (nthcdr 4 org-emphasis-regexp-components) 10)
  :bind (("C-c o l" . org-store-link)
         ("C-c o r r" . org-refile))
  :hook (org-mode . vde/org-mode-hook))
#+end_src

I've set-up an =org-mode= hook to add few modes to the default setup.
- I am really annoyed by trailing white-space so I want them to be shown
- If the major mod is not =org-agenda-mode= (a sub-mode of =org-mode=)
  + I set the =fill-column= to ~90~ (instead of the usual ~80~), and I enable =auto-fill= mode.
  + I turn on =auto-revert-mode= so that the buffer is always up-to-date.
  + I really like =smartparens= when programming, and I find it also really useful when
    editing notes in =org-mode=.
  + I like to have header indented, so I'm enabling =org-indent-mode=.
  + And of course, I want =flyspell= to be enable so I quickly see my /writing/ mistakes.

#+begin_src emacs-lisp
(defun vde/org-mode-hook ()
  "Org-mode hook"
  (setq show-trailing-whitespace t)
  (when (not (eq major-mode 'org-agenda-mode))
    (setq fill-column 90)
    (auto-revert-mode)
    (auto-fill-mode)
    (flyspell-mode)
    (org-indent-mode)
    (smartparens-mode)))
#+end_src

Let's also use =org-id=…

#+begin_src emacs-lisp
(use-package org-id
  :after (org)
  :config
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (defun eos/org-custom-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker POM.
   If POM is nil, refer to the entry at point. If the entry does
   not have an CUSTOM_ID, the function returns nil. However, when
   CREATE is non nil, create a CUSTOM_ID if none is present
   already. PREFIX will be passed through to `org-id-new'. In any
   case, the CUSTOM_ID of the entry is returned."
    (interactive)
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
          id)))))

  (defun eos/org-add-ids-to-headlines-in-file ()
    "Add CUSTOM_ID properties to all headlines in the
   current file which do not already have one."
    (interactive)
    (org-map-entries (lambda ()
                       (eos/org-custom-id-get (point) 'create)))))
#+end_src

… and =org-crypt= (for encrypted =org-mode= files).

#+begin_src emacs-lisp
(use-package org-crypt
  :after (org)
  :config
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance '("crypt")))
#+end_src

*** TODO Agenda
:PROPERTIES:
:CUSTOM_ID: h:ba2a773a-88d1-4df9-a98c-5e547ee50691
:END:

The =org-mode= agenda is *the* source of my day-to-day organization. This is how I know
what I have to do that, what I can do. This is also where I log my work (see /Clocking/
below).

#+begin_quote
Due to the way Org works, TODO items, time-stamped items, and tagged headlines can be
scattered throughout a file or even a number of files.  To get an overview of open action
items, or of events that are important for a particular date, this information must be
collected, sorted and displayed in an organized way.
#+end_quote

#+begin_src emacs-lisp
(use-package org-agenda
  :after (org)
  :commands (org-agenda)
  :config
  (setq org-agenda-span 'day
        org-agenda-include-diary t
        org-agenda-window-setup 'current-window
        org-agenda-skip-scheduled-if-done nil
        org-agenda-compact-blocks t
        org-agenda-sticky t)
  :commands (org-agenda)
  :bind (("C-c o a" . org-agenda)
         ("<f12>" . org-agenda)
         ("C-c o r a" . org-agenda-refile)))
#+end_src

*** Habits                                                         :ATTACH:
:PROPERTIES:
:CUSTOM_ID: h:291bae2c-f3eb-4c2a-9415-606afa28ac86
:ID:       17a3ed73-aaca-4a18-8ed1-3efe7bac855a
:Attachments: 2020-02-29-14-41-59.png
:END:

Org has the ability to track the consistency of a special category of
TODO, called /habits/.

#+begin_quote
What’s really useful about habits is that they are displayed along
with a consistency graph, to show how consistent you’ve been at getting
that task done in the past.  This graph shows every day that the task
was done over the past three weeks, with colors for each day.  The
colors used are:

Blue
     If the task was not to be done yet on that day.
Green
     If the task could have been done on that day.
Yellow
     If the task was going to be overdue the next day.
Red
     If the task was overdue on that day.
#+end_quote

This look as followed in the agenda.

[[att:2020-02-29-14-41-59.png]]

#+begin_src emacs-lisp
(use-package org-habit
  :after (org)
  :config
  (setq org-habit-show-habits-only-for-today nil
        org-habit-graph-column 80))
#+end_src

*** TODO Sources
:PROPERTIES:
:CUSTOM_ID: h:82c3b800-9d80-408d-b3b6-54dc15b0590c
:END:

#+begin_src emacs-lisp
(use-package org-src
  :after (org)
  :config
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'split-window-right
        org-edit-src-content-indentation 0))
#+end_src

*** TODO Capture
:PROPERTIES:
:CUSTOM_ID: h:b29abe71-6e9a-4ddf-8519-453170212777
:END:

#+begin_src emacs-lisp
(use-package org-capture
  :after org
  :commands (org-capture)
  :bind (("C-c o c" . org-capture)))
#+end_src

#+begin_src emacs-lisp
(use-package org-protocol
  :after org)
#+end_src

*** TODO Clocking
:PROPERTIES:
:CUSTOM_ID: h:264afe05-79e3-4bff-aafc-9fc726c4034b
:END:

#+begin_src emacs-lisp
(use-package org-clock
  :after org
  :commands (org-clock-in org-clock-out org-clock-goto)
  :bind (("<f11>" . org-clock-goto)))
#+end_src

*** TODO Links
:PROPERTIES:
:CUSTOM_ID: h:afc81fbb-f7a0-401c-8b56-19f51edebd88
:END:

#+begin_src emacs-lisp
(use-package org-attach
  :config
  (setq org-link-abbrev-alist '(("att" . org-attach-expand-link))))
#+end_src


#+begin_src emacs-lisp
(use-package ol-eshell
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ol-git-link
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ol-gnus
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ol-irc
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ol-info
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ol-man
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ol-notmuch
  :after (org))
#+end_src

*** TODO Litterate programming
:PROPERTIES:
:CUSTOM_ID: h:b5f6beba-6195-4ff0-a194-502ac2a9e3da
:END:

#+begin_src emacs-lisp
(use-package ob-async
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ob-go
  :after (org))
#+end_src

#+begin_src emacs-lisp
(use-package ob-http
  :after (org))
#+end_src


*** TODO Exporting
:PROPERTIES:
:CUSTOM_ID: h:afad00e0-367c-4c7b-b191-e3ed72be754b
:END:

#+begin_src emacs-lisp
(defconst site-directory "~/desktop/sites/" "website folder that holds exported org-mode files and more.")
(defconst org-default-publish-technical (concat site-directory "sbr.pm/technical") "publish directory for the technical org-mode files.")
#+end_src

#+begin_src emacs-lisp
(use-package ox-publish
  :after (org ox)
  :config
  (setq org-html-coding-system 'utf-8-unix))
(use-package ox-slack
  :after ox)
(use-package ox-hugo
  :after ox
  :commands (org-hugo-slug)
  :bind (:map vde-mode-map
              ("C-c G" . org-hugo-export-wim-to-md))
  :config
  (use-package ox-hugo-auto-export))
#+end_src


** TODO Email and newsgroup
:PROPERTIES:
:header-args: :tangle config/setup-mails.el
:CUSTOM_ID: h:afa562d5-b07e-413b-8c1d-2d489fb72900
:END:

I have been back and forth on using email inside Emacs, from ~mu4e~ to ~notmuch~. In the
past I have used Thunderbird, and for a while now, I have been only using webmail UI for
emails (and mobile apps of course). I recently re-discover [[https://www.gnus.org/][Gnus]] as a mail reader, so my
current setup is the following:

- [[https://www.gnus.org/][Gnus]], the Emacs built-in newsreader and email client.
- ~notmuch~ to be able to browse my mail backups (using ~isync~, …), see [[https://sbr.pm/technical/mail-setup.html][here]] for the
  current setup.

One of the main reason to rely on [[https://www.gnus.org/][Gnus]] instead of ~notmuch~ for the mails, is that I don't
need to worry about some complex mechanism for syncing, storing and indexing email. I
still use ~notmuch~ with ~isync~ to backup my mails somewhere, with the possibility to
search them.

*** Base email settings
:PROPERTIES:
:CUSTOM_ID: h:765191a3-81cb-4e6e-9360-6a42b2a55b0f
:END:

Before configuring any email client, we need to establish some essentials: who we are,
where our credentials are stored and whether encryption is supported.

#+begin_src emacs-lisp
(use-package auth-source
  :config
  (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo"))
  (setq user-full-name "Vincent Demeester")
  (setq user-mail-address "vincent@sbr.pm"))

(use-package epa-file
  :config
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)
  :init
  (epa-file-enable))
#+end_src


*** Gnus
:PROPERTIES:
:CUSTOM_ID: h:0aeec7d8-b6c9-4244-8c10-2788c6e89cc5
:END:

The documentation describes Gnus as the /"coffee-brewing, all singing, all dancing,
kitchen sink newsreader"/. It is massive, which means the learning curve is more or less
similar to =org-mode=. You need to go slowly, starting simple and enhance your workflow
and configuration along the way.

Now some basic information on the abstractions that Gnus relies on:

1. The default Gnus buffer is called "Group".  It will present you with a list of all the
   news sources you have subscribed to.  By default, Gnus only displays messages that have
   not been read.  The same applies for groups.  The "Group" buffer will be empty the very
   first time you log in because you have not subscribed to anything yet.  Use =g= to
   fetch new messages from the sources.  If you only want to refresh the group at point,
   do it with =M-g=.
2. The "Server" buffer contains a list with all the sources you have specified for
   discovering news.  In my case, these are my email accounts and a Usenet server where
   mailing lists are hosted.  To access the "Server" buffer from inside the "Group"
   buffer, just hit the caret sign =^=.  To subscribe to an item, place the point over it
   and hit =u=.  Do that for your email's inbox and for whatever mailing lists you intend
   to follow.
3. The "Summary" buffer contains all the messages of a group.  Hitting the return key over
   a message will split the view in two, with the list above and the message below.  Use
   =n= or =p= to move to the next or previous unread message (or =N= and =P= to just the
   next/prev).  You access the "Summary" buffer both from the "Group" and the "Server" by
   entering a group.

As noted, Gnus will only show you a list of unread items. To view all your groups, hit
=L=. Use the lower case version =l= to view only the unread ones. To produce a Summary
buffer with read items, hit =C-u RET= over a group and specify the number of messages you
want to list (the other option is =C-u M-g= from inside the Summary). Another useful trick
for the Summary buffer is the use of the caret sign (=^=) to show you the previous message
that the current item is a reply to.

**** Account settings
:PROPERTIES:
:CUSTOM_ID: h:be7bbb5b-4b13-49f0-8044-b79363ccba7f
:END:

Let's first configure the essentials of Gnus.

The =gnus-select-method= sets the default method for fetching news items. As I want to
read mail from several accounts in addition to following Usenet sources, I choose to set
it to nil.

The =gnus-secondary-select-methods= is where my accounts are specified. Each =nnimap= list
points to a specific line in my =authinfo.gpg= file. My emails all use the same server so
this method allows me to specify the username (email) and password combination for each of
them /without/ making this information public.  I am not sure whether the =nnimap-stream=
and =nnimap-authinfo-file= are needed, but I keep them for the sake of completeness.

- [[http://www.cataclysmicmutation.com/2010/11/multiple-gmail-accounts-in-gnus/][Multiple GMail Accounts in Gnus - Cataclysmic Mutation]]
- [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org][mastering-emacs-in-one-year-guide/gnus-guide-en.org at master · redguardtoo/mastering-emacs-in-one-year-guide]]

#+begin_src emacs-lisp
(use-package gnus
  :config
  (setq nnml-directory "~/desktop/gnus/mail")
  (setq nnfolder-directory "~/desktop/gnus/archive")
  (setq nndraft-directory "~/desktop/gnus/drafts")
  (setq nnmh-directory "~/desktop/gnus/drafts")
  (setq gnus-article-save-directory "~/desktop/gnus/news")
  (setq gnus-home-directory "~/desktop/gnus")
  (setq gnus-kill-files-directory "~/desktop/gnus/news")
  (setq gnus-cache-directory "~/desktop/gnus/news/cache")
  (setq gnus-startup-file "~/desktop/gnus/newsrc")
  (setq mail-source-directory "~/desktop/gnus/mail")
  (setq gnus-registry-cache-file "~/desktop/gnus/gnus.registry.eld")
  (setq gnus-select-method '(nnnil))
  (setq nntp-authinfo-file "~/.authinfo.gpg")
  (setq gnus-secondary-select-methods
        '((nntp "news.gwene.org")
          (nnimap "prv"
                  (nnimap-address "mail.gandi.net")
                  (nnimap-stream ssl)
                  (nnimap-authinfo-file "~/.authinfo.gpg"))
          (nnimap "redhat"
                  (nnimap-address "imap.gmail.com")
                  (nnimap-stream ssl)
                  (nnimap-authinfo-file "~/.authinfo.gpg"))
          (nnimap "vde"
                  (nnimap-address "imap.gmail.com")
                  (nnimap-stream ssl)
                  (nnimap-authinfo-file "~/.authinfo.gpg"))
          ))
  (setq gnus-parameters
        '(("prv"
           (posting-style
            (address "vincent@demeester.fr")
            (signature-file "~/desktop/documents/.prv.signature")
            (gcc "nnimap+prv:Sent")))
          ("redhat"
           (posting-style
            (address "vdemeest@redhat.com")
            (signature-file "~/desktop/documents/.redhat.signature")
            (gcc "nnimap+redhat:[Gmail]/Sent Mail")))
          ("nnimap+redhat:INBOX"
           (display . all))
          ("vde"
           (posting-style
            (address "vinc.demeester.fr")
            (signature-file "~/desktop/documents/.vde.signature")
            (gcc "nnimap+vde:[Gmail]/Sent Mail")))
          ("nnimap+vde:INBOX"
           (display . all))))
  (setq gnus-agent t)
  (setq mail-user-agent 'gnus-user-agent) ; also works with `sendmail-user-agent'
  (setq gnus-check-new-newsgroups 'ask-server)
  (setq gnus-read-active-file 'some)
  (setq gnus-use-dribble-file t)
  (setq gnus-always-read-dribble-file t)
  (setq gnus-novice-user nil)
  (setq gnus-extra-headers
        '(To Newsgroups X-GM-LABELS)))
#+end_src

**** Gnus agent
:PROPERTIES:
:CUSTOM_ID: h:2beac436-62ba-4b52-acc5-559016ec477f
:END:

Gnus has something call the "agent", which represent the bridge between Gnus and the
server it connects to. Gnus is said to be "plugged" when a connection is established,
otherwise it is "unplugged".

Technicalities aside, we basically use this to save a local copy of the items we have
already fetched from the server.  We can also use the agent to configure the handling of
local messages.  For example, we can set an expiry date, after which the message is
deleted, or we can create a queue of outgoing messages when Gnus is in an unplugged state.

#+begin_src emacs-lisp
(use-package gnus-agent
  :after gnus
  :config
  (setq gnus-agent-article-alist-save-format 1)  ; uncompressed
  (setq gnus-agent-cache t)
  (setq gnus-agent-confirmation-function 'y-or-n-p)
  (setq gnus-agent-consider-all-articles nil)
  (setq gnus-agent-directory "~/desktop/gnus/agent/")
  (setq gnus-agent-enable-expiration 'ENABLE)
  (setq gnus-agent-expire-all nil)
  (setq gnus-agent-expire-days 30)
  (setq gnus-agent-mark-unread-after-downloaded t)
  (setq gnus-agent-queue-mail t)        ; queue if unplugged
  (setq gnus-agent-synchronize-flags nil))
#+end_src

**** Gnus asynchronous operations
:PROPERTIES:
:CUSTOM_ID: h:c089372e-4aeb-4daf-96d5-77a997ff2dd0
:END:

By default, Gnus performs all its actions in a synchronous fashion. This means that Emacs
is blocked until Gnus has finished. By enabling this library, we can use certain functions
in a non-blocking way. I do this for [[#h:8cd8c972-ba38-40c2-b30f-68a4233593d6][sending email]].

#+begin_src emacs-lisp
(use-package gnus-async
  :after gnus
  :config
  (setq gnus-asynchronous t)
  (setq gnus-use-article-prefetch 30))
#+end_src

**** Gnus group
:PROPERTIES:
:CUSTOM_ID: h:4e52ab94-4e54-41df-a43e-db0c8d23a55a
:END:

Let's dig a bit more into groups :

+ A group can be assigned a level of importance.  This is a grade whose highest score is 1
  and the lowest is 6 (customisable though). Each level has a different colour. To assign
  a new value to the group at point, do it with =S l= and then give it a number.  Once you
  have graded your groups, you can perform various actions on a per-level basis.  For
  example, to refresh all levels from 1 up to 3 but not higher, pass a numeric argument to
  the standard =g= command. So =C-3 g= (this is the same as =C-u 3 g=).
+ Groups can be organised by topic. Create a new one with =T n= and give it a name.  Move
  a group to a topic with =T m=. To toggle the view of topics use =t= (I have a hook that
  does this automatically at startup). The level of indentation tells us whether a topic
  is a sub-set of another.  Use =TAB= or =C-u TAB= to adjust it accordingly. As with
  levels, you can operate on a per-topic basis. For example, to catch up on all the news
  of a given topic (mark all as read), you place the point over it, hit =c= and then
  confirm your choice.

Note that =gnus-group-sort-functions= requires the most important function to be declared
last.

#+begin_src emacs-lisp
(use-package gnus-group
  :after gnus
  :config
  (setq gnus-level-subscribed 6)
  (setq gnus-level-unsubscribed 7)
  (setq gnus-level-zombie 8)
  (setq gnus-group-sort-function
        '((gnus-group-sort-by-unread)
          (gnus-group-sort-by-alphabet)
          (gnus-group-sort-by-rank)))
  (setq gnus-group-mode-line-format "Gnus: %%b")
  :hook
  (gnus-select-group-hook . gnus-group-set-timestamp)
  :bind (:map gnus-agent-group-mode-map
              ("M-n" . gnus-topic-goto-next-topic)
              ("M-p" . gnus-topic-goto-previous-topic)))

(use-package gnus-topic
  :after (gnus gnus-group)
  :config
  (setq gnus-topic-display-empty-topics t)
  :hook
  (gnus-group-mode . gnus-topic-mode))
#+end_src

**** Gnus Summary
:PROPERTIES:
:CUSTOM_ID: h:dfe4a692-1f0f-44c7-8d72-a1488e4ef80b
:END:

Threads should not be hidden, while messages whose root has been removed should be grouped
together in some meaningful way. Furthermore, when moving up or down in the list of
messages using just =n= or =p=, I want to go to the next message, regardless of whether it
has been read or not.  I can otherwise rely on standard Emacs motions.

The formatting of the threads using Unicode characters was taken from the [[https://www.emacswiki.org/emacs/GnusFormatting][relevant Emacs
wiki entry]] plus some minor tweaks by me.

The =gnus-user-date-format-alist=, this basically adapts the date to whether the message
was within the day or the one before, else falls back to a default value. It is then
called with =%&user-date;=.

#+begin_src emacs-lisp
(use-package gnus-sum
  :after (gnus gnus-group)
  :demand
  :config
  (setq gnus-auto-select-first nil)
  (setq gnus-summary-ignore-duplicates t)
  (setq gnus-suppress-duplicates t)
  (setq gnus-summary-goto-unread nil)
  (setq gnus-summary-make-false-root 'adopt)
  (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)
  (setq gnus-thread-sort-functions
        '((not gnus-thread-sort-by-number)
          (not gnus-thread-sort-by-date)))
  (setq gnus-subthread-sort-functions
        'gnus-thread-sort-by-date)
  (setq gnus-thread-hide-subtree nil)
  (setq gnus-thread-ignore-subject t)
  (setq gnus-user-date-format-alist
        '(((gnus-seconds-today) . "Today at %R")
          ((+ 86400 (gnus-seconds-today)) . "Yesterday, %R")
          (t . "%Y-%m-%d %R")))
  (setq gnus-summary-line-format "%U%R%z %-16,16&user-date;  %4L:%-30,30f  %B%S\n")
  (setq gnus-summary-mode-line-format "Gnus: %p (%U)")
  (setq gnus-sum-thread-tree-false-root "")
  (setq gnus-sum-thread-tree-indent " ")
  (setq gnus-sum-thread-tree-leaf-with-other "├─➤ ")
  (setq gnus-sum-thread-tree-root "")
  (setq gnus-sum-thread-tree-single-leaf "└─➤ ")
  (setq gnus-sum-thread-tree-vertical "│")
  :hook
  (gnus-summary-exit-hook . gnus-topic-sort-groups-by-alphabet)
  (gnus-summary-exit-hook . gnus-group-sort-groups-by-rank)
  :bind (:map gnus-agent-summary-mode-map
              ("<delete>" . gnus-summary-delete-article)
              ("n" . gnus-summary-next-article)
              ("p" . gnus-summary-prev-article)
              ("N" . gnus-summary-next-unread-article)
              ("P" . gnus-summary-prev-unread-article)
              ("M-n" . gnus-summary-next-thread)
              ("M-p" . gnus-summary-prev-thread)
              ("C-M-n" . gnus-summary-next-group)
              ("C-M-p" . gnus-summary-prev-group)
              ("C-M-^" . gnus-summary-refer-thread)))
#+end_src

Gnus summary displays a mark for each messages, those `O`, `!`, … Let's first describe
what are those marks (from the [[https://www.gnu.org/software/emacs/manual/html_node/gnus/Marking-Articles.html#Marking-Articles][documentation]]) and which one make the more sense for me.
Most of those marks can be set using the =M= prefix (or =M M=) from the Summary buffer.

First there is two groups of /marks/ : *unread* and *read*. Note they do not entirely map
to what IMAP defines or what you would see in another mail UI (webmail, …).

+ *unread*: those will appear by default on a Summary buffer (almost 😜)
  - =<SPC>= are the /standard/ unread, never read. Once a mail is read you can mark it back as
    unread with =M M u u=.
  - =!= is for /ticked/. This is similar to the *starred* thread/message on GMail (or
    Thunderbird, … — in ~notmuch~ it appears as =flagged=). Those will always appear in
    the summary, so this is mainly for really important message to be remembered all the
    time.
  - =?= is for /dormant/. This is similar to /ticked/ *but* the article will only appear
    if there is a follow-up of the message. This would be a good use of "waiting for an
    answer so keep it".
+ *read*: those will not appear by default on a Summary buffer
  - =r= and =R= are /just read/ (like in the /reading session/) more or less
  - =O= is /read/ in an older session
  - =Y= is for /too low of a score/, this means this message got automatically read
    because it had low score (/more on that later/).
  - =E= is for /marked as expirable/, so that Gnus can delete/expunge them (or do
    something else — /more on that later/).
  - =M= is for /duplicated/.
  - =K=, =X= are for /killed/, =C= is for /catchup/ =Q= is for /sparsely reffed article/
    and =G= is for cancelled — not sure what this means yet…

**** Gnus intersection with Dired
:PROPERTIES:
:CUSTOM_ID: h:35901f1a-4a24-46a8-bc8f-a334cd156f2b
:END:

We can use the built-in directory editor (file manager) as a more convenient way of
performing certain tasks that relate to emails, such as attaching all the marked items of
the =dired= buffer to an email we are currently composing or wish to initiate the
composition of.

Run =C-h m= inside of a Dired buffer that has =gnus-dired-mode= enabled and search for
"gnus" to see all the relevant key bindings and the functions they call. I only ever use
=C-c C-m C-a= (=C-m= is the same as =RET=).

#+begin_src emacs-lisp
(use-package gnus-dired
  :after (gnus dired)
  :hook (dired-mode . gnus-dired-mode))
#+end_src

**** TODO Searching mails
:PROPERTIES:
:CUSTOM_ID: h:8288c9b3-cfe2-4599-a55b-9b2b1c71f524
:END:

**** TODO Subscribing to RSS
:PROPERTIES:
:CUSTOM_ID: h:259bbc05-4ea6-43b7-bfef-0036434a86f8
:END:

*** TODO ~notmuch~ configuration
:PROPERTIES:
:CUSTOM_ID: h:b67b377e-0fbc-4237-857c-641cdf2de1cf
:END:

*** TODO Sending mails
:PROPERTIES:
:CUSTOM_ID: h:8cd8c972-ba38-40c2-b30f-68a4233593d6
:END:

#+begin_src emacs-lisp
(use-package smtpmail
  :config
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq sendmail-program "msmtp")
  (setq message-sendmail-f-is-evil 't)
  (setq message-sendmail-extra-arguments '("--read-envelope-from")))
#+end_src


* TODO Programming
:PROPERTIES:
:CUSTOM_ID: h:635a27c4-5ff9-46e4-8d42-283d316cf4d6
:END:
* Legacy
:PROPERTIES:
:CUSTOM_ID: h:9e392a26-fe69-4156-910f-fb1911fd8924
:END:

This holds legacy code from the previous configuration (without org-mode). This will
slowly but surely move into an org-mode header and or disappear.

** Configurations
:PROPERTIES:
:CUSTOM_ID: h:2227a24c-90e4-4544-bbf0-c123122e3b39
:END:

These are the initial configuration files to be imported in this file slowly but surely.

*** ~init.el~
:PROPERTIES:
:CUSTOM_ID: h:443b5480-2b61-4653-afa2-3c8da9169353
:END:

#+begin_src emacs-lisp :tangle init.el
(setenv "PAGER" "cat")
(setenv "TERM" "xterm-256color")
(setenv "NOTMUCH_CONFIG" (expand-file-name ".config/notmuch/notmuchrc" (getenv "HOME")))

(use-package pinentry
  :config
  (setenv "INSIDE_EMACS" (format "%s,comint" emacs-version))
  (pinentry-start))

;; Confirm before quitting Emacs
(setq confirm-kill-emacs #'y-or-n-p)

;; C-up/down onn console
(when (not window-system)
  (define-key function-key-map "\eO1;5A"    [C-up])
  (define-key function-key-map "\eO1;5B"  [C-down])
  (define-key function-key-map "\eO1;5C" [C-right])
  (define-key function-key-map "\eO1;5D"  [C-left])
  )

(let ((elapsed (float-time (time-subtract (current-time)
                                          emacs-start-time))))
  (message "Loading %s...done (%.3fs)" load-file-name elapsed))

(add-hook 'after-init-hook
          `(lambda ()
             (let ((elapsed
                    (float-time
                     (time-subtract (current-time) emacs-start-time))))
               (message "Loading %s...done (%.3fs) [after-init]"
                        ,load-file-name elapsed))) t)

(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-region 'disabled nil)

(put 'magit-diff-edit-hunk-commit 'disabled nil)
;; Local Variables:
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:
;;; Finalization
;;; init.el ends here
#+end_src

*** ~setup-browser.el~
:PROPERTIES:
:CUSTOM_ID: h:271aa865-f85d-4e6e-9283-4a2fb457328a
:END:

#+begin_src emacs-lisp :tangle config/setup-browser.el
;;; -*- lexical-binding: t; -*-
(use-package shr
  :commands (eww
             eww-browse-url)
  :custom
  (shr-use-fonts nil)
  (shr-use-colors nil)
  (shr-max-image-proportion 0.2)
  (shr-width (current-fill-column)))

(use-package shr-tag-pre-highlight
  :after shr
  :config
  (add-to-list 'shr-external-rendering-functions
               '(pre . shr-tag-pre-highlight))
  (when (version< emacs-version "26")
    (with-eval-after-load 'eww
      (advice-add 'eww-display-html :around
                  'eww-display-html--override-shr-external-rendering-functions))))

(use-package eww
  :defer t
  :init
  (setq browse-url-browser-function
        '((".*google.*maps.*" . browse-url-generic)
          ;; Github goes to firefox, but not gist
          ("http.*\/\/github.com" . browse-url-generic)
          ("http.*\/\/github.io" . browse-url-generic)
          ("http.*\/\/gitlab.com" . browse-url-generic)
          ("http.*\/\/gitlab.io" . browse-url-generic)
          ("groups.google.com" . browse-url-generic)
          ("docs.google.com" . browse-url-generic)
          ("melpa.org" . browse-url-generic)
          ("build.*\.elastic.co" . browse-url-generic)
          (".*-ci\.elastic.co" . browse-url-generic)
          ("internal-ci\.elastic\.co" . browse-url-generic)
          ("zendesk\.com" . browse-url-generic)
          ("salesforce\.com" . browse-url-generic)
          ("stackoverflow\.com" . browse-url-generic)
          ("apache\.org\/jira" . browse-url-generic)
          ("thepoachedegg\.net" . browse-url-generic)
          ("zoom.us" . browse-url-generic)
          ("blujeans.com" . browse-url-generic)
          ("t.co" . browse-url-generic)
          ("twitter.com" . browse-url-generic)
          ("\/\/a.co" . browse-url-generic)
          ("youtube.com" . browse-url-generic)
          ("amazon.com" . browse-url-generic)
          ("slideshare.net" . browse-url-generic)
          ("." . browse-url-generic)))
  (setq shr-external-browser 'browse-url-generic)
  (setq browse-url-generic-program (executable-find "firefox"))
  (add-hook 'eww-mode-hook #'toggle-word-wrap)
  (add-hook 'eww-mode-hook #'visual-line-mode)
  :config
  (define-key eww-mode-map "o" 'eww)
  (define-key eww-mode-map "O" 'eww-browse-with-external-browser))

(provide 'setup-browser)
#+end_src

*** ~setup-buffers.el~
:PROPERTIES:
:CUSTOM_ID: h:98200f45-7379-42e7-be0d-7db52cd950c8
:END:

#+begin_src emacs-lisp :tangle config/setup-buffers.el
;;; -*- lexical-binding: t; -*-
;; Don't let the cursor go into minibuffer prompt
(let ((default (eval (car (get 'minibuffer-prompt-properties 'standard-value))))
      (dont-touch-prompt-prop '(cursor-intangible t)))
  (setq minibuffer-prompt-properties
        (append default dont-touch-prompt-prop))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))

;; Allow to read from minibuffer while in minibuffer.
(setq enable-recursive-minibuffers t)

;; Show the minibuffer depth (when larger than 1)
(minibuffer-depth-indicate-mode 1)

(use-package savehist                   ; Save minibuffer history
  :init (savehist-mode t)
  :custom
  (history-length 1000)
  (savehist-save-minibuffer-history t)
  (savehist-autosave-interval 180)
  :config
  (savehist-mode 1))

(use-package emacs
  :init
  ;; Configure `display-buffer' behaviour for some special buffers
  (setq display-buffer-alist
        '(;; bottom side window
          ("\\*e?shell.*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . -1))
          ("\\*v?term.*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . -1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|[Hh]elp\\|Messages\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . 0))
          ("\\*\\(helpful\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . 0))
          ("\\*\\(compilation\\|go test\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . 0))
          ("\\*\\(ielm\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . 1))
          ;; right side window
          ("\\*wclock*"
           (display-buffer-in-side-window)
           (window-width . 0.20)
           (side . right)
           (slot . -1))
          ("\\*undo-tree*"
           (display-buffer-in-side-window)
           (window-width . 0.20)
           (side . right)
           (slot . -1))
          ("\\*\\(Flycheck\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-width . 0.20)
           (side . right)
           (slot . 0)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . (" "
                                                      mode-line-buffer-identification)))))
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-width . 0.20)
           (side . right)
           (slot . 1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . (" "
                                                      mode-line-buffer-identification)))))
          ("\\*Custom.*"
           (display-buffer-in-side-window)
           (window-width . 0.20)
           (side . right)
           (slot . 2))))
  (setq window-sides-vertical nil)
  (setq window-combination-resize t) ; Size new windows proportionally
  :bind (("C-x +" . balance-windows-area)
         ("<f7>" . window-toggle-side-windows)))

(use-package uniquify                   ; Unique buffer names
  :custom
  (uniquify-buffer-name-style 'post-forward)
  (uniquify-separator ":")
  (uniquify-ignore-buffers-re "^\\*")
  (uniquify-after-kill-buffer-p t))

(use-package ibuf-ext                   ; Extensions for Ibuffer
  :config
  ;; Do not show empty groups
  (setq ibuffer-show-empty-filter-groups nil))

(use-package ibuffer                    ; Buffer management
  :custom
  (ibuffer-expert t)
  (ibuffer-filter-group-name-face 'font-lock-doc-face)
  (ibuffer-default-sorting-mode 'filename/process)
  (ibuffer-use-header-line t)
  :bind (("C-x C-b" . ibuffer)
         ([remap list-buffers] . ibuffer))
  :config
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size)))))

  (setq ibuffer-formats
        '((mark modified read-only " "
                (name 18 18 :left :elide)
                " "
                (size-h 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                filename-and-process)
          (mark modified read-only " "
                (name 18 18 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                (vc-status 16 16 :left)
                " "
                filename-and-process))))

(use-package ibuffer-vc                 ; Group buffers by VC project and status
  :defer 2
  :init (add-hook 'ibuffer-hook
                  (lambda ()
                    (ibuffer-vc-set-filter-groups-by-vc-root)
                    (unless (eq ibuffer-sorting-mode 'filename/process)
                      (ibuffer-do-sort-by-filename/process)))))

(provide 'setup-buffers)
#+end_src

*** ~setup-compile.el~
:PROPERTIES:
:CUSTOM_ID: h:c5d92923-4c37-44d6-9adf-a5911e950f7e
:END:

#+begin_src emacs-lisp :tangle config/setup-compile.el
;;; -*- lexical-binding: t; -*-
(use-package compile
  :defer 2
  :config
  (progn
    ;; http://stackoverflow.com/a/13408008/1219634
    (setq
     compilation-scroll-output t
     ;; I'm not scared of saving everything.
     compilation-ask-about-save nil
     ;; Automatically scroll and jump to the first error
     compilation-scroll-output 'next-error
     ;; compilation-scroll-output 'first-error
     ;; compilation-auto-jump-to-first-error t
     ;; Skip over warnings and info messages in compilation
     compilation-skip-threshold 2
     ;; Don't freeze when process reads from stdin
     compilation-disable-input t
     ;; Show three lines of context around the current message
     compilation-context-lines 3)
    (require 'ansi-color)
    (defun vde/colorize-compilation-buffer ()
      (unless (or (derived-mode-p 'grep-mode) ;Don't mess up colors in Grep/Ag results buffers
                  (derived-mode-p 'ag-mode))
        (ansi-color-apply-on-region compilation-filter-start (point))))
    (add-hook 'compilation-filter-hook #'vde/colorize-compilation-buffer)

    (defun vde/mark-compilation-window-as-dedicated ()
      "Setup the *compilation* window with custom settings."
      (when (string-prefix-p "*compilation: " (buffer-name))
        (save-selected-window
          (save-excursion
            (let* ((w (get-buffer-window (buffer-name))))
              (when w
                (select-window w)
                (switch-to-buffer (buffer-name))
                (set-window-dedicated-p w t)))))))
    (add-hook 'compilation-mode-hook 'vde/mark-compilation-window-as-dedicated)))

(use-package flycheck
  :if (not (eq system-type 'windows-nt))
  :defer 4
  :commands (flycheck-mode
             flycheck-next-error
             flycheck-previous-error)
  :init
  (dolist (where '((emacs-lisp-mode-hook . emacs-lisp-mode-map)
                   (haskell-mode-hook    . haskell-mode-map)
                   (js2-mode-hook        . js2-mode-map)
                   (go-mode-hook         . go-mode-map)
                   (c-mode-common-hook   . c-mode-base-map)))
    (add-hook (car where)
              `(lambda ()
                 (bind-key "M-n" #'flycheck-next-error ,(cdr where))
                 (bind-key "M-p" #'flycheck-previous-error ,(cdr where)))
              t))
  :config
  (add-hook 'prog-mode-hook 'flycheck-mode)
  (defalias 'show-error-at-point-soon
    'flycheck-show-error-at-point)
  (setq flycheck-idle-change-delay 1.2))

(provide 'setup-compile)
#+end_src

*** ~setup-completion.el~
:PROPERTIES:
:CUSTOM_ID: h:5d87a504-6cba-4cc4-a694-ce46756d2fe6
:END:

#+begin_src emacs-lisp :tangle config/setup-completion.el
;;; -*- lexical-binding: t; -*-
(use-package ivy
  :delight
  :custom
  (ivy-count-format "%d/%d ")
  (ivy-height-alist '((t lambda (_caller) (/ (window-height) 4))))
  (ivy-use-virtual-buffers t)
  (ivy-virtual-abbreviate 'full) ;Show the full virtual file paths
  (ivy-wrap nil)
  (ivy-re-builders-alist
   '((counsel-M-x . ivy--regex-fuzzy)
     (t . ivy--regex-plus)))
  (ivy-display-style 'fancy)
  (ivy-use-selectable-prompt t)
  (ivy-fixed-height-minibuffer nil)
  (ivy-extra-directories nil) ; Default value: ("../" "./")
  :bind (:map vde-mode-map
              ("C-x b" . vde/switch-buffer)
              ("C-x B" . ivy-switch-buffer)
              ("M-u" . ivy-resume)    ;Override the default binding for `upcase-word'
              ("C-c C-w p" . ivy-push-view) ;Push window configuration to `ivy-views'
              ("C-c C-w P" . ivy-pop-view)  ;Remove window configuration from `ivy-views'
              ("C-c C-w s" . ivy-switch-view) ; Switch window configuration to `ivy-views'
              :map ivy-occur-mode-map
              ("f" . forward-char)
              ("b" . backward-char)
              ("n" . ivy-occur-next-line)
              ("p" . ivy-occur-previous-line)
              ("<C-return>" . ivy-occur-press))
  :init
  (progn
    (bind-to-vde-map "v" #'counsel-set-variable))
  :hook
  (ivy-occur-mode . hl-line-mode)
  :config
  (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur)
  (ivy-set-occur 'swiper 'swiper-occur)
  (ivy-set-occur 'swiper-isearch 'swiper-occur)
  (ivy-mode 1)
  (progn
    (defun vde/switch-buffer (arg)
      "Custom switch to buffer.
With universal argument ARG or when not in project, rely on
`ivy-switch-buffer'.
Otherwise, use `counsel-projectile-switch-project'."
      (interactive "P")
      (if (or arg
              (not (projectile-project-p)))
          (ivy-switch-buffer)
        (counsel-projectile-switch-to-buffer)))
    ;; Disable ido
    (with-eval-after-load 'ido
      (ido-mode -1)
      ;; Enable ivy
      (ivy-mode 1))
    ))

(use-package ivy-hydra                  ; Additional bindings for Ivy
  :after ivy)

(use-package ivy-rich
  :after ivy
  :custom
  (ivy-virtual-abbreviate 'full
                          ivy-rich-switch-buffer-align-virtual-buffer t
                          ivy-rich-path-style 'abbrev)
  :config (ivy-rich-mode 1))

(use-package prescient
  :custom
  (prescient-history-length 50)
  ;; (prescient-save-file "~/.emacs.d/prescient-items")
  (prescient-filter-method '(fuzzy initialism regexp))
  :config
  (prescient-persist-mode 1))

;;; Default rg arguments
;; https://github.com/BurntSushi/ripgrep
(defconst vde/rg-arguments
  `("--no-ignore-vcs"                   ;Ignore files/dirs ONLY from `.ignore'
    "--line-number"                     ;Line numbers
    "--smart-case"
    "--max-columns" "150"      ;Emacs doesn't handle long line lengths very well
    "--ignore-file" ,(expand-file-name ".ignore" (getenv "HOME")))
  "Default rg arguments used in the functions in `counsel' and `projectile' packages.")

(use-package ivy-prescient
  :after (prescient ivy)
  :custom
  (ivy-prescient-sort-commands
   '(:not swiper ivy-switch-buffer counsel-switch-buffer))
  (ivy-prescient-retain-classic-highlighting t)
  (ivy-prescient-enable-filtering t)
  (ivy-prescient-enable-sorting t)
  :config
  (defun prot/ivy-prescient-filters (str)
    "Specify an exception for `prescient-filter-method'.

This new rule can be used to tailor the results of individual
Ivy-powered commands, using `ivy-prescient-re-builder'."
    (let ((prescient-filter-method '(literal regexp)))
      (ivy-prescient-re-builder str)))

  (setq ivy-re-builders-alist
        '((counsel-rg . prot/ivy-prescient-filters)
          (counsel-grep . prot/ivy-prescient-filters)
          (counsel-yank-pop . prot/ivy-prescient-filters)
          (swiper . prot/ivy-prescient-filters)
          (swiper-isearch . prot/ivy-prescient-filters)
          (swiper-all . prot/ivy-prescient-filters)
          (t . ivy-prescient-re-builder)))
  (ivy-prescient-mode 1))

(use-package counsel
  :after ivy
  :custom
  (counsel-yank-pop-preselect-last t)
  (counsel-yank-pop-separator "\n—————————\n")
  (counsel-describe-function-function 'helpful-function)
  (counsel-describe-variable-function 'helpful-variable)
  (counsel-find-file-at-point t)
  (counsel-find-file-ignore-regexp
   ;; Note that `ivy-extra-directories' should also not contain the "../" and
   ;; "./" elements if you don't want to see those in the `counsel-find-file'
   ;; completion list.
   (concat
    ;; file names beginning with # or .
    "\\(?:\\`[#.]\\)"
    ;; file names ending with # or ~
    "\\|\\(?:[#~]\\'\\)"))
  :bind (:map vde-mode-map
              ("M-i" . counsel-semantic-or-imenu)
              ;;("M-i" . counsel-grep-or-swiper)
              ("C-x C-r" . counsel-recentf)
              ("C-M-y" . counsel-yank-pop)
              ("C-h F" . counsel-faces)       ;Overrides `Info-goto-emacs-command-node'
              ("C-h S" . counsel-info-lookup-symbol)
              ("C-c u" . counsel-unicode-char)
              ("C-c C" . counsel-colors-emacs) ;Alternative to `list-colors-display'
              ([remap execute-extended-command] . counsel-M-x)
              ([remap bookmark-jump] . counsel-bookmark) ;Jump to book or set it if it doesn't exist, C-x r b
              ([remap bookmark-set] . counsel-bookmark)  ;C-x r m
              ([remap find-file]  . counsel-find-file)
              ([remap describe-bindings] . counsel-descbinds)
              ([remap finder-by-keyword] . counsel-package) ;C-h p
              ([remap describe-variable] . counsel-describe-variable)
              ([remap describe-function] . counsel-describe-function)
              ("M-s r" . counsel-rg)
              ("M-s g" . counsel-git-grep)
              ("M-s z" . prot/counsel-fzf-rg-files)
              :map ivy-minibuffer-map
              ("C-r" . counsel-minibuffer-history)
              ("C-SPC" . ivy-restrict-to-matches))
  :init
  (progn
    (bind-to-vde-map "s" #'counsel-rg))
  :config
  (progn
    (defun prot/counsel-fzf-rg-files (&optional input dir)
      "Run `fzf' in tandem with `ripgrep' to find files in the
present directory.  If invoked from inside a version-controlled
repository, then the corresponding root is used instead."
      (interactive)
      (let* ((process-environment
              (cons (concat "FZF_DEFAULT_COMMAND=rg -Sn --color never --files --no-follow --hidden")
                    process-environment))
             (vc (vc-root-dir)))
        (if dir
            (counsel-fzf input dir)
          (if (eq vc nil)
              (counsel-fzf input default-directory)
            (counsel-fzf input vc)))))

    (defun prot/counsel-fzf-dir (arg)
      "Specify root directory for `counsel-fzf'."
      (prot/counsel-fzf-rg-files ivy-text
                                 (read-directory-name
                                  (concat (car (split-string counsel-fzf-cmd))
                                          " in directory: "))))

    (defun prot/counsel-rg-dir (arg)
      "Specify root directory for `counsel-rg'."
      (let ((current-prefix-arg '(4)))
        (counsel-rg ivy-text nil "")))

    ;; TODO generalise for all relevant file/buffer counsel-*?
    (defun prot/counsel-fzf-ace-window (arg)
      "Use `ace-window' on `prot/counsel-fzf-rg-files' candidate."
      (ace-window t)
      (let ((default-directory (if (eq (vc-root-dir) nil)
                                   counsel--fzf-dir
                                 (vc-root-dir))))
        (if (> (length (aw-window-list)) 1)
            (progn
              (find-file arg))
          (find-file-other-window arg))
        (balance-windows)))

    ;; Pass functions as appropriate Ivy actions (accessed via M-o)
    (ivy-add-actions
     'counsel-fzf
     '(("r" prot/counsel-fzf-dir "change root directory")
       ("g" prot/counsel-rg-dir "use ripgrep in root directory")
       ("a" prot/counsel-fzf-ace-window "ace-window switch")))

    (ivy-add-actions
     'counsel-rg
     '(("r" prot/counsel-rg-dir "change root directory")
       ("z" prot/counsel-fzf-dir "find file with fzf in root directory")))

    (ivy-add-actions
     'counsel-find-file
     '(("g" prot/counsel-rg-dir "use ripgrep in root directory")
       ("z" prot/counsel-fzf-dir "find file with fzf in root directory")))

    (ivy-set-actions
     'counsel-find-file
     `(("x"
        (lambda (x) (delete-file (expand-file-name x ivy--directory)))
        ,(propertize "delete" 'face 'font-lock-warning-face))))

    (push '(counsel-rg . "--glob '**' -- ") ivy-initial-inputs-alist)
    ;; counsel-rg
    ;; Redefine `counsel-rg-base-command' with my required options, especially
    ;; the `--follow' option to allow search through symbolic links (part of
    ;; `modi/rg-arguments').
    (setq counsel-rg-base-command
          (concat (mapconcat #'shell-quote-argument
                             (append '("rg")
                                     vde/rg-arguments
                                     '("--no-heading" ;No file names above matching content
                                       ))
                             " ")
                  " %s"            ;This MUST be %s, not %S
                                        ;https://github.com/abo-abo/swiper/issues/427
                  ))))

(use-package company
  :commands global-company-mode
  :init
  (add-hook 'after-init-hook #'global-company-mode)
  (setq
   company-idle-delay 0.2
   company-selection-wrap-around t
   company-minimum-prefix-length 2
   company-require-match nil
   company-dabbrev-ignore-case nil
   company-dabbrev-downcase nil
   company-show-numbers t
   company-tooltip-align-annotations t)
  :config
  (bind-keys :map company-active-map
             ("C-d" . company-show-doc-buffer)
             ("C-l" . company-show-location)
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous)
             ("C-t" . company-select-next)
             ("C-s" . company-select-previous)
             ("TAB" . company-complete))
  (setq company-backends
        '(company-css
          company-clang
          company-capf
          company-semantic
          company-xcode
          company-cmake
          company-files
          company-gtags
          company-etags
          company-keywords)))

(use-package company-prescient
  :ensure company
  :after (company prescient)
  :config
  (company-prescient-mode 1))

(use-package company-emoji
  :ensure company
  :config
  (add-to-list 'company-backends 'company-emoji))

(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :custom
  (lsp-enable-file-watchers nil)
  (lsp-gopls-staticcheck t)
  (lsp-gopls-complete-unimported t)
  (lsp-eldoc-render-all nil)
  (lsp-enable-snippet nil)
  (lsp-enable-links nil)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-sideline-show-hover nil)
  (lsp-ui-sideline-delay 2.0)
  (lsp-ui-doc-enable nil)
  (lsp-ui-doc-max-width 30)
  (lsp-ui-doc-max-height 15)
  (lsp-document-highlight-delay 2.0)
  (lsp-auto-guess-root t)
  (lsp-ui-flycheck-enable t)
  (lsp-prefer-flymake nil) ; Use flycheck instead of flymake
  :hook ((go-mode . lsp-deferred)
         (python-mode . lsp-deferred)))

;; lsp-ui: This contains all the higher level UI modules of lsp-mode, like flycheck support and code lenses.
;; https://github.com/emacs-lsp/lsp-ui
(use-package lsp-ui
  :after lsp-mode
  ;;:hook ((lsp-mode . lsp-ui-mode)
  ;;       (lsp-ui-mode . lsp-ui-peek-mode))
  :config
  (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references))

;;Set up before-save hooks to format buffer and add/delete imports.
;;Make sure you don't have other gofmt/goimports hooks enabled.
(defun lsp-go-install-save-hooks ()
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))
(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)

(with-eval-after-load "company"
  (use-package company-lsp
    :after lsp-mode
    :config
    (push 'company-lsp company-backends)))

(with-eval-after-load "projectile"
  (defun my-set-projectile-root ()
    (when lsp--cur-workspace
      (setq projectile-project-root (lsp--workspace-root lsp--cur-workspace))))
  (add-hook 'lsp-before-open-hook #'my-set-projectile-root))

(use-package dap-mode
  :after lsp-mode
  :bind (:map dap-mode-map
              ([f9] . dap-debug)
              ;; ([f9] . dap-continue)
              ;; ([S-f9] . dap-disconnect)
              ;; ([f10] . dap-next)
              ;; ([f11] . dap-step-in)
              ;; ([S-f11] . dap-step-out)
              ([C-f9] . dap-hide/show-ui))
  :hook (dap-stopped-hook . (lambda (arg) (call-interactively #'dap-hydra)))
  :config
  ;; FIXME: Create nice solution instead of a hack
  (defvar dap-hide/show-ui-hidden? t)
  (defun dap-hide/show-ui ()
    "Hide/show dap ui. FIXME"
    (interactive)
    (if dap-hide/show-ui-hidden?
        (progn
          (setq dap-hide/show-ui-hidden? nil)
          (dap-ui-locals)
          (dap-ui-repl))
      (dolist (buf '("*dap-ui-inspect*" "*dap-ui-locals*" "*dap-ui-repl*" "*dap-ui-sessions*"))
        (when (get-buffer buf)
          (kill-buffer buf)))
      (setq dap-hide/show-ui-hidden? t)))

  (dap-mode)
  (dap-ui-mode)
  (dap-tooltip-mode))

(provide 'setup-completion)
#+end_src

*** ~setup-dired.el~
:PROPERTIES:
:CUSTOM_ID: h:739e0f3e-18f0-47c8-b510-ad5a4b09abdc
:END:

#+begin_src emacs-lisp :tangle config/setup-dired.el
;;; -*- lexical-binding: t; -*-
(use-package dired
  :defer t
  :custom
  (dired-auto-revert-buffer t)
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  (dired-isearch-filenames 'dwim)
  (delete-by-moving-to-trash t)
  (dired-listing-switches "-lFaGh1v --group-directories-first")
  (dired-ls-F-marks-symlinks t)
  (dired-dwim-target t)
  :bind (("<C-return>" . vde/open-in-external-app)
         ("C-c f g"    . vde/dired-get-size)
         ("C-c f f"    . find-name-dired)
         (:map dired-mode-map
               ("M-p"         . vde/dired-up)
               ("^"           . vde/dired-up)
               ("<backspace>" . vde/dired-up)
               ("M-n"         . vde/dired-down)
               ("RET"         . find-file-reuse-dir-buffer)
               ("!"           . vde/sudired)
               ("<prior>"     . beginend-dired-mode-goto-beginning)
               ("<next>"      . beginend-dired-mode-goto-end)))
  :config
  (when (string= system-type "darwin")
    (setq dired-use-ls-dired t
          insert-directory-program "/usr/local/bin/gls"))

  ;; Enable dired-find-alternate-file
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Handle long file names
  (add-hook 'dired-mode-hook #'toggle-truncate-lines)

  (defun vde/dired-up ()
    "Go to previous directory."
    (interactive)
    (find-alternate-file ".."))

  (defun vde/dired-down ()
    "Enter directory."
    (interactive)
    (dired-find-alternate-file))

  (defun vde/open-in-external-app ()
    "Open the file(s) at point with an external application."
    (interactive)
    (let* ((file-list
            (dired-get-marked-files)))
      (mapc
       (lambda (file-path)
         (let ((process-connection-type nil))
           (start-process "" nil "xdg-open" file-path))) file-list)))

  (defun find-file-reuse-dir-buffer ()
    "Like `dired-find-file', but reuse Dired buffers."
    (interactive)
    (set-buffer-modified-p nil)
    (let ((file (dired-get-file-for-visit)))
      (if (file-directory-p file)
          (find-alternate-file file)
        (find-file file))))

  (defun vde/sudired ()
    "Open directory with sudo in Dired."
    (interactive)
    (require 'tramp)
    (let ((dir (expand-file-name default-directory)))
      (if (string-match "^/sudo:" dir)
          (user-error "Already in sudo")
        (dired (concat "/sudo::" dir)))))

  (defun vde/dired-get-size ()
    "Quick and easy way to get file size in Dired."
    (interactive)
    (let ((files (dired-get-marked-files)))
      (with-temp-buffer
        (apply 'call-process "du" nil t nil "-sch" files)
        (message
         "Size of all marked files: %s"
         (progn
           (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
           (match-string 1)))))))

(use-package find-dired
  :after dired
  :custom
  (find-ls-option ;; applies to `find-name-dired'
   '("-ls" . "-AFhlv --group-directories-first"))
  (find-name-arg "-iname"))

(use-package dired-x                    ; Enable some nice Dired features
  :bind ("C-x C-j" . dired-jump)
  :custom
  (dired-omit-verbose nil)
  (dired-clean-confirm-killing-deleted-buffers nil)
  :hook
  (dired-mode . dired-omit-mode)
  :config
  (setq dired-omit-files (concat dired-omit-files "\\|^\\.+$\\|^\\..+$")))

(use-package dired-aux                  ; Other Dired customizations
  :after dired
  :config
  (setq
   ;; Ask for creation of missing directories when copying/moving
   dired-create-destination-dirs 'ask
   ;; Search only file names when point is on a file name
   dired-isearch-filenames'dwim))

(use-package dired-collapse
  :defer 1
  :commands (dired-collapse-mode)
  :init
  (add-hook 'dired-mode-hook #'dired-collapse-mode))

(use-package dired-quick-sort
  :defer 1
  :after dired
  :config
  (dired-quick-sort-setup))

(use-package async)

(use-package dired-async
  :after (dired async)
  :config
  (dired-async-mode 1))

(use-package dired-narrow
  :after dired
  :custom
  (dired-narrow-exit-when-one-left t)
  (dired-narrow-enable-blinking t)
  (dired-narrow-blink-time 0.3)
  :bind (:map dired-mode-map
              ("M-s n" . dired-narrow)))

(use-package wdired
  :after dired
  :commands (wdired-mode
             wdired-change-to-wdired-mode)
  :custom
  (wdired-allow-to-change-permissions t)
  (wdired-create-parent-directories t))

(use-package dired-rsync
  :ensure t
  :bind (:map dired-mode-map
              ("r" . dired-rsync)))

(provide 'setup-dired)
#+end_src

*** ~setup-docker.el~
:PROPERTIES:
:CUSTOM_ID: h:47e8ae18-cb65-4b18-99eb-36cee80786e8
:END:

#+begin_src emacs-lisp :tangle config/setup-docker.el
;;; -*- lexical-binding: t; -*-
(use-package dockerfile-mode            ; Edit docker's Dockerfiles
  :mode ("Dockerfile\\'" . dockerfile-mode))

;; I have a bunch of different 'profiles' for kubernetes by different cluster so
;; i don't mess between things
;; This allow me to set the KUBECONFIG variable between those easily
;; TODO: add the current profile in modeline
(defun my-switch-kubeconfig-env (&optional kubeconfig)
  "Set KUBECONFIG environment variable for the current session"
  (interactive
   (list
    (completing-read
     "Kubeconfig: "
     (mapcar
      (lambda (x)
        (replace-regexp-in-string
         "^config\." ""
         (file-name-nondirectory(directory-file-name x))))
      (directory-files-recursively
       (expand-file-name "~/.kube") "^config\.")) nil t )))
  (setq kubeconfig (expand-file-name (format "~/.kube/config.%s" kubeconfig)))
  (if (file-exists-p kubeconfig)
      (setenv "KUBECONFIG" kubeconfig)
    (error "Cannot find kubeconfig: %s" kubeconfig)))

(provide 'setup-docker)
#+end_src

*** ~setup-editing.el~
:PROPERTIES:
:CUSTOM_ID: h:60b9cba7-507c-4f07-be1a-e8e71c3ae7a4
:END:

#+begin_src emacs-lisp :tangle config/setup-editing.el
;;; -*- lexical-binding: t; -*-
(setq enable-remote-dir-locals t)
(use-package aggressive-indent          ; Automatically indent code
  :bind ("C-c e i" . aggressive-indent-mode)
  :hook ((lisp-mode       . aggressive-indent-mode)
         (emacs-lisp-mode . aggressive-indent-mode)
         (clojure-mode    . aggressive-indent-mode))
  :config
  ;; Free C-c C-q, used in Org and in CIDER
  (unbind-key "C-c C-q" aggressive-indent-mode-map))

(use-package undo-tree                  ; Show buffer changes as a tree
  :defer 1
  :init (global-undo-tree-mode)
  :config (setq undo-tree-visualizer-timestamps t
                undo-tree-enable-undo-in-region t))

(use-package whitespace
  :defer 1
  :hook ((prog-mode . whitespace-mode))
  :config
  (setq whitespace-style '(face tabs spaces trailing space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))

(use-package smartparens
  :defer 1
  :init
  (progn
    (use-package smartparens-config)
    (show-smartparens-global-mode 1))
  :config
  (progn
    (require 'smartparens-config)
    (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)

    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
    (sp-local-pair 'web-mode "{%" "%}")
    (sp-with-modes 'emacs-lisp-mode
      ;; disable ', it's the quote character!
      (sp-local-pair "'" nil :actions nil)
      ;; also only use the pseudo-quote inside strings where it
      ;; serves as hyperlink.
      (sp-local-pair "`" "'" :when '(sp-in-string-p sp-in-comment-p)))))

(use-package expand-region
  :bind (("C-=" . er/expand-region)
         ("C--". er/contract-region)))

(use-package iedit
  :defines hydra-iedit/body
  :bind* (:map global-map
               ("C-*" . iedit-mode)
               :map iedit-mode-keymap
               ("M-n" . iedit-next-occurence)
               ("M-p" . iedit-prev-occurence))
  :config
  (defhydra hydra-iedit (:color pink :columns 1)
    "IEDIT"
    ("C-*" iedit-mode "toggle")
    ("C-p" iedit-prev-occurrence "prev")
    ("C-n" iedit-next-occurrence "next")
    ("C-g" iedit-quit "toggle" :color blue)))

(use-package visual-regexp
  :bind (("C-c r"   . vr/replace)
         ("C-c %"   . vr/query-replace)
         ("C-c m" . vr/mc-mark)))

(use-package yasnippet
  :after (company prog-mode)
  :defer 5
  :bind (("C-c y d" . yas-load-directory)
         ("C-c y i" . yas-insert-snippet)
         ("C-c y f" . yas-visit-snippet-file)
         ("C-c y n" . yas-new-snippet)
         ("C-c y t" . yas-tryout-snippet)
         ("C-c y l" . yas-describe-tables)
         ("C-c y g" . yas-global-mode)
         ("C-c y m" . yas-minor-mode)
         ("C-c y a" . yas-reload-all)
         ("C-c y x" . yas-expand))
  :bind (:map yas-keymap
              ("C-i" . yas-next-field-or-maybe-expand))
  :mode ("/\\.emacs\\.d/etc/yasnippet/snippets/" . snippet-mode)
  :hook (go-mode . yas-minor-mode)
  :config
  (yas-load-directory (concat user-emacs-directory "etc/yasnippet/snippets"))
  (yas-global-mode 1)
  :init
  (add-hook 'term-mode-hook (lambda () (yas-minor-mode -1))))

(use-package hs-minor-mode
  :hook ((prog-mode . hs-minor-mode)))

(use-package easy-kill
  :config
  (global-set-key [remap kill-ring-save] 'easy-kill)
  (global-set-key [remap mark-sexp] 'easy-mark))

(use-package define-word)

(setq display-line-numbers-type 'relative)
(add-hook 'prog-mode-hook
          'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'toggle-truncate-lines)

(use-package newcomment
  :custom
  (comment-empty-lines t)
  (comment-fill-column nil)
  (comment-multi-line t)
  (comment-style 'multi-line)
  :config
  (defun prot/comment-dwim (&optional arg)
    "Alternative to `comment-dwim': offers a simple wrapper
around `comment-line' and `comment-dwim'.

If the region is active, then toggle the comment status of the
region or, if the major mode defines as much, of all the lines
implied by the region boundaries.

Else toggle the comment status of the line at point."
    (interactive "*P")
    (if (use-region-p)
        (comment-dwim arg)
      (save-excursion
        (comment-line arg))))

  :bind (("C-;" . prot/comment-dwim)
         ("C-:" . comment-kill)
         ("M-;" . comment-indent)
         ("C-x C-;" . comment-box)))

(use-package flyspell
  :init
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "hunspell")
  (setq ispell-local-dictionary "en_GB")
  (setq ispell-local-dictionary-alist
        '(("en_GB"
           "[[:alpha:]]"
           "[^[:alpha:]]"
           "[']"
           nil
           ("-d" "en_GB,fr_FR")
           nil
           utf-8)))
  :config
  (define-key flyspell-mode-map (kbd "C-;") nil)
  :hook
  (text-mode . turn-on-flyspell)
  (prog-mode . turn-off-flyspell))

(use-package flyspell-correct-ivy
  :after flyspell
  :bind (:map flyspell-mode-map
              ([remap flyspell-correct-word-before-point] . flyspell-correct-previous-word-generic)))

(use-package electric
  :custom
  (electric-pair-inhibit-predicate 'electric-pair-default-inhibit)
  (electric-pair-pairs '((8216 . 8217)
                         (8220 . 8221)
                         (171 . 187)))
  (electric-pair-skip-self 'electric-pair-default-skip-self)
  (electric-quote-context-sensitive t)
  (electric-quote-paragraph t)
  (electric-quote-string nil)
  :config
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (electric-quote-mode -1))

(use-package emacs
  :init
  (setq-default tab-always-indent 'complete)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil))

(use-package emacs
  :hook (before-save . delete-trailing-whitespace))

(use-package delsel
  :config
  (delete-selection-mode 1))

(use-package emacs
  :custom
  (repeat-on-final-keystroke t)
  (set-mark-command-repeat-pop t)
  :bind ("M-z" . zap-up-to-char))

(use-package emacs
  :config
  (defun prot/new-line-below ()
    "Create a new line below the current one.  Move the point to
the absolute beginning.  Also see `prot/new-line-above'."
    (interactive)
    (end-of-line)
    (newline))

  (defun prot/new-line-above ()
    "Create a new line above the current one.  Move the point to
the absolute beginning.  Also see `prot/new-line-below'."
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1))

  (defun prot/yank-replace-line-or-region ()
    "Replace the line at point with the contents of the last
stretch of killed text.  If the region is active, operate over it
instead.  This command can then be followed by the standard
`yank-pop' (default is bound to M-y)."
    (interactive)
    (if (use-region-p)
        (progn
          (delete-region (region-beginning) (region-end))
          (yank))
      (progn
        (delete-region (point-at-bol) (point-at-eol))
        (yank))))

  :bind (("C-S-SPC" . contrib/mark-whole-word)
         ("<C-return>" . prot/new-line-below)
         ("<C-S-return>" . prot/new-line-above)
         ("M-SPC" . cycle-spacing)
         ("M-o" . delete-blank-lines)
         ("<f6>" . tear-off-window)
         ("C-S-y" . prot/yank-replace-line-or-region)))

(use-package crux
  :commands (crux-transpose-windows
             crux-duplicate-current-line-or-region
             crux-rename-file-and-buffer
             crux-open-with)
  :bind (("C-c w S" . crux-transpose-windows)
         ("C-c d" . crux-duplicate-current-line-or-region)
         ("<C-f2>" . crux-rename-file-and-buffer)
         :map dired-mode-map
         ("<M-return>" . crux-open-with)))

(use-package goto-last-change
  :commands goto-last-change
  :bind ("C-z" . goto-last-change))

(use-package pdf-tools
  :pin manual
  :mode  ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq-default pdf-view-display-size 'fit-page)
  (setq pdf-annot-activate-created-annotations t)
  (setq pdf-view-midnight-colors '("#ffffff" . "#000000"))
  (pdf-tools-install :no-query)
  (require 'pdf-occur))

(provide 'setup-editing)
#+end_src

*** ~setup-files.el~
:PROPERTIES:
:CUSTOM_ID: h:2e1f18fb-5555-4c91-a134-e509eccdf67a
:END:

#+begin_src emacs-lisp :tangle config/setup-files.el
;;; -*- lexical-binding: t; -*-
(use-package files                      ; Core commands for files
  :bind (("<f5>" . revert-buffer)))

(use-package ripgrep
  :defer 2)

(setq view-read-only t)                 ; View read-only

(use-package direnv
  :custom
  (direnv-always-show-summary t)
  (direnv-show-paths-in-summary nil)
  :config
  (direnv-mode))

(use-package hardhat                    ; Protect user-writable files
  :init (global-hardhat-mode))

(use-package image-file                 ; Visit images as images
  :init (auto-image-file-mode))

(use-package markdown-mode              ; Edit markdown files
  :mode ("\\.md\\'" . markdown-mode)
  :config
  (setq markdown-fontify-code-blocks-natively t)

  ;; Don't change font in code blocks
  (set-face-attribute 'markdown-code-face nil
                      :inherit nil)

  ;; Process Markdown with Pandoc, using a custom stylesheet for nice output
  (let ((stylesheet (expand-file-name
                     (locate-user-emacs-file "etc/pandoc.css"))))
    (setq markdown-command
          (mapconcat #'shell-quote-argument
                     `("pandoc" "--toc" "--section-divs"
                       "--css" ,(concat "file://" stylesheet)
                       "--standalone" "-f" "markdown" "-t" "html5")
                     " ")))
  (add-hook 'markdown-mode-hook #'auto-fill-mode))

(use-package highlight-indentation
  :config
  (set-face-background 'highlight-indentation-face "#e3e3d3")
  (set-face-background 'highlight-indentation-current-column-face "#c3b3b3"))

(use-package yaml-mode
  :mode "\\.ya?ml\\'"
  :hook ((yaml-mode . highlight-indentation-mode)
         (yaml-mode . highlight-indentation-current-column-mode)))

(use-package toml-mode
  :mode "\\.to?ml\\'")

;;;###autoload
(defun vde/delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))

;;;###autoload
(defun vde/rename-this-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (if (get-buffer new-name)
        (message "A buffer named '%s' already exists!" new-name)
      (progn
        (when (file-exists-p filename)
          (rename-file filename new-name 1))
        (rename-buffer new-name)
        (set-visited-file-name new-name)))))

(bind-key "C-c f D" #'vde/delete-this-file)
(bind-key "C-c f R" #'vde/rename-this-file-and-buffer)

;; Additional bindings for built-ins
(bind-key "C-c f v d" #'add-dir-local-variable)
(bind-key "C-c f v l" #'add-file-local-variable)
(bind-key "C-c f v p" #'add-file-local-variable-prop-line)

(defun vde/reload-dir-locals-for-current-buffer ()
  "Reload dir locals for the current buffer."
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

(defun vde/reload-dir-locals-for-all-buffers-in-this-directory ()
  "Reload dir-locals for all buffers in current buffer's `default-directory'."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir))
        (vde/reload-dir-locals-for-current-buffer)))))

(bind-key "C-c f v r" #'vde/reload-dir-locals-for-current-buffer)
(bind-key "C-c f v r" #'vde/reload-dir-locals-for-all-buffers-in-this-directory)

(provide 'setup-files)
#+end_src

*** ~setup-go.el~
:PROPERTIES:
:CUSTOM_ID: h:28696bf2-7a37-493f-b760-bb4d89a5d051
:END:

#+begin_src emacs-lisp :tangle config/setup-go.el
;;; -*- lexical-binding: t; -*-
(use-package go-mode
  :mode "\\.go$"
  :interpreter "go"
  :config
  (use-package company-go
    :config
    (setq company-go-show-annotation t)
    (push 'company-go company-backends))
  ;(setq gofmt-command "goimports")
  (if (not (executable-find "goimports"))
      (warn "go-mode: couldn't find goimports; no code formatting/fixed imports on save")
    (add-hook 'before-save-hook 'gofmt-before-save))
  (if (not (string-match "go" compile-command))   ; set compile command default
      (set (make-local-variable 'compile-command)
           "go build -v && go test -v && go vet")))

(use-package flycheck-golangci-lint
  :hook (go-mode . flycheck-golangci-lint-setup)
  :config (setq flycheck-golangci-lint-tests t))

(use-package dap-go
  :after dap-mode)

(use-package gotest
  :after go-mode)

(use-package gotest-ui
  :after (go-mode gotest)
  :bind (:map go-mode-map
              ("C-c t t" . gotest-ui-current-test)
              ("C-c t f" . gotest-ui-current-file)
              ("C-c t p" . gotest-ui-current-project)))

(provide 'setup-go)
#+end_src

*** ~setup-hydras.el~
:PROPERTIES:
:CUSTOM_ID: h:c763026a-a3f2-4ed5-a6e6-1b49fa2a6b1c
:END:

#+begin_src emacs-lisp :tangle config/setup-hydras.el
;;; -*- lexical-binding: t; -*-
(defhydra hydra-goto-line (goto-map "")
  "goto-line"
  ("g" goto-line "go")
  ("m" set-mark-command "mark" :bind nil)
  ("q" nil "quit"))

(defhydra hydra-yank-pop ()
  "yank"
  ("C-y" yank nil)
  ("M-y" yank-pop nil)
  ("y" (yank-pop 1) "next")
  ("Y" (yank-pop -1) "prev"))   ; or browse-kill-ring

(defhydra hydra-zoom (global-map "<f2>")
  "zoom"
  ("g" text-scale-increase "in")
  ("l" text-scale-decrease "out")
  ("r" (text-scale-set 0) "reset")
  ("0" (text-scale-set 0) :bind nil :exit t)
  ("1" (text-scale-set 0) nil :bind nil :exit t))

;; Better shrink/enlarge windows
(defhydra hydra-resize (global-map "<f2>")
  "resize windows"
  ("<up>" enlarge-window "enlarge")
  ("<down>" shrink-window "shrink")
  ("<left>" shrink-window-horizontally "shrink horizontaly")
  ("<right>" enlarge-window-horizontally "enlarge horizontaly"))

(defvar hide-mode-line-mode nil)
(defvar whitespace-mode nil)
(defvar subword-mode nil)
(defhydra hydra-toggle (:color pink :hint nil)
  "
_a_ abbrev-mode:          %`abbrev-mode
_b_ subword-mode:         %`subword-mode
_d_ debug-on-error:       %`debug-on-error
_h_ hide-mode-line-mode   %`hide-mode-line-mode
_f_ auto-fill-mode:       %`auto-fill-function
_r_ readonly-mode:        %`buffer-read-only
_t_ truncate-lines        %`truncate-lines
_v_ visual-line-mode:     %`visual-line-mode
_w_ whitespace-mode:      %`whitespace-mode
_s_ smartparens-strict:   %`smartparens-strict-mode
_V_ visible-mode:         %`visible-mode
"
  ("a" abbrev-mode             nil)
  ("b" subword-mode            nil)
  ("d" toggle-debug-on-error   nil)
  ("f" auto-fill-mode          nil)
  ("h" hide-mode-line-mode     nil)
  ("r" dired-toggle-read-only  nil)
  ("t" toggle-truncate-lines   nil)
  ("v" visual-line-mode        nil)
  ("V" visible-mode            nil)
  ("w" whitespace-mode         nil)
  ("s" smartparens-strict-mode nil)
  ("q" nil "quit"))

(global-set-key (kbd "C-c C-v") 'hydra-toggle/body)

(defhydra hydra-marked-items (dired-mode-map "")
  "
Number of marked items: %(length (dired-get-marked-files))
"
  ("m" dired-mark "mark"))

(bind-key "M-y" #'hydra-yank-pop/yank-pop)
(bind-key "C-y" #'hydra-yank-pop/yank)

(provide 'setup-hydras)
#+end_src

*** ~setup-keybindings.el~
:PROPERTIES:
:CUSTOM_ID: h:35f0e304-7076-4b73-b148-a206db3f0bcb
:END:

#+begin_src emacs-lisp :tangle config/setup-keybindings.el
(use-package which-key
  :init (which-key-mode)
  :custom
  (which-key-idle-delay 2)
  (which-key-idle-secondary-delay 0.05)
  (which-key-show-early-on-C-h t)
  (which-key-sort-order 'which-key-prefix-then-key-order)
  (which-key-popup-type 'side-window)
  (which-key-show-prefix 'echo)
  (which-key-max-display-columns 6)
  (which-key-separator " → ")
  :config
  (add-to-list 'which-key-replacement-alist '(("TAB" . nil) . ("↹" . nil)))
  (add-to-list 'which-key-replacement-alist '(("RET" . nil) . ("⏎" . nil)))
  (add-to-list 'which-key-replacement-alist '(("DEL" . nil) . ("⇤" . nil)))
  (add-to-list 'which-key-replacement-alist '(("SPC" . nil) . ("␣" . nil))))

(use-package region-bindings-mode
  :config
  ;; Do not activate `region-bindings-mode' in Special modes like `dired' and
  ;; `ibuffer'. Single-key bindings like 'm' are useful in those modes even
  ;; when a region is selected.
  (setq region-bindings-mode-disabled-modes '(dired-mode ibuffer-mode))

  (region-bindings-mode-enable)

  (defun vde/disable-rbm-deactivate-mark ()
    "Disable `region-bindings-mode' and deactivate mark."
    (interactive)
    (region-bindings-mode -1)
    (deactivate-mark)
    (message "Mark deactivated"))

  (bind-keys
   :map region-bindings-mode-map
   ("<C-SPC>" . vde/disable-rbm-deactivate-mark)))

;; Disable C-x C-n to avoid the disabled command buffer
(unbind-key "C-x C-n" global-map)

(provide 'setup-keybindings)
#+end_src

*** ~setup-multiple-cursor.el~
:PROPERTIES:
:CUSTOM_ID: h:2b97e563-abdc-4f0d-95e2-b212c696196c
:END:

#+begin_src emacs-lisp :tangle config/setup-multiple-cursors.el
(use-package multiple-cursor
  :bind (:map vde-mode-map
              ("C-S-c C-S-c" . mc/edit-lines))
  :bind (:map region-bindings-mode-map
              ("a" . mc/mark-all-like-this)
              ("p" . mc/mark-previous-like-this)
              ("n" . mc/mark-next-like-this)
              ("P" . mc/unmark-previous-like-this)
              ("N" . mc/unmark-next-like-this)
              ("[" . mc/cycle-backward)
              ("]" . mc/cycle-forward)
              ("m" . mc/mark-more-like-this-extended)
              ("h" . mc-hide-unmatched-lines-mode)
              ("\\" . mc/vertical-align-with-space)
              ("#" . mc/insert-numbers) ; use num prefix to set the starting number
              ("^" . mc/edit-beginnings-of-lines)
              ("$" . mc/edit-ends-of-lines)))

(provide 'setup-multiple-cursors)
#+end_src

*** ~setup-navigating.el~
:PROPERTIES:
:CUSTOM_ID: h:e082e210-60b9-446e-a85f-c97ed94854a8
:END:

#+begin_src emacs-lisp :tangle config/setup-navigating.el
(use-package avy                   ; Jump to characters in buffers
  :bind (("C-c j"   . avy-goto-word-1)
         ("C-c n b" . avy-pop-mark)
         ("C-c n j" . avy-goto-char-2)
         ("C-c n t" . avy-goto-char-timer)
         ("C-c n w" . avy-goto-word-1)))

(use-package helpful
  :bind (("C-c h F" . helpful-function)
         ("C-c h C" . helpful-command)
         ("C-c h M" . helpful-macro)
         ("C-c h L" . helpful-callable)
         ("C-c h S" . helpful-at-point)
         ("C-c h V" . helpful-variable)))
(use-package winner
  :unless noninteractive
  :defer 5
  :config
  (winner-mode 1))

(use-package hideshow
  :defer 5
  :bind (("C-c @ a" . hs-show-all)
         ("C-c @ c" . hs-toggle-hiding)
         ("C-c @ t" . hs-hide-all)
         ("C-c @ d" . hs-hide-block)
         ("C-c @ l" . hs-hide-level)))

(use-package mwim
  :bind (:map prog-mode-map
              ("C-a" . mwim-beginning-of-code-or-line)
              ("C-e" . mwim-end-of-code-or-line)))

(provide 'setup-navigating)
#+end_src

*** ~setup-nix.el~
:PROPERTIES:
:CUSTOM_ID: h:5429052a-d792-429a-9176-c9a3e3e7e130
:END:

#+begin_src emacs-lisp :tangle config/setup-nix.el
;;; -*- lexical-binding: t; -*-
(use-package nix-mode
  :mode ("\\.nix\\'" "\\.nix.in\\'"))

(use-package nix-drv-mode
  :ensure nix-mode
  :mode "\\.drv\\'")

(use-package nix-shell
  :ensure nix-mode
  :commands (nix-shell-unpack nix-shell-configure nix-shell-build))

(provide 'setup-nix)
#+end_src

*** ~setup-notmuch.el~
:PROPERTIES:
:CUSTOM_ID: h:a6256db2-c230-4261-bf4a-0f8a0f09e810
:END:

#+begin_src emacs-lisp :tangle config/setup-notmuch.el
(use-package notmuch
  :defer t
  :bind ("<f6>" . notmuch)
  :config
  (setq notmuch-search-oldest-first nil
        mail-user-agent 'message-user-agent
        notmuch-tree-show-out t)
  (setq notmuch-saved-searches
        '((:key "i" :name "inbox" :query "tag:Inbox")
          (:key "r" :name "redhat inbox folder" :query "folder:redhat/Inbox")
          (:key "p" :name "perso inbox folder" :query "folder:perso/Inbox")
          (:key "u" :name "unread" :query "tag:unread")
          (:key "F" :name "flagged" :query "tag:flagged")
          (:key "S" :name "sent" :query "tag:Sent Mail"))))

(use-package sendmail
  :defer t
  :commands (mail-mode mail-text)
  :defines (send-mail-function)
  :config
  (setq send-mail-function 'sendmail-send-it
        sendmail-program "/home/vincent/bin/msmtp"))

(use-package message
  :commands (message-mode message-cite-original-without-signature)
  :config
  (add-hook 'message-mode-hook 'turn-on-auto-fill)
  (setq  message-default-mail-headers "Cc: \nBcc: \n"
         message-kill-buffer-on-exit t
         message-generate-headers-first t))

(provide 'setup-notmuch)
#+end_src

*** ~setup-org.el~
:PROPERTIES:
:CUSTOM_ID: h:46adc0c2-75cb-4bc7-8aab-c4338a06a96d
:END:

#+begin_src emacs-lisp :tangle config/setup-org.el
;;; -*- lexical-binding: t; -*-

(use-package org
  :defer t
  :ensure org-plus-contrib
  :config
  (use-package find-lisp)

  (use-package org-super-agenda
    :config (org-super-agenda-mode))

  (setq org-super-agenda-header-separator "")
  (setq org-agenda-custom-commands
        `(("n" "Personal agenda"
           ((agenda "")
            (tags-todo "+TODO=\"NEXT\""
                       ((org-agenda-overriding-header "Next items")))
            (tags-todo "@work-goals"
                       ((org-agenda-skip-function '(org-agenda-skip-if nil '(scheduled deadline)))
                        (org-agenda-overriding-header "Work")))
            (tags-todo "@home-goals"
                       ((org-agenda-skip-function '(org-agenda-skip-if nil '(scheduled deadline)))
                        (org-agenda-overriding-header "Home"))))
           ((org-super-agenda-groups
             '((:name "Important" :priority "A")
               (:name "Done" :log closed)
               (:name "Scheduled" :time-grid t)
               (:name "Work" :tag "@work")
               (:name "Perso" :tag "@home")
               (:habit t))))
           (org-agenda-list))))

  (defun vde/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun vde/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (vde/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun vde/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun vde/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun vde/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (org-clock-persistence-insinuate)
  ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
  (setq org-clock-history-length 23)
  ;; Change tasks to STARTED when clocking in
  (setq org-clock-in-switch-to-state 'vde/clock-in-to-started)
  ;; Clock out when moving task to a done state
  (setq org-clock-out-when-done t)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist t)

  (defun vde/clock-in-to-started (kw)
    "Switch a task from TODO to STARTED when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from STARTED back to TODO"
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO"))
             (vde/is-task-p))
        "STARTED")
       ((and (member (org-get-todo-state) (list "STARTED"))
             (vde/is-project-p))
        "TODO"))))

  (defvar org-capture-templates (list))
  (setq org-protocol-default-template-key "l")

  ;; images
  (setq org-image-actual-width nil
        org-startup-with-inline-images t)

  ;; Tasks (-> inbox)
  (add-to-list 'org-capture-templates
               `("t" "Task Entry" entry
                 (file ,org-default-inbox-file)
                 "* %?\n:PROPERTIES:\n:CREATED:%U\n:END:\n\n%i\n\nFrom: %a"
                 :empty-lines 1))
  (add-to-list 'org-capture-templates
               `("r" "PR Review" entry
                 (file ,org-default-inbox-file)
                 "* TODO review gh:%^{issue} :review:\n:PROPERTIES:\n:CREATED:%U\n:END:\n\n%i\n%?\nFrom: %a"
                 :empty-lines 1))
  (add-to-list 'org-capture-templates
               `("l" "Link" entry
                 (file ,org-default-inbox-file)
                 "* %a\n%U\n%?\n%i"
                 :empty-lines 1))
  (add-to-list 'org-capture-templates
               '("n" "Thought or Note"  entry
                 (file org-default-notes-file)
                 "* %?\n\n  %i\n\n  See: %a" :empty-lines 1))

  ;; Journal
  (add-to-list 'org-capture-templates
               `("j" "Journal entry" entry
                 (file+datetree ,org-default-journal-file)
                 "* %^{title}\n%U\n%?\n%i\nFrom: %a"
                 :empty-lines 1 :clock-in t :clock-resume t))
  (add-to-list 'org-capture-templates
               `("w" "Worklog (journal) entry" entry
                 (file+datetree ,org-default-journal-file)
                 "* worklog :@work:log:\n%U\n** Today\n%?\n** Next (later today, tomorrow)\n"
                 :unnarrowed t))
  (add-to-list 'org-capture-templates
               `("e" "Weekly review" entry
                 (file+datetree,org-default-journal-file)
                 "* weekly review :weekly:review:\n%U

- [ ] review [[file:../projects/inbox.org][~inbox.org~]]
  Clean the file by either
  - refiling it to ~incubate.org~
  - removing it / archiving it
- [ ] review [[file:../projects/incubate.org][~incubate.org~]]
  - Is something worth becoming a project
  - Is something not worth thinking about anymore ?
- [ ] empty mail inbox (and create task if needed)
  - [ ] work
  - [ ] perso
- [ ] Review next week ~F12 n w f~
- [ ] review ~org-mode~ workflow
  - *what works, what doesn't ?*
  - *is there task / stuck projects ?*
  - *enhancement possible ?*
- [ ] export previous agenda (somewhere)"
                 :clock-in t :clock-resume t :unnarrowed t))

  ;; Olds, most likely to remove
  (add-to-list 'org-capture-templates
               `("b" "Blog post" entry
                 (file+headline "~/src/github.com/vdemeester/blog/content-org/posts.org" "Blog Ideas")
                 "* %?\n:PROPERTIES:\n:END:\n"))
  (add-to-list 'org-capture-templates
               `("bl" "Blog link post" entry
                 (file+olp "~/src/github.com/vdemeester/blog/content-org/links.org" "Link")
                 "* %a\n%?\n%i"))

  (setq org-ditaa-jar-path "/home/vincent/.nix-profile/lib/ditaa.jar") ;; FIXME(vdemeester) remove /home/vincent
  ;; org-babel
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((css . t)
     (dot . t)
     (ditaa . t)
     (emacs-lisp . t)
     (go . t)
     (gnuplot . t)
     (http . t)
     (js . t)
     ;;(ledger . t)
     (latex . t)
     (python . t)
     ;;(rust . t)
     (shell . t)
     ;;(typescript . t)
     ))

  (setq org-latex-listings t)

  (setq org-list-demote-modify-bullet
        '(("+" . "-") ("-" . "+")))

  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" "#\\+END_EXAMPLE"))

  ;; org-links
  ;; from http://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html
  (org-link-set-parameters "tag"
                           :follow #'endless/follow-tag-link)
  (defun endless/follow-tag-link (tag)
    "Display a list of TODO headlines with tag TAG.
With prefix argument, also display headlines without a TODO keyword."
    (org-tags-view (null current-prefix-arg) tag))

  (org-link-set-parameters "grep"
                           :follow #'vde/follow-grep-link
                           :face '(:foreground "DarkRed" :underline t))
  (defun vde/follow-grep-link (regexp)
    "Run `rgrep' with REGEXP and FOLDER as argument,
like this : [[grep:REGEXP:FOLDER]]."
    (setq expressions (split-string regexp ":"))
    (setq exp (nth 0 expressions))
    (grep-compute-defaults)
    (if (= (length expressions) 1)
        (progn
          (rgrep exp "*" (expand-file-name "./")))
      (progn
        (setq folder (nth 1 expressions))
        (rgrep exp "*" (expand-file-name folder))))
    )

  (org-link-set-parameters "rg"
                           :follow #'vde/follow-rg-link
                           :face '(:foreground "DarkGreen" :underline t))
  (defun vde/follow-rg-link (regexp)
    "Run `ripgrep-regexp` with REXEP and FOLDER as argument,
like this : [[pt:REGEXP:FOLDER]]"
    (setq expressions (split-string regexp ":"))
    (setq exp (nth 0 expressions))
    (if (= (length expressions) 1)
        (progn
          (ripgrep-regexp exp (expand-file-name "./")))
      (progn
        (setq folder (nth 1 expressions))
        (ripgrep-regexp exp (file-name-as-directory (expand-file-name folder)))))
    )

  (org-link-set-parameters "gh"
                           :follow #'vde/follow-gh-link
                           :export #'vde/org-gh-export
                           :face '(:foreground "DimGrey" :underline t))
  (defun vde/org-gh-export (link description format)
    "Export a github page link from Org files."
    (let ((path (vde/gh-get-url link))
          (desc (or description link)))
      (cond
       ((eq format 'html) (format "<a hrefl=\"_blank\" href=\"%s\">%s</a>" path desc))
       ((eq format 'latex) (format "\\href{%s}{%s}" path desc))
       ((eq format 'texinfo) (format "@uref{%s,%s}" path desc))
       ((eq format 'ascii) (format "%s (%s)" desc path))
       (t path))))
  (defun vde/follow-gh-link (issue)
    "Browse github issue/pr specified"
    (browse-url (vde/gh-get-url issue)))

  (defun vde/gh-get-url (path)
    "Translate org-mode link `gh:foo/bar#1' to github url."
    (setq expressions (split-string path "#"))
    (setq project (nth 0 expressions))
    (setq issue (nth 1 expressions))
    (format "https://github.com/%s/issues/%s" project issue))

  (org-link-set-parameters
   "org"
   :complete (lambda () (+org-link-read-file "org" org-directory))
   :follow   (lambda (link) (find-file (expand-file-name link org-directory)))
   :face     (lambda (link)
               (if (file-exists-p (expand-file-name link org-directory))
                   'org-link
                 'error)))
  (defun +org-link-read-file (key dir)
    (let ((file (read-file-name (format "%s: " (capitalize key)) dir)))
      (format "%s:%s"
              key
              (file-relative-name file dir))))
  )

(use-package smartparens-org
  :after org-mode)

(use-package org-capture-pop-frame)

(use-package darkroom
  :custom
  (darkroom-text-scale-increase 2))
(use-package org-tree-slide
  :after (org darkroom)
  :custom
  (org-tree-slide-breadcrumbs nil)
  (org-tree-slide-header nil)
  (org-tree-slide-slide-in-effect nil)
  (org-tree-slide-heading-emphasis nil)
  (org-tree-slide-cursor-init t)
  (org-tree-slide-modeline-display nil)
  (org-tree-slide-skip-done nil)
  (org-tree-slide-skip-comments t)
  (org-tree-slide-fold-subtrees-skipped t)
  (org-tree-slide-skip-outline-level 8)
  (org-tree-slide-never-touch-face t)
  :config
  (defun prot/org-presentation ()
    "Specifies conditions that should apply locally upon
activation of `org-tree-slide-mode'."
    (if (eq darkroom-tentative-mode nil)
        (progn
          (darkroom-tentative-mode 1)
          (org-indent-mode 1)
          (set-frame-font "Hack-14" t t)
          (setq cursor-type '(bar . 1)))
      (darkroom-tentative-mode -1)
      (org-indent-mode -1)
      (prot/fonts-per-monitor)
      (setq cursor-type 'box)))
  :bind (("<f8>" . org-tree-slide-mode)
         :map org-tree-slide-mode-map
         ("<C-right>" . org-tree-slide-move-next-tree)
         ("<C-left>" . org-tree-slide-move-previous-tree))
  :hook (org-tree-slide-mode . prot/org-presentation))

(use-package orgit
  :after magit)

(provide 'setup-org)
#+end_src

*** ~setup-projectile.el~
:PROPERTIES:
:CUSTOM_ID: h:fcfa4636-70a0-4088-a021-7f6b2dc16208
:END:

#+begin_src emacs-lisp :tangle config/setup-projectile.el
;;; -*- lexical-binding: t; -*-
(use-package projectile                 ; Project management
  :init (projectile-mode)
  :bind-keymap ("C-c p" . projectile-command-map)
  :config
  ;; Remove dead projects when Emacs is idle
  (run-with-idle-timer 10 nil #'projectile-cleanup-known-projects)
  (setq
   ;; Custom compilation buffer name function
   compilation-buffer-name-function (lambda (mode) (concat "*" (downcase mode) ": " (projectile-project-name) "*"))
   projectile-completion-system 'ivy
   projectile-find-dir-includes-top-level t
   projectile-switch-project-action #'projectile-commander
   projectile-create-missing-test-files t
   projectile-mode-line '(:eval (format " Proj[%s]" (projectile-project-name))))
  (def-projectile-commander-method ?s
    "Open a *shell* buffer for the project"
    (projectile-run-eshell))
  (def-projectile-commander-method ?c
    "Run `compile' in the project"
    (projectile-compile-project nil)))

(use-package counsel-projectile         ; Ivy integration for Projectile
  :bind (:map projectile-command-map
              ("p" . counsel-projectile-switch-project)
              ("r" . counsel-projectile-rg))
  :init (counsel-projectile-mode))

(provide 'setup-projectile)
#+end_src

*** ~setup-search.el~
:PROPERTIES:
:CUSTOM_ID: h:25d09ed7-8a16-421d-94c7-2b1dfb96ace4
:END:

#+begin_src emacs-lisp :tangle config/setup-search.el
;;; -*- lexical-binding: t; -*-
;; Ignore directories during grep
(with-eval-after-load 'grep
  '(progn
     (add-to-list 'grep-find-ignored-directories "auto")
     (add-to-list 'grep-find-ignored-directories "elpa")))

;; Truncate lines during grep
(add-hook 'grep-mode-hook #'toggle-truncate-lines)
(use-package isearch
  :custom
  (search-whitespace-regexp ".*?")
  (isearch-lax-whitespace t)
  (isearch-regexp-lax-whitespace nil)
  :config
  (defun prot/isearch-mark-and-exit ()
    "Marks the current search string.  Can be used as a building
block for a more complex chain, such as to kill a region, or
place multiple cursors."
    (interactive)
    (push-mark isearch-other-end t 'activate)
    (setq deactivate-mark nil)
    (isearch-done))

  (defun stribb/isearch-region (&optional not-regexp no-recursive-edit)
    "If a region is active, make this the isearch default search
pattern."
    (interactive "P\np")
    (when (use-region-p)
      (let ((search (buffer-substring-no-properties
                     (region-beginning)
                     (region-end))))
        (message "stribb/ir: %s %d %d" search (region-beginning) (region-end))
        (setq deactivate-mark t)
        (isearch-yank-string search))))
  (advice-add 'isearch-forward-regexp :after 'stribb/isearch-region)
  (advice-add 'isearch-forward :after 'stribb/isearch-region)
  (advice-add 'isearch-backward-regexp :after 'stribb/isearch-region)
  (advice-add 'isearch-backward :after 'stribb/isearch-region)

  (defun contrib/isearchp-remove-failed-part-or-last-char ()
    "Remove failed part of search string, or last char if successful.
Do nothing if search string is empty to start with."
    (interactive)
    (if (equal isearch-string "")
        (isearch-update)
      (if isearch-success
          (isearch-delete-char)
        (while (isearch-fail-pos) (isearch-pop-state)))
      (isearch-update)))

  (defun contrib/isearch-done-opposite-end (&optional nopush edit)
    "End current search in the opposite side of the match.
Particularly useful when the match does not fall within the
confines of word boundaries (e.g. multiple words)."
    (interactive)
    (funcall #'isearch-done nopush edit)
    (when isearch-other-end (goto-char isearch-other-end)))
  :bind (("M-s M-o" . multi-occur)
         :map isearch-mode-map
         ("C-SPC" . prot/isearch-mark-and-exit)
         ("DEL" . contrib/isearchp-remove-failed-part-or-last-char)
         ("<C-return>" . contrib/isearch-done-opposite-end)))

(use-package anzu
  :ensure t
  :delight
  :custom
  (anzu-search-threshold 100)
  (anzu-replace-threshold nil)
  (anzu-deactivate-region nil)
  (anzu-replace-to-string-separator "")
  :config
  (global-anzu-mode 1)
  :bind (([remap isearch-query-replace] . anzu-isearch-query-replace)
         ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))
  ([remap query-replace] . anzu-query-replace)
  ([remap query-replace-regexp] . anzu-query-replace-regexp)
  ("M-s %" . anzu-query-replace-at-cursor))

(use-package swiper
  :after ivy
  :custom
  (swiper-action-recenter t)
  (swiper-goto-start-of-match t)
  (swiper-include-line-number-in-search t)
  :bind (("C-S-s" . swiper)
         ("M-s s" . swiper-multi)
         ("M-s w" . swiper-thing-at-point)
         :map swiper-map
         ("M-y" . yank)
         ("C-." . swiper-avy)))

(use-package wgrep                      ; Editable grep buffer
  :defer 2
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-change-readonly-file t))

(use-package visual-regexp              ; Regexp replace with in-buffer display
  :bind (("C-c s r" . vr/query-replace)
         ("C-c s R" . vr/replace)))

(provide 'setup-search)
#+end_src

*** ~setup-shells.el~
:PROPERTIES:
:CUSTOM_ID: h:fd536392-1477-450c-965a-80bbbd1e4d81
:END:
:PROPERTIES:

:END:

#+begin_src emacs-lisp :tangle config/setup-shells.el
;;; -*- lexical-binding: t; -*-
(use-package shell                 ; Specialized comint.el for running the shell
  :custom
                                        ;(ansi-color-for-comint-mode 'filter)
  (explicit-shell-file-name "zsh")
  (shell-file-name "zsh")
  :bind (("<f1>"      . shell)
         (:map shell-mode-map
               ("<tab>" . completion-at-point)))
  :config
  (unbind-key "C-c C-l" shell-mode-map)
  (bind-key "C-c C-l" #'counsel-shell-history shell-mode-map)

  (defun vde/comint-delchar-or-eof-or-kill-buffer (arg)
    "Restore window configuration if process is dead, otherwise delete ARG."
    (interactive "p")
    (if (null (get-buffer-process (current-buffer)))
        (vde/pop-window-configuration)
      (comint-delchar-or-maybe-eof arg)))

  (add-hook 'shell-mode-hook
            (lambda ()
              (bind-key "C-d" #'vde/comint-delchar-or-eof-or-kill-buffer
                        shell-mode-map)))
  )

(use-package eshell                     ; Emacs command shell
  :bind* ("C-x m t" . eshell-here)
  :config
  (defun eshell-here ()
    "Open EShell in the directory associated with the current buffer's file.
The EShell is renamed to match that directory to make multiple windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (name   (car (last (split-string parent "/" t)))))
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))))

  ;; Handy aliases
  (defalias 'ff 'find-file)

  (defun eshell/d ()
    "Open a dired instance of the current working directory."
    (dired "."))

  (defun eshell/gs (&rest args)
    (magit-status (pop args) nil)
    (eshell/echo))                      ; The echo command suppresses output

  (defun eshell/extract (file)
    "One universal command to extract FILE (for bz2, gz, rar, etc.)"
    (eshell-command-result (format "%s %s" (cond ((string-match-p ".*\.tar.bz2" file)
                                                  "tar xzf")
                                                 ((string-match-p ".*\.tar.gz" file)
                                                  "tar xzf")
                                                 ((string-match-p ".*\.bz2" file)
                                                  "bunzip2")
                                                 ((string-match-p ".*\.rar" file)
                                                  "unrar x")
                                                 ((string-match-p ".*\.gz" file)
                                                  "gunzip")
                                                 ((string-match-p ".*\.tar" file)
                                                  "tar xf")
                                                 ((string-match-p ".*\.tbz2" file)
                                                  "tar xjf")
                                                 ((string-match-p ".*\.tgz" file)
                                                  "tar xzf")
                                                 ((string-match-p ".*\.zip" file)
                                                  "unzip")
                                                 ((string-match-p ".*\.jar" file)
                                                  "unzip")
                                                 ((string-match-p ".*\.Z" file)
                                                  "uncompress")
                                                 (t
                                                  (error "Don't know how to extract %s" file)))
                                   file)))

  (add-hook
   'eshell-mode-hook
   (lambda ()
     (let ((ls (if (executable-find "exa") "exa" "ls")))
       (eshell/alias "ls" (concat ls " --color=always $*"))
       (eshell/alias "ll" (concat ls " --color=always -l $*"))
       (eshell/alias "l" (concat ls " --color=always -lah $*")))
     (eshell-smart-initialize)
     (eshell-dirs-initialize)
     (bind-keys :map eshell-mode-map
                ("C-c C-l"                . counsel-esh-history)
                ([remap eshell-pcomplete] . completion-at-point))))

  ;; Use system su/sudo
  (with-eval-after-load "em-unix"
    '(progn
       (unintern 'eshell/su nil)
       (unintern 'eshell/sudo nil)))

  (add-hook 'eshell-mode-hook #'with-editor-export-editor))

(use-package em-prompt                  ; EShell command prompts
  :defer 2
  :config
  (defun vde/eshell-quit-or-delete-char (arg)
    "Use C-d to either delete forward char or exit EShell."
    (interactive "p")
    (if (and (eolp) (looking-back eshell-prompt-regexp nil nil))
        (progn
          (eshell-life-is-too-much))
      (delete-char arg)))

  (add-hook 'eshell-mode-hook
            (lambda ()
              (bind-key "C-d"
                        #'vde/eshell-quit-or-delete-char eshell-mode-map))))

(use-package esh-mode                   ; EShell UI customizations
  :ensure eshell
  :config (setq eshell-scroll-to-bottom-on-input 'all))

(use-package em-smart
  :ensure eshell)
(use-package em-dirs
  :ensure eshell)

(use-package em-cmpl                    ; EShell TAB completion
  :ensure eshell
  :config
  (add-hook 'eshell-mode-hook #'eshell-cmpl-initialize)

  (add-to-list 'eshell-command-completions-alist
               '("gunzip" "gz\\'"))
  (add-to-list 'eshell-command-completions-alist
               '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'")))

(use-package em-hist                    ; EShell History management
  :ensure eshell
  :config (setq eshell-hist-ignoredups t))

(use-package em-term                    ; Handle visual commands in EShell
  :ensure eshell
  :config
  (add-to-list 'eshell-visual-commands "ssh")
  (add-to-list 'eshell-visual-commands "htop")
  (add-to-list 'eshell-visual-commands "top")
  (add-to-list 'eshell-visual-commands "tail")
  (add-to-list 'eshell-visual-commands "npm")
  (add-to-list 'eshell-visual-commands "ncdu"))

(use-package em-banner
  :ensure eshell
  :config
  (setq eshell-banner-message "
  Welcome to the Emacs

                         _/                  _/  _/
      _/_/      _/_/_/  _/_/_/      _/_/    _/  _/
   _/_/_/_/  _/_/      _/    _/  _/_/_/_/  _/  _/
  _/            _/_/  _/    _/  _/        _/  _/
   _/_/_/  _/_/_/    _/    _/    _/_/_/  _/  _/

"))

(use-package fish-completion            ; Add Fish completion to EShell
  :defer 2
  :when (executable-find "fish")
  :config (add-hook 'eshell-mode-hook #'fish-completion-mode))

(use-package eshell-prompt-extras
  :defer 1
  :custom
  (eshell-highlight-prompt nil)
  (eshell-prompt-function 'vde-theme-lambda)
  :config
  (defun vde-kubernetes-current-context ()
    "Return the current context"
    (if (not (string-empty-p (getenv "KUBECONFIG")))
        (epe-trim-newline (shell-command-to-string (concat
                                                    "env KUBECONFIG="
                                                    (getenv "KUBECONFIG")
                                                    " kubectl config current-context")))
      (epe-trim-newline (shell-command-to-string "kubectl config current-context"))))
  (defun vde-kubernetes-p ()
    "If you have kubectl install and a config set,
using either KUBECONFIG or ~/.kube/config"
    (and (eshell-search-path "kubectl")
         (not (string-empty-p (vde-kubernetes-current-context)))
         (not (string-match-p "error: current-context is not set" (vde-kubernetes-current-context)))))
  ;; From epe-theme-lambda
  (defun vde-theme-lambda ()
    "A eshell-prompt lambda theme."
    (setq eshell-prompt-regexp "^[^#\nλ]*[#λ] ")
    (concat
     (when (epe-remote-p)
       (epe-colorize-with-face
        (concat (epe-remote-user) "@" (epe-remote-host) " ")
        'epe-remote-face))
     (when (and epe-show-python-info (bound-and-true-p venv-current-name))
       (epe-colorize-with-face (concat "(" venv-current-name ") ") 'epe-venv-face))
     (let ((f (cond ((eq epe-path-style 'fish) 'epe-fish-path)
                    ((eq epe-path-style 'single) 'epe-abbrev-dir-name)
                    ((eq epe-path-style 'full) 'abbreviate-file-name))))
       (epe-colorize-with-face (funcall f (eshell/pwd)) 'epe-dir-face))
     (when (epe-git-p)
       (concat
        (epe-colorize-with-face ":" 'epe-dir-face)
        (epe-colorize-with-face
         (concat (epe-git-branch)
                 (epe-git-dirty)
                 (epe-git-untracked)
                 (let ((unpushed (epe-git-unpushed-number)))
                   (unless (= unpushed 0)
                     (concat ":" (number-to-string unpushed)))))
         'epe-git-face)))
     (when (vde-kubernetes-p)
       (concat (epe-colorize-with-face " (" 'epe-dir-face)
               (epe-colorize-with-face (vde-kubernetes-current-context) 'epe-dir-face)
               (epe-colorize-with-face ")" 'epe-dir-face)))
     (epe-colorize-with-face " λ" 'epe-symbol-face)
     (epe-colorize-with-face (if (= (user-uid) 0) "#" "") 'epe-sudo-symbol-face)
     " ")))

(use-package esh-autosuggest
  :defer 1
  :hook (eshell-mode . esh-autosuggest-mode))

(use-package xterm-color
  :init
  (setq comint-output-filter-functions
        (remove 'ansi-color-process-output comint-output-filter-functions))
  (add-hook 'shell-mode-hook
            (lambda ()
              ;; Disable font-locking in this buffer to improve performance
              (font-lock-mode -1)
              ;; Prevent font-locking from being re-enabled in this buffer
              (make-local-variable 'font-lock-function)
              (setq font-lock-function (lambda (_) nil))
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
  (add-hook 'eshell-before-prompt-hook
            (lambda ()
              (setenv "TERM" "xterm-256color")
              (setq xterm-color-preserve-properties t)))
  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
  (setq compilation-environment '("TERM=xterm-256color"))
  (add-hook 'compilation-start-hook
            (lambda (proc)
              ;; We need to differentiate between compilation-mode buffers
              ;; and running as part of comint (which at this point we assume
              ;; has been configured separately for xterm-color)
              (when (eq (process-filter proc) 'compilation-filter)
                ;; This is a process associated with a compilation-mode buffer.
                ;; We may call `xterm-color-filter' before its own filter function.
                (set-process-filter
                 proc
                 (lambda (proc string)
                   (funcall 'compilation-filter proc
                            (xterm-color-filter string))))))))

;; for fish in ansi-term
(add-hook 'term-mode-hook 'toggle-truncate-lines)

(provide 'setup-shells)
#+end_src

*** ~setup-style.el~
:PROPERTIES:
:CUSTOM_ID: h:8ad2ded5-f9e0-4973-9c6e-99efd37aaad4
:END:

#+begin_src emacs-lisp :tangle config/setup-style.el
;;; -*- lexical-binding: t; -*-
;;; ¯\_(ツ)_/¯
;;; - Iosevka (https://github.com/be5invis/Iosevka)
;;; - Fira Sans (https://github.com/mozilla/Fira/)
(defconst font-height 130)
;; Middle/Near East: שלום, السّلام عليكم
(when (member "Noto Sans Arabic" (font-family-list))
  (set-fontset-font t 'arabic "Noto Sans Arabic"))
(when (member "Noto Sans Hebrew" (font-family-list))
  (set-fontset-font t 'arabic "Noto Sans Hebrew"))

;; Africa: ሠላም
(when (member "Noto Sans Ethiopic" (font-family-list))
  (set-fontset-font t 'ethiopic "Noto Sans Ethiopic"))

(set-face-attribute 'default nil
                    :family "Ubuntu Mono"
                    :height font-height)
(set-face-attribute 'variable-pitch nil
                    :family "Ubuntu Sans"
                    :height font-height
                    :weight 'regular)

;;; Utilities and key bindings
(defun mu-reset-fonts ()
  "Reset fonts to my preferences."
  (interactive)
  (set-face-attribute 'default nil
                      :family "Ubuntu Mono"
                      :height font-height)
  (set-face-attribute 'variable-pitch nil
                      :family "Ubuntu Sans"
                      :height font-height
                      :weight 'regular))

(bind-key "C-c f r" #'mu-reset-fonts)

;;; Interface
(use-package frame                      ; Frames
  :bind ("C-c w f" . toggle-frame-fullscreen)
  :init
  ;; Kill `suspend-frame'
  (unbind-key "C-x C-z")
  :config (add-to-list 'initial-frame-alist '(fullscreen . maximized)))

(use-package emacs
  :custom
  (use-file-dialog nil)
  (use-dialog-box nil)
  (echo-keystrokes 0.1) ; Faster echo keystrokes
  (line-number-display-limit-width 10000) ;; Avoid showing ?? in the mode line when we have long lines.
  (display-time-world-list '(("Europe/London" "London")
                             ("Europe/Paris" "Paris")
                             ("America/New_York" "Boston")
                             ("America/Los_Angeles" "San-Francisco")
                             ("Asia/Calcutta" "Bangalore")
                             ("Australia/Brisbane" "Brisbane")))
  :config
  (line-number-mode 1)
  (column-number-mode 1)
  (global-hl-line-mode 1)
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "C-x C-z"))
  (global-unset-key (kbd "C-h h")))

;;; Theme
(setq custom-safe-themes t)    ; Treat themes as safe

(use-package doom-themes
  :config
  (load-theme 'doom-one-light t)
  (doom-themes-visual-bell-config)
  (doom-themes-org-config))

(use-package solaire-mode
  :config
  (setq solaire-mode-remap-modeline nil)
  (add-hook 'after-change-major-mode-hook #'turn-on-solaire-mode)
  (add-hook 'after-revert-hook #'turn-on-solaire-mode)
  (add-hook 'minibuffer-setup-hook #'solaire-mode-in-minibuffer)
  (add-hook 'ediff-prepare-buffer-hook #'solaire-mode)
  (advice-add #'persp-load-state-from-file :after #'solaire-mode-restore-persp-mode-buffers))

;; Show buffer position percentage starting from top
(setq mode-line-percent-position '(-3 "%o"))
(defvar mu-eyebrowse-mode-line
  '(:propertize
    (:eval
     (when (bound-and-true-p eyebrowse-mode)
       (let* ((num (eyebrowse--get 'current-slot))
              (tag (when num
                     (nth 2 (assoc num (eyebrowse--get 'window-configs)))))
              (str (concat
                    " "
                    (if (and tag (< 0 (length tag)))
                        tag
                      (when num (int-to-string num)))
                    " ")))
         str)))
    face (:background "#81a2be" :foreground "#373b41"))
  "Mode line format for Eyebrowse.")

(put 'mu-eyebrowse-mode-line 'risky-local-variable t)

(setq-default mode-line-format
              '("%e"
                mu-eyebrowse-mode-line
                mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                mode-line-frame-identification
                mode-line-buffer-identification " " mode-line-position
                (vc-mode vc-mode)
                (multiple-cursors-mode mc/mode-line)
                " " mode-line-modes
                mode-line-end-spaces))

(defmacro rename-modeline (package-name mode new-name)
  "Rename PACKAGE-NAME with MODE into NEW-NAME in the mode line."
  `(eval-after-load ,package-name
     '(defadvice ,mode (after rename-modeline activate)
        (setq mode-name ,new-name))))

(defun generic-term-init ()
  (visual-line-mode -1)
  (setq-local global-hl-line-mode nil)
  (setq-local scroll-margin 0))

(add-hook 'term-mode-hook #'generic-term-init)
(add-hook 'shell-mode-hook #'generic-term-init)
(add-hook 'eshell-mode-hook #'generic-term-init)

(use-package moody
  :config
  (setq x-underline-at-descent-line t)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode))

(use-package minions                    ; A minor-mode menu for the mode line
  :init (minions-mode)
  :config
  (setq
   minions-mode-line-lighter "λ="
   minions-direct '(flycheck-mode)))

(setq-default indicate-buffer-boundaries 'left)
(setq-default indicate-empty-lines +1)

(use-package highlight
  :ensure t
  :pin melpa)

(use-package highlight-numbers
  :hook (prog-mode . highlight-numbers-mode))

(use-package symbol-overlay
  :defer 4
  :bind
  ("M-s h ." . symbol-overlay-put)
  ("M-s h n" . symbol-overlay-jump-next)
  ("M-s h p" . symbol-overlay-jump-prev)
  :hook (prog-mode . symbol-overlay-mode)
  :config
  (setq symbol-overlay-idle-time 0.2))

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

(use-package rainbow-mode
  :commands rainbow-mode
  :hook (prog-mode . rainbow-mode))

(use-package visual-fill-column
  :commands visual-fill-column-mode)

(use-package hide-mode-line-mode
  :commands hide-mode-line-mode)

(defun set-light-theme ()
  "Set the light theme with some customization if needed."
  (interactive)
  (load-theme 'doom-one-light t))

(defun set-dark-theme ()
  "Set the dark theme with some customization if needed."
  (interactive)
  (load-theme 'doom-one t))

(defun theme-switcher ()
  (interactive)
  (let ((current-hour (string-to-number (format-time-string "%H"))))
    (if (and (> current-hour 6) (< current-hour 20))
        (set-light-theme)
      (set-dark-theme))))

;; Run at every 3600 seconds, after 0s delay
;; (run-with-timer 0 3600 'theme-switcher)

(provide 'setup-style)
#+end_src

*** ~setup-vcs.el~
:PROPERTIES:
:CUSTOM_ID: h:225b08ad-d82e-46a1-9695-9d0d9ed2c17f
:END:

#+begin_src emacs-lisp :tangle config/setup-vcs.el
;;; -*- lexical-binding: t; -*-
(use-package vc-hooks                   ; Simple version control
  :bind (("S-<f5>" . vc-revert)
         ("C-c v r" . vc-refresh-state))
  :config
  ;; Always follow symlinks to files in VCS repos
  (setq vc-follow-symlinks t))

(use-package magit                      ; The best Git client out there
  :bind (("C-c v c" . magit-clone)
         ("C-c v C" . magit-checkout)
         ("C-c v d" . magit-dispatch-popup)
         ("C-c v g" . magit-blame)
         ("C-c v l" . magit-log-buffer-file)
         ("C-c v p" . magit-pull)
         ("C-c v v" . magit-status))
  :config
  (setq
   magit-save-repository-buffers 'dontask
   magit-refs-show-commit-count 'all
   magit-branch-prefer-remote-upstream '("master")
   magit-display-buffer-function #'magit-display-buffer-traditional
   magit-completing-read-function 'ivy-completing-read
   )

  (magit-define-popup-option 'magit-rebase-popup
    ?S "Sign using gpg" "--gpg-sign=" #'magit-read-gpg-secret-key)
  (magit-define-popup-switch 'magit-log-popup
    ?m "Omit merge commits" "--no-merges")

  ;; Hide "Recent Commits"
  (magit-add-section-hook 'magit-status-sections-hook
                          'magit-insert-unpushed-to-upstream
                          'magit-insert-unpushed-to-upstream-or-recent
                          'replace)

  (use-package magit-files
    :config
    (global-magit-file-mode))

  ;; Show refined hunks during diffs
  (set-default 'magit-diff-refine-hunk t)

  (add-hook 'projectile-switch-project-hook
            #'mu-magit-set-repo-dirs-from-projectile)

  ;; Refresh `magit-status' after saving a buffer
  (add-hook 'after-save-hook #'magit-after-save-refresh-status)

  ;; Free C-c C-w for Eyebrowse
  (unbind-key "C-c C-w" git-commit-mode-map)  )

(use-package magit-repos
  :after magit
  :commands magit-list-repositories
  :config
  (setq magit-repository-directories
        '(("~/src" . 3))))

(use-package git-commit                 ; Git commit message mode
  :defer 2
  :init (global-git-commit-mode)
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))
  (remove-hook 'git-commit-finish-query-functions
               #'git-commit-check-style-conventions))

(use-package gitconfig-mode             ; Git configuration mode
  :defer 2)

(use-package gitignore-mode             ; .gitignore mode
  :defer 2)

(use-package gitattributes-mode         ; Git attributes mode
  :defer 2)

(use-package dired-git-info
  :bind (:map dired-mode-map
              (")" . dired-git-info-mode))
  :defer 2)

(use-package ediff
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo))

(defun git-blame-line ()
  "Runs `git blame` on the current line and
   adds the commit id to the kill ring"
  (interactive)
  (let* ((line-number (save-excursion
                        (goto-char (point-at-bol))
                        (+ 1 (count-lines 1 (point)))))
         (line-arg (format "%d,%d" line-number line-number))
         (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
    (call-process "git" nil commit-buf nil
                  "blame" (buffer-file-name) "-L" line-arg)
    (let* ((commit-id (with-current-buffer commit-buf
                        (buffer-substring 1 9)))
           (log-buf (generate-new-buffer "*git-blame-line-log*")))
      (kill-new commit-id)
      (call-process "git" nil log-buf nil
                    "log" "-1" "--pretty=%h   %an   %s" commit-id)
      (with-current-buffer log-buf
        (message "Line %d: %s" line-number (buffer-string)))
      (kill-buffer log-buf))
    (kill-buffer commit-buf)))

(provide 'setup-vcs)
#+end_src

*** ~setup-vde-mode.el~
:PROPERTIES:
:CUSTOM_ID: h:19bf468b-1fcd-469f-9c25-dee2e200f7e7
:END:

#+begin_src emacs-lisp :tangle lisp/00-vde-mode.el
;;; -*- lexical-binding: t; -*-
(defvar vde-special-keymap-prefix (kbd "C-x m")
  "`vde-mode' keymap prefix.
Overrides the default binding for `compose-mail'.")

(defvar vde-mode-special-map (make-sparse-keymap)
  "Special keymap for `vde-mode' whose bindings begin with
`vde-special-keymap-prefix'.")
(fset 'vde-mode-special-map vde-mode-special-map)

(defvar vde-mode-map (let ((map (make-sparse-keymap)))
                       (define-key map vde-special-keymap-prefix 'vde-mode-special-map)
                       map)
  "Keymap for `vde-mode'.")

;;;###autoload
(define-minor-mode vde-mode
  "A minor mode so that my key settings override annoying major modes."
  ;; If init-value is not set to t, this mode does not get enabled in
  ;; `fundamental-mode' buffers even after doing \"(global-vde-mode 1)\".
  ;; More info: http://emacs.stackexchange.com/q/16693/115
  :init-value t
  :lighter    " μ"
  :keymap     vde-mode-map)

;;;###autoload
(define-globalized-minor-mode global-vde-mode vde-mode vde-mode)

;; https://github.com/jwiegley/use-package/blob/master/bind-key.el
;; The keymaps in `emulation-mode-map-alists' take precedence over
;; `minor-mode-map-alist'
(add-to-list 'emulation-mode-map-alists `((vde-mode . ,vde-mode-map)))

;; Turn off the minor mode in the minibuffer
(defun turn-off-vde-mode ()
  "Turn off vde-mode."
  (vde-mode -1))
(add-hook 'minibuffer-setup-hook #'turn-off-vde-mode)

(defmacro bind-to-vde-map (key fn)
  "Bind a function to the `vde-mode-special-map'.
USAGE: (bind-to-vde-map \"f\" #'full-screen-center)."
  `(define-key vde-mode-special-map (kbd ,key) ,fn))

;; http://emacs.stackexchange.com/a/12906/115
(defun unbind-from-vde-map (key)
  "Unbind a function from the `vde-mode-map'
USAGE: (unbind-from-vde-map \"C-x m f\")
"
  (interactive "Unset key from vde-mode-map: ")
  (define-key vde-mode-map (kbd (key-description key)) nil)
  (message "%s" (format "Unbound %s key from the %s."
                        (propertize (key-description key)
                                    'face 'font-lock-function-name-face)
                        (propertize "vde-mode-map"
                                    'face 'font-lock-function-name-face))))

(provide 'setup-vde-mode)
;; Minor mode tutorial: http://nullprogram.com/blog/2013/02/06/
#+end_src

*** ~setup-web.el~
:PROPERTIES:
:CUSTOM_ID: h:cb940809-e0af-4e9f-9c09-71c95b6cb472
:END:

#+begin_src emacs-lisp :tangle config/setup-web.el
;;; -*- lexical-binding: t; -*-
(use-package web-mode
  :mode
  ("\\.html\\'" . web-mode)
  ("\\.phtml\\'" . web-mode)
  ("\\.[agj]sp\\'" . web-mode)
  ("\\.as[cp]x\\'" . web-mode)
  ("\\.erb\\'" . web-mode)
  ("\\.mustache\\'" . web-mode)
  ("\\.djhtml\\'" . web-mode)
  ("\\.jsp\\'" . web-mode)
  ("\\.eex\\'" . web-mode)
  ("\\.tsx\\'" . web-mode)
  :config
  (setq web-mode-attr-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-indent-style 2)
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-sql-indent-offset 2)
  (eval-after-load 'smartparens
    (lambda ()
      (setq web-mode-enable-auto-pairing nil)
      (sp-with-modes '(web-mode)
        (sp-local-pair "%" "%"
                       :unless '(sp-in-string-p)
                       :post-handlers '(((lambda (&rest _ignored)
                                           (just-one-space)
                                           (save-excursion (insert " ")))
                                         "SPC" "=" "#")))
        (sp-local-tag "%" "<% "  " %>")
        (sp-local-tag "=" "<%= " " %>")
        (sp-local-tag "#" "<%# " " %>")))))

(provide 'setup-web)
#+end_src

*** ~setup-windows.el~
:PROPERTIES:
:CUSTOM_ID: h:c53d2549-1bd0-430e-a7b1-cd981d994b7a
:END:

#+begin_src emacs-lisp :tangle config/setup-windows.el
;;; -*- lexical-binding: t; -*-

;;;###autoload
(defun vde/window-split-toggle ()
  "Toggle between horizontal and vertical split with two windows."
  (interactive)
  (if (> (length (window-list)) 2)
      (error "Can't toggle with more than 2 windows!")
    (let ((func (if (window-full-height-p)
                    #'split-window-vertically
                  #'split-window-horizontally)))
      (delete-other-windows)
      (funcall func)
      (save-selected-window
        (other-window 1)
        (switch-to-buffer (other-buffer))))))

(bind-key "C-c w t" #'vde/window-split-toggle)

(defvar vde/saved-window-configuration nil)

(defun vde/save-wins-then-call (func &optional args)
  "Save current window configuration, then call FUNC optionally with ARGS."
  (interactive)
  (push (current-window-configuration) vde/saved-window-configuration)
  (cond
   ;; We have arguments for the function
   ((bound-and-true-p args) (funcall func args))
   ;; The function expects exactly one argument, and we want it to be nil
   ((equal args "nil") (funcall func nil))
   ;; The function does not expect arguments
   (t (funcall func))))

(defun vde/restore-window-configuration (config)
  "Kill current buffer and restore the window configuration in CONFIG."
  (interactive)
  (kill-this-buffer)
  (set-window-configuration config))

(defun vde/pop-window-configuration ()
  "Restore the previous window configuration and clear current window."
  (interactive)
  (let ((config (pop vde/saved-window-configuration)))
    (if config
        (vde/restore-window-configuration config)
      (if (> (length (window-list)) 1)
          (delete-window)
        (bury-buffer)))))

(use-package eyebrowse                  ; Easy workspaces creation and switching
  :init (eyebrowse-mode t)
  :config
  (setq
   eyebrowse-mode-line-separator " "
   eyebrowse-mode-line-style 'always
   eyebrowse-new-workspace t
   eyebrowse-wrap-around t))

(use-package ace-window                 ; Better movements between windows
  :custom
  (aw-keys '(?a ?u ?i ?e ?, ?c ?t ?r ?m))
  (aw-scope 'frame)
  (aw-dispatch-always t)
  (aw-dispatch-alist
   '((?s aw-swap-window "Swap Windows")
     (?2 aw-split-window-vert "Split Window Vertically")
     (?3 aw-split-window-horz "Split Window Horizontally")
     (?? aw-show-dispatch-help)))
  (aw-minibuffer-flag t)
  (aw-ignore-current nil)
  (aw-display-mode-overlay t)
  (aw-background t)
  :bind (("C-x o"   . ace-window)
         ("C-c w w" . ace-window)
         ("C-c w s" . ace-swap-window)))

(use-package windmove
  :bind (("M-<left>" . windmove-left)
         ("M-<down>" . windmove-down)
         ("M-<up>" . windmove-up)
         ("M-<right>" . windmove-right)))

(provide 'setup-windows)
#+end_src

* External libraries
:PROPERTIES:
:CUSTOM_ID: h:96ce2856-182e-42c8-a8b3-418c38124dcc
:END:

** ~use-package-list.el~
:PROPERTIES:
:CUSTOM_ID: h:bd8804a0-df0e-4aca-b748-429ea9402cd6
:END:

#+begin_src emacs-lisp :tangle lisp/use-package-list.el
;;; use-package-list.el --- List use-package declarations in config file

;; Copyright (C) 2017 Matthew Bauer

;; Author: Matthew Bauer <mjbauer95@gmail.com>

;; This file is NOT part of GNU Emacs.

;;; Commentary:

;; ‘ensure’ packages at compile time.

;;; Code:

(require 'json)
(require 'use-package)
(require 'package)
(eval-when-compile
  (require 'cl))

(defun use-package-list (script)
  "Count use-package declarations listed in SCRIPT."

  (defvar use-package-list--is-running t)
  (lexical-let ((use-package-verbose t)
                (use-package-debug t)
                (use-package-always-ensure nil)
                (use-package-always-defer t)
                (use-package-list--packages nil)
                (use-package-ensure-function 'ignore))
    (advice-add 'use-package
                :before (lambda (name &rest args)
                          (unless (or (and (member :disabled args)
                                           (plist-get args :disabled))
                                      (and (member :ensure args)
                                           (not (plist-get args :ensure)))
                                      (and (not (member :ensure args))
                                           (package-built-in-p name)))
                            (when (and (member :ensure args)
                                       (not (eq (plist-get args :ensure) t))
                                       (symbolp (plist-get args :ensure)))
                              (setq name (plist-get args :ensure)))
                            (add-to-list 'use-package-list--packages name))))

    (advice-add 'use-package-handler/:defer
                :around (lambda (x name keyword arg rest state)
                          (let ((body (use-package-process-keywords name rest
                                        (plist-put state :deferred t)))
                                (name-string (use-package-as-string name)))
                            (dolist (command
                                     (delete-dups (plist-get state :commands)))
                              (fset command (lambda (&rest args))))
                            body)))

    (advice-add 'use-package-load-name :override #'ignore)

    (load script nil nil t)

    (princ (json-encode use-package-list--packages))

    use-package-list--packages))

(provide 'use-package-list)
;;; use-package-list.el ends here
#+end_src


** ~gotest-ui.el~
:PROPERTIES:
:CUSTOM_ID: h:a94b8ba9-2d74-4fb3-a43a-58f4cd6e5141
:END:

From [[https://github.com/antifuchs/gotest-ui-mode/][antifuchs/gotest-ui-mode]].

#+begin_src emacs-lisp :tangle lisp/gotest-ui.el
;;; gotest-ui.el --- Major mode for running go test -json

;; Copyright 2018 Andreas Fuchs
;; Authors: Andreas Fuchs <asf@boinkor.net>

;; URL: https://github.com/antifuchs/gotest-ui-mode
;; Created: Feb 18, 2018
;; Keywords: languages go
;; Version: 0.1.0
;; Package-Requires: ((emacs "25") (s "1.12.0") (gotest "0.14.0"))

;; This file is not a part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3.0, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software
;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

;;; Commentary:

;;  Provides support for running go tests with a nice user interface
;;  that allows folding away output, highlighting failing tests.

;;; Code:

(eval-when-compile
  (require 'cl))

(require 'subr-x)
(require 'ewoc)
(require 'json)
(require 'compile)

(defgroup gotest-ui nil
  "The go test runner."
  :group 'tools)

(defface gotest-ui-pass-face '((t :foreground "green"))
  "Face for displaying the status of a passing test."
  :group 'gotest-ui)

(defface gotest-ui-skip-face '((t :foreground "grey"))
  "Face for displaying the status of a skipped test."
  :group 'gotest-ui)

(defface gotest-ui-fail-face '((t :foreground "pink" :weight bold))
  "Face for displaying the status of a failed test."
  :group 'gotest-ui)

(defface gotest-ui-link-face '((t :foreground "white" :weight bold))
  "Face for displaying links to go source files."
  :group 'gotest-ui)

(defcustom gotest-ui-expand-test-statuses '(fail)
  "Statuses to expand test cases for.
Whenever a test enters this state, it is automatically expanded."
  :group 'gotest-ui)

(defcustom gotest-ui-test-binary '("go")
  "Command list used to invoke the `go' binary."
  :group 'gotest-ui)

(defcustom gotest-ui-test-args '("test" "-json")
  "Argument list used to run tests with JSON output."
  :group 'gotest-ui)

(defcustom gotest-ui-additional-test-args '()
  "Additional args to pass to `go test'."
  :group 'gotest-ui)

;;;; Data model:

(defstruct (gotest-ui-section :named
                              (:constructor gotest-ui-section-create)
                              (:type vector)
                              (:predicate gotest-ui-section-p))
  title tests node)

;;; `gotest-ui-thing' is a thing that can be under test: a
;;; package, or a single test.

(defstruct gotest-ui-thing
  (name)
  (node)
  (expanded-p)
  (status)
  (buffer)    ; the buffer containing this test's output
  (elapsed)   ; a floating-point amount of seconds
  )

;;; `gotest-ui-test' is a single test. It contains a status and
;;; output.
(defstruct (gotest-ui-test (:include gotest-ui-thing)
                           (:constructor gotest-ui--make-test-1))
  (package)
  (reason))

(defun gotest-ui-test->= (test1 test2)
  "Returns true if TEST1's name sorts greater than TEST2's."
  (let ((pkg1 (gotest-ui-test-package test1))
        (pkg2 (gotest-ui-test-package test2))
        (name1 (or (gotest-ui-thing-name test1) ""))
        (name2 (or (gotest-ui-thing-name test2) "")))
    (if (string= pkg1 pkg2)
        (string> name1 name2)
      (string> pkg1 pkg2))))

(defstruct (gotest-ui-status (:constructor gotest-ui--make-status-1))
  (state)
  (cmdline)
  (dir)
  (output)
  (node))

(cl-defun gotest-ui--make-status (ewoc cmdline dir)
  (let ((status (gotest-ui--make-status-1 :state 'run :cmdline (s-join " " cmdline) :dir dir)))
    (let ((node (ewoc-enter-first ewoc status)))
      (setf (gotest-ui-status-node status) node))
    status))

(cl-defun gotest-ui--make-test (ewoc &rest args &key status package name &allow-other-keys)
  (apply #'gotest-ui--make-test-1 :status (or status "run") args))

;;; Data manipulation routines:

(cl-defun gotest-ui-ensure-test (ewoc package-name base-name &key (status 'run))
  (let* ((test-name (format "%s.%s" package-name base-name))
         (test (gethash test-name gotest-ui--tests)))
    (if test
        test
      (setf (gethash test-name gotest-ui--tests)
            (gotest-ui--make-test ewoc :name base-name :package package-name :status status)))))

(defun gotest-ui-update-status (new-state)
  (setf (gotest-ui-status-state gotest-ui--status) new-state)
  (ewoc-invalidate gotest-ui--ewoc (gotest-ui-status-node gotest-ui--status)))

(defun gotest-ui-update-status-output (new-output)
  (setf (gotest-ui-status-output gotest-ui--status) new-output)
  (ewoc-invalidate gotest-ui--ewoc (gotest-ui-status-node gotest-ui--status)))

(defun gotest-ui-ensure-output-buffer (thing)
  (unless (gotest-ui-thing-buffer thing)
    (with-current-buffer
        (setf (gotest-ui-thing-buffer thing)
              (generate-new-buffer (format " *%s" (gotest-ui-thing-name thing))))
      (setq-local gotest-ui-parse-marker (point-min-marker))
      (setq-local gotest-ui-insertion-marker (point-min-marker))
      (set-marker-insertion-type gotest-ui-insertion-marker t)))
  (gotest-ui-thing-buffer thing))

(defun gotest-ui-mouse-open-file (event)
  "In gotest-ui mode, open the file/line reference in another window."
  (interactive "e")
  (let ((window (posn-window (event-end event)))
        (pos (posn-point (event-end event)))
        file line)
    (if (not (windowp window))
        (error "No file chosen"))
    (with-current-buffer (window-buffer window)
      (goto-char pos)
      (setq file (gotest-ui-get-file-for-visit))
      (setq line (gotest-ui-get-line-for-visit)))
    (unless (file-exists-p file)
      (error "Could not open %s:%d" file line))
    (with-current-buffer (find-file-other-window file)
      (goto-char (point-min))
      (forward-line (1- line)))))

(defun gotest-ui-get-file-for-visit ()
  (get-text-property (point) 'gotest-ui-file))

(defun gotest-ui-get-line-for-visit ()
  (string-to-number (get-text-property (point) 'gotest-ui-line)))

(defun gotest-ui-file-from-gopath (package file-basename)
  (if (or (file-name-absolute-p file-basename)
          (string-match-p "/" file-basename))
      file-basename
    (let ((gopath (or (getenv "GOPATH")
                      (expand-file-name "~/go"))))
      (expand-file-name (concat gopath "/src/" package "/" file-basename)))))

(defvar gotest-ui-click-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-2] 'gotest-ui-mouse-open-file)
    map))

(defun gotest-ui-ensure-parsed (thing)
  (save-excursion
    (goto-char gotest-ui-parse-marker)
    (while (re-search-forward "\\([^ \t]+\\.go\\):\\([0-9]+\\)" gotest-ui-insertion-marker t)
      (let* ((file-basename (match-string 1))
             (file (gotest-ui-file-from-gopath (gotest-ui-test-package thing) file-basename)))
        (set-text-properties (match-beginning 0) (match-end 0)
                             `(face gotest-ui-link-face
                                    gotest-ui-file ,file
                                    gotest-ui-line ,(match-string 2)
                                    keymap ,gotest-ui-click-map
                                    follow-link t
                                    ))))
    (set-marker gotest-ui-parse-marker gotest-ui-insertion-marker)))

(defun gotest-ui-update-thing-output (thing output)
  (with-current-buffer (gotest-ui-ensure-output-buffer thing)
    (goto-char gotest-ui-insertion-marker)
    (let ((overwrites (split-string output "\r")))
      (insert (car overwrites))
      (dolist (segment (cdr overwrites))
        (let ((delete-to (point)))
          (forward-line 0)
          (delete-region (point) delete-to))
        (insert segment)))
    (set-marker gotest-ui-insertion-marker (point))
    (gotest-ui-ensure-parsed thing)))

;; TODO: clean up buffers on kill

;;;; Mode definition

(defvar gotest-ui-mode-map
  (let ((m (make-sparse-keymap)))
    (suppress-keymap m)
    ;; key bindings go here
    (define-key m (kbd "TAB") 'gotest-ui-toggle-expanded)
    (define-key m (kbd "g") 'gotest-ui-rerun)
    m))

(define-derived-mode gotest-ui-mode special-mode "go test UI"
  "Major mode for running go test with JSON output."
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq-local line-move-visual t)
  (setq show-trailing-whitespace nil)
  (setq list-buffers-directory default-directory)
  (make-local-variable 'text-property-default-nonsticky)
  (push (cons 'keymap t) text-property-default-nonsticky))


(defun gotest-ui--clear-buffer (buffer)
  (let ((dir default-directory))
    (with-current-buffer buffer
      (when (buffer-live-p gotest-ui--process-buffer)
        (kill-buffer gotest-ui--process-buffer))
      (kill-all-local-variables)
      (let  ((buffer-read-only nil))
        (erase-buffer))
      (buffer-disable-undo)
      (setq-local default-directory dir))))

(defun gotest-ui--setup-buffer (buffer name cmdline dir)
  (setq-local default-directory dir)
  (setq gotest-ui--cmdline cmdline
        gotest-ui--dir dir)
  (let ((ewoc (ewoc-create 'gotest-ui--pp-test nil nil t))
        (tests (make-hash-table :test #'equal)))
    (setq gotest-ui--tests tests)
    (setq gotest-ui--ewoc ewoc)
    ;; Drop in the first few ewoc nodes:
    (setq gotest-ui--status (gotest-ui--make-status ewoc cmdline dir))
    (gotest-ui-add-section gotest-ui--ewoc 'fail "Failed Tests:")
    (gotest-ui-add-section gotest-ui--ewoc 'run "Currently Running:")
    (gotest-ui-add-section gotest-ui--ewoc 'skip "Skipped:")
    (gotest-ui-add-section gotest-ui--ewoc 'pass "Passed Tests:"))
  ;; Set up the other buffers:
  (setq gotest-ui--stderr-process-buffer (generate-new-buffer (format " *%s (stderr)" name)))
  (with-current-buffer gotest-ui--stderr-process-buffer
    (setq gotest-ui--ui-buffer buffer))
  (setq gotest-ui--process-buffer (generate-new-buffer (format " *%s" name)))
  (with-current-buffer gotest-ui--process-buffer
    (setq gotest-ui--ui-buffer buffer)))

(defun gotest-ui-add-section (ewoc state name)
  (let ((section (gotest-ui-section-create :title name :tests (list nil))))
    (setf (gotest-ui-section-node section)
          (ewoc-enter-last ewoc section))
    (push (cons state section) gotest-ui--section-alist)))

(defun gotest-ui-sort-test-into-section (test previous-state)
  (let (invalidate-nodes)
    (when-let ((previous-section* (and previous-state
                                       (assoc previous-state gotest-ui--section-alist))))
      (let ((previous-section (cdr previous-section*)))
        (setf (gotest-ui-section-tests previous-section)
              (delete test (gotest-ui-section-tests previous-section)))
        (when (null (cdr (gotest-ui-section-tests previous-section)))
          (push (gotest-ui-section-node previous-section) invalidate-nodes))))
    ;; Drop the node from the buffer:
    (when-let (node (gotest-ui-thing-node test))
      (let ((buffer-read-only nil))
        (ewoc-delete gotest-ui--ewoc node))
      (setf (gotest-ui-thing-node test) nil))

    ;; Put it in the next secion:
    (when-let ((section* (assoc (gotest-ui-thing-status test)
                                gotest-ui--section-alist)))
      (let* ((section (cdr section*))
             (insertion-cons (gotest-ui-section-tests section)))
        (while (and (cdr insertion-cons)
                    (gotest-ui-test->= test (cadr insertion-cons)))
          (setq insertion-cons (cdr insertion-cons)))
        (rplacd insertion-cons (cons test (cdr insertion-cons)))
        (let ((insertion-node (if (car insertion-cons)
                                  (gotest-ui-thing-node (car insertion-cons))
                                (gotest-ui-section-node section))))
          (setf (gotest-ui-thing-node test)
                (ewoc-enter-after gotest-ui--ewoc insertion-node test)))
        (when (null (cddr (gotest-ui-section-tests section)))
          (push (gotest-ui-section-node section) invalidate-nodes))))
    (unless (null invalidate-nodes)
      (apply 'ewoc-invalidate gotest-ui--ewoc invalidate-nodes))
    (gotest-ui-thing-node test)))

;;;; Commands:

(defun gotest-ui-toggle-expanded ()
  "Toggle expandedness of a test/package node"
  (interactive)
  (let* ((node (ewoc-locate gotest-ui--ewoc (point)))
         (data (ewoc-data node)))
    (when (and data (gotest-ui-thing-p data))
      (setf (gotest-ui-thing-expanded-p data)
            (not (gotest-ui-thing-expanded-p data)))
      (ewoc-invalidate gotest-ui--ewoc node))))

(defun gotest-ui-rerun ()
  (interactive)
  (gotest-ui gotest-ui--cmdline :dir gotest-ui--dir))

;;;; Displaying the data:

(defvar-local gotest-ui--tests nil)
(defvar-local gotest-ui--section-alist nil)
(defvar-local gotest-ui--ewoc nil)
(defvar-local gotest-ui--status nil)
(defvar-local gotest-ui--process-buffer nil)
(defvar-local gotest-ui--stderr-process-buffer nil)
(defvar-local gotest-ui--ui-buffer nil)
(defvar-local gotest-ui--process nil)
(defvar-local gotest-ui--stderr-process nil)
(defvar-local gotest-ui--cmdline nil)
(defvar-local gotest-ui--dir nil)

(cl-defun gotest-ui (cmdline &key dir)
  (let* ((dir (or dir default-directory))
         (name (format "*go test: %s in %s" (s-join " " cmdline) dir))
         (buffer (get-buffer-create name)))
    (unless (eql buffer (current-buffer))
      (display-buffer buffer))
    (with-current-buffer buffer
      (let ((default-directory dir))
        (gotest-ui--clear-buffer buffer)
        (gotest-ui-mode)
        (gotest-ui--setup-buffer buffer name cmdline dir))
      (setq gotest-ui--stderr-process
            (make-pipe-process :name (s-concat name "(stderr)")
                               :buffer gotest-ui--stderr-process-buffer
                               :sentinel #'gotest-ui--stderr-process-sentinel
                               :filter #'gotest-ui-read-stderr))
      (setq gotest-ui--process
            (make-process :name name
                          :buffer gotest-ui--process-buffer
                          :sentinel #'gotest-ui--process-sentinel
                          :filter #'gotest-ui-read-stdout
                          :stderr gotest-ui--stderr-process
                          :command cmdline)))))

(defun gotest-ui-pp-status (status)
  (propertize (format "%s" status)
              'face
              (case status
                (fail 'gotest-ui-fail-face)
                (skip 'gotest-ui-skip-face)
                (pass 'gotest-ui-pass-face)
                (otherwise 'default))))

(defun gotest-ui--pp-test-output (test)
  (with-current-buffer (gotest-ui-ensure-output-buffer test)
    (propertize (buffer-substring (point-min) (point-max))
                'line-prefix "\t")))

(defun gotest-ui--pp-test (test)
  (cond
   ((gotest-ui-section-p test)
    (unless (null (cdr (gotest-ui-section-tests test)))
      (insert "\n" (gotest-ui-section-title test) "\n")))
   ((gotest-ui-status-p test)
    (insert (gotest-ui-pp-status (gotest-ui-status-state test)))
    (insert (format " %s in %s\n\n"
                    (gotest-ui-status-cmdline test)
                    (gotest-ui-status-dir test)))
    (unless (zerop (length (gotest-ui-status-output test)))
      (insert (format "\n\n%s" (gotest-ui-status-output test)))))
   ((gotest-ui-test-p test)
    (let ((status (gotest-ui-thing-status test))
          (package (gotest-ui-test-package test))
          (name (gotest-ui-thing-name test)))
      (insert (gotest-ui-pp-status status))
      (insert " ")
      (insert (if name
                  (format "%s.%s" package name)
                package))
      (when-let ((elapsed (gotest-ui-thing-elapsed test)))
        (insert (format " (%.3fs)" elapsed)))
      (when-let ((reason (gotest-ui-test-reason test)))
        (insert (format " [%s]" reason))))
    (when (and (gotest-ui-thing-expanded-p test)
               (> (length (gotest-ui--pp-test-output test)) 0))
      (insert "\n")
      (insert (gotest-ui--pp-test-output test)))
    (insert "\n"))))

;;;; Handling input:

(defun gotest-ui--process-sentinel (proc event)
  (let* ((process-buffer (process-buffer proc))
         (ui-buffer (with-current-buffer process-buffer gotest-ui--ui-buffer))
         (inhibit-quit t))
    (with-local-quit
      (with-current-buffer ui-buffer
        (cond
         ((string= event "finished\n")
          (gotest-ui-update-status 'pass))
         ((s-prefix-p "exited abnormally" event)
          (gotest-ui-update-status 'fail))
         (t
          (gotest-ui-update-status event)))))))

(defun gotest-ui--stderr-process-sentinel (proc event)
  ;; ignore all events
  nil)

(defun gotest-ui-read-stderr (proc input)
  (let* ((process-buffer (process-buffer proc))
         (ui-buffer (with-current-buffer process-buffer gotest-ui--ui-buffer))
         (inhibit-quit t))
    (with-local-quit
      (when (buffer-live-p process-buffer)
        (with-current-buffer process-buffer
          (gotest-ui-read-compiler-spew proc process-buffer ui-buffer input))))))

(defun gotest-ui-read-stdout (proc input)
  (let* ((process-buffer (process-buffer proc))
         (ui-buffer (with-current-buffer process-buffer gotest-ui--ui-buffer))
         (inhibit-quit t))
    (with-local-quit
      (when (buffer-live-p process-buffer)
        (gotest-ui-read-json process-buffer (process-mark proc) input)))))

(defun gotest-ui-read-json (process-buffer marker input)
  (with-current-buffer process-buffer
    (gotest-ui-read-json-1 process-buffer marker gotest-ui--ui-buffer input)))

(defvar-local gotest-ui--current-failing-test nil)

(defun gotest-ui-read-failing-package (ui-buffer)
  (when (looking-at "^# \\(.*\\)$")
    (let* ((package (match-string 1))
           test)
      (with-current-buffer ui-buffer
        (setq test (gotest-ui-ensure-test gotest-ui--ewoc package nil :status 'fail))
        (gotest-ui-maybe-expand test)
        (gotest-ui-sort-test-into-section test nil))
      (forward-line 1)
      test)))

(defun gotest-ui-read-compiler-spew (proc process-buffer ui-buffer input)
  (with-current-buffer process-buffer
    (save-excursion
      (goto-char (point-max))
      (insert input)
      (goto-char (process-mark proc))
      (while (and (/= (point-max) (line-end-position)) ; incomplete line
                  (/= (point-max) (point)))
        (cond
         (gotest-ui--current-failing-test
          (cond
           ((looking-at "^# \\(.*\\)$")
            (gotest-ui-read-failing-package ui-buffer))
           (t
            (let* ((line (buffer-substring (point) (line-end-position)))
                   (test gotest-ui--current-failing-test))
              (forward-line 1)
              (set-marker (process-mark proc) (point))
              (with-current-buffer ui-buffer
                (gotest-ui-update-thing-output test (concat line "\n"))
                (ewoc-invalidate gotest-ui--ewoc (gotest-ui-thing-node test)))))))
         (t
          (let ((test (gotest-ui-read-failing-package ui-buffer)))
            (setq gotest-ui--current-failing-test test)
            (set-marker (process-mark proc) (point))
            (with-current-buffer ui-buffer
              (ewoc-invalidate gotest-ui--ewoc (gotest-ui-thing-node test))))))))))

(defun gotest-ui-read-json-1 (process-buffer marker ui-buffer input)
  (with-current-buffer process-buffer
    (save-excursion
      ;; insert the chunk of output at the end
      (goto-char (point-max))
      (insert input)

      ;; try to read the next object (which is hopefully complete now):
      (let ((nodes
             (cl-loop
              for (node . continue) = (gotest-ui-read-test-event process-buffer marker ui-buffer)
              when node collect node into nodes
              while continue
              finally (return nodes))))
        (when nodes
          (with-current-buffer ui-buffer
            (apply #'ewoc-invalidate gotest-ui--ewoc
                   (cl-remove-if-not (lambda (node) (marker-buffer (ewoc-location node))) (cl-remove-duplicates nodes)))))))))

(defun gotest-ui-read-test-event (process-buffer marker ui-buffer)
  (goto-char marker)
  (when (= (point) (line-end-position))
    (forward-line 1))
  (case (char-after (point))
    (?\{
     ;; It's JSON:
     (condition-case err
         (let ((obj (json-read)))
           (set-marker marker (point))
           (with-current-buffer ui-buffer
             (cons (gotest-ui-update-test-status obj) t)))
       (json-error (cons nil nil))
       (wrong-type-argument
        (if (and (eql (cadr err) 'characterp)
                 (eql (caddr err) :json-eof))
            ;; This is peaceful & we can ignore it:
            (cons nil nil)
          (signal 'wrong-type-argument err)))))
    (?\F
     ;; It's a compiler error:
     (when (looking-at "^FAIL\t\\(.*\\)\s+\\[\\([^]]+\\)\\]\n")
       (let* ((package-name (match-string 1))
              (reason (match-string 2))
              test node)
         (with-current-buffer ui-buffer
           (setq test (gotest-ui-ensure-test gotest-ui--ewoc package-name nil :status 'fail)
                 node (gotest-ui-thing-node test))
           (setf (gotest-ui-test-reason test) reason)
           (gotest-ui-sort-test-into-section test nil)
           (gotest-ui-maybe-expand test))
         (forward-line 1)
         (set-marker marker (point))
         (cons node t))))
    (otherwise
     ;; We're done:
     (cons nil nil))))

(defun gotest-ui-maybe-expand (test)
  (when (memq (gotest-ui-test-status test) gotest-ui-expand-test-statuses)
    (setf (gotest-ui-test-expanded-p test) t)))

(defun gotest-ui-update-test-status (json)
  (let-alist json
    (let* ((action (intern .Action))
           (test (gotest-ui-ensure-test gotest-ui--ewoc .Package .Test))
           (previous-status (gotest-ui-thing-status test)))
      (case action
        (run
         (gotest-ui-sort-test-into-section test nil))
        (output (gotest-ui-update-thing-output test .Output))
        (pass
         (setf (gotest-ui-thing-status test) 'pass
               (gotest-ui-thing-elapsed test) .Elapsed)
         (gotest-ui-sort-test-into-section test previous-status)
         (gotest-ui-maybe-expand test))
        (fail
         (setf (gotest-ui-thing-status test) 'fail
               (gotest-ui-thing-elapsed test) .Elapsed)
         (gotest-ui-sort-test-into-section test previous-status)
         (gotest-ui-maybe-expand test))
        (skip
         (setf (gotest-ui-thing-status test) 'skip
               (gotest-ui-thing-elapsed test) .Elapsed)
         (gotest-ui-sort-test-into-section test previous-status)
         (gotest-ui-maybe-expand test))
        (otherwise
         (setq test nil)))
      (when test (gotest-ui-thing-node test)))))

;;;; Commands for go-mode:

(defun gotest-ui--command-line (&rest cmdline)
  (append gotest-ui-test-binary gotest-ui-test-args gotest-ui-additional-test-args
          cmdline))

;;;###autoload
(defun gotest-ui-current-test ()
  "Launch go test with the test that (point) is in."
  (interactive)
  (cl-destructuring-bind (test-suite test-name) (go-test--get-current-test-info)
    (let ((test-flag (if (> (length test-suite) 0) "-m" "-run")))
      (when test-name
        (gotest-ui (gotest-ui--command-line test-flag (s-concat test-name "$") "."))))))

;;;###autoload
(defun gotest-ui-current-file ()
  "Launch go test on the current buffer file."
  (interactive)
  (let* ((data (go-test--get-current-file-testing-data))
         (run-flag (s-concat "-run=" data "$")))
    (gotest-ui (gotest-ui--command-line run-flag "."))))

;;;###autoload
(defun gotest-ui-current-project ()
  "Launch go test on the current buffer's project."
  (interactive)
  (let ((default-directory (projectile-project-root)))
    (gotest-ui (gotest-ui--command-line "./..."))))

(provide 'gotest-ui)

;;; gotest-ui.el ends here
#+end_src
